"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key2, value) => key2 in obj ? __defProp(obj, key2, { enumerable: true, configurable: true, writable: true, value }) : obj[key2] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name3 in all)
      __defProp(target, name3, { get: all[name3], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key2 of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key2) && key2 !== except)
          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
  var __decorateClass = (decorators, target, key2, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key2) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key2, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key2, result);
    return result;
  };
  var __decorateParam = (index, decorator) => (target, key2) => decorator(target, key2, index);
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };

  // ../../../node_modules/tslib/tslib.js
  var require_tslib = __commonJS({
    "../../../node_modules/tslib/tslib.js"(exports, module) {
      var __extends2;
      var __assign3;
      var __rest2;
      var __decorate2;
      var __param2;
      var __metadata2;
      var __awaiter2;
      var __generator2;
      var __exportStar2;
      var __values2;
      var __read2;
      var __spread2;
      var __spreadArrays2;
      var __spreadArray2;
      var __await2;
      var __asyncGenerator2;
      var __asyncDelegator2;
      var __asyncValues2;
      var __makeTemplateObject2;
      var __importStar2;
      var __importDefault2;
      var __classPrivateFieldGet2;
      var __classPrivateFieldSet2;
      var __classPrivateFieldIn2;
      var __createBinding2;
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
        if (typeof define === "function" && define.amd) {
          define("tslib", ["exports"], function(exports2) {
            factory(createExporter(root, createExporter(exports2)));
          });
        } else if (typeof module === "object" && typeof module.exports === "object") {
          factory(createExporter(root, createExporter(module.exports)));
        } else {
          factory(createExporter(root));
        }
        function createExporter(exports2, previous) {
          if (exports2 !== root) {
            if (typeof Object.create === "function") {
              Object.defineProperty(exports2, "__esModule", { value: true });
            } else {
              exports2.__esModule = true;
            }
          }
          return function(id, v) {
            return exports2[id] = previous ? previous(id, v) : v;
          };
        }
      })(function(exporter) {
        var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b)
            if (Object.prototype.hasOwnProperty.call(b, p))
              d[p] = b[p];
        };
        __extends2 = function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
        __assign3 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        __rest2 = function(s, e) {
          var t = {};
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
              t[p] = s[p];
          if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
              if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
            }
          return t;
        };
        __decorate2 = function(decorators, target, key2, desc) {
          var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key2) : desc, d;
          if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key2, desc);
          else
            for (var i = decorators.length - 1; i >= 0; i--)
              if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key2, r) : d(target, key2)) || r;
          return c > 3 && r && Object.defineProperty(target, key2, r), r;
        };
        __param2 = function(paramIndex, decorator) {
          return function(target, key2) {
            decorator(target, key2, paramIndex);
          };
        };
        __metadata2 = function(metadataKey, metadataValue) {
          if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
        };
        __awaiter2 = function(thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P ? value : new P(function(resolve) {
              resolve(value);
            });
          }
          return new (P || (P = Promise))(function(resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
            }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        __generator2 = function(thisArg, body) {
          var _ = { label: 0, sent: function() {
            if (t[0] & 1)
              throw t[1];
            return t[1];
          }, trys: [], ops: [] }, f2, y, t, g;
          return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
            return this;
          }), g;
          function verb(n) {
            return function(v) {
              return step([n, v]);
            };
          }
          function step(op) {
            if (f2)
              throw new TypeError("Generator is already executing.");
            while (_)
              try {
                if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                  return t;
                if (y = 0, t)
                  op = [op[0] & 2, t.value];
                switch (op[0]) {
                  case 0:
                  case 1:
                    t = op;
                    break;
                  case 4:
                    _.label++;
                    return { value: op[1], done: false };
                  case 5:
                    _.label++;
                    y = op[1];
                    op = [0];
                    continue;
                  case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                  default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                      _ = 0;
                      continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                      _.label = op[1];
                      break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                      _.label = t[1];
                      t = op;
                      break;
                    }
                    if (t && _.label < t[2]) {
                      _.label = t[2];
                      _.ops.push(op);
                      break;
                    }
                    if (t[2])
                      _.ops.pop();
                    _.trys.pop();
                    continue;
                }
                op = body.call(thisArg, _);
              } catch (e) {
                op = [6, e];
                y = 0;
              } finally {
                f2 = t = 0;
              }
            if (op[0] & 5)
              throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
          }
        };
        __exportStar2 = function(m, o) {
          for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
              __createBinding2(o, m, p);
        };
        __createBinding2 = Object.create ? function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          var desc = Object.getOwnPropertyDescriptor(m, k);
          if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
            desc = { enumerable: true, get: function() {
              return m[k];
            } };
          }
          Object.defineProperty(o, k2, desc);
        } : function(o, m, k, k2) {
          if (k2 === void 0)
            k2 = k;
          o[k2] = m[k];
        };
        __values2 = function(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m)
            return m.call(o);
          if (o && typeof o.length === "number")
            return {
              next: function() {
                if (o && i >= o.length)
                  o = void 0;
                return { value: o && o[i++], done: !o };
              }
            };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        };
        __read2 = function(o, n) {
          var m = typeof Symbol === "function" && o[Symbol.iterator];
          if (!m)
            return o;
          var i = m.call(o), r, ar = [], e;
          try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
              ar.push(r.value);
          } catch (error) {
            e = { error };
          } finally {
            try {
              if (r && !r.done && (m = i["return"]))
                m.call(i);
            } finally {
              if (e)
                throw e.error;
            }
          }
          return ar;
        };
        __spread2 = function() {
          for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read2(arguments[i]));
          return ar;
        };
        __spreadArrays2 = function() {
          for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
          for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
              r[k] = a[j];
          return r;
        };
        __spreadArray2 = function(to, from, pack) {
          if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
              if (ar || !(i in from)) {
                if (!ar)
                  ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
              }
            }
          return to.concat(ar || Array.prototype.slice.call(from));
        };
        __await2 = function(v) {
          return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
        };
        __asyncGenerator2 = function(thisArg, _arguments, generator) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var g = generator.apply(thisArg, _arguments || []), i, q = [];
          return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i;
          function verb(n) {
            if (g[n])
              i[n] = function(v) {
                return new Promise(function(a, b) {
                  q.push([n, v, a, b]) > 1 || resume(n, v);
                });
              };
          }
          function resume(n, v) {
            try {
              step(g[n](v));
            } catch (e) {
              settle(q[0][3], e);
            }
          }
          function step(r) {
            r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
          }
          function fulfill(value) {
            resume("next", value);
          }
          function reject(value) {
            resume("throw", value);
          }
          function settle(f2, v) {
            if (f2(v), q.shift(), q.length)
              resume(q[0][0], q[0][1]);
          }
        };
        __asyncDelegator2 = function(o) {
          var i, p;
          return i = {}, verb("next"), verb("throw", function(e) {
            throw e;
          }), verb("return"), i[Symbol.iterator] = function() {
            return this;
          }, i;
          function verb(n, f2) {
            i[n] = o[n] ? function(v) {
              return (p = !p) ? { value: __await2(o[n](v)), done: n === "return" } : f2 ? f2(v) : v;
            } : f2;
          }
        };
        __asyncValues2 = function(o) {
          if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
          var m = o[Symbol.asyncIterator], i;
          return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
            return this;
          }, i);
          function verb(n) {
            i[n] = o[n] && function(v) {
              return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
              });
            };
          }
          function settle(resolve, reject, d, v) {
            Promise.resolve(v).then(function(v2) {
              resolve({ value: v2, done: d });
            }, reject);
          }
        };
        __makeTemplateObject2 = function(cooked, raw) {
          if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
          } else {
            cooked.raw = raw;
          }
          return cooked;
        };
        var __setModuleDefault = Object.create ? function(o, v) {
          Object.defineProperty(o, "default", { enumerable: true, value: v });
        } : function(o, v) {
          o["default"] = v;
        };
        __importStar2 = function(mod) {
          if (mod && mod.__esModule)
            return mod;
          var result = {};
          if (mod != null) {
            for (var k in mod)
              if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                __createBinding2(result, mod, k);
          }
          __setModuleDefault(result, mod);
          return result;
        };
        __importDefault2 = function(mod) {
          return mod && mod.__esModule ? mod : { "default": mod };
        };
        __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
          if (kind === "a" && !f2)
            throw new TypeError("Private accessor was defined without a getter");
          if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
          return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
        };
        __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
          if (kind === "m")
            throw new TypeError("Private method is not writable");
          if (kind === "a" && !f2)
            throw new TypeError("Private accessor was defined without a setter");
          if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
          return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
        };
        __classPrivateFieldIn2 = function(state, receiver) {
          if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
            throw new TypeError("Cannot use 'in' operator on non-object");
          return typeof state === "function" ? receiver === state : state.has(receiver);
        };
        exporter("__extends", __extends2);
        exporter("__assign", __assign3);
        exporter("__rest", __rest2);
        exporter("__decorate", __decorate2);
        exporter("__param", __param2);
        exporter("__metadata", __metadata2);
        exporter("__awaiter", __awaiter2);
        exporter("__generator", __generator2);
        exporter("__exportStar", __exportStar2);
        exporter("__createBinding", __createBinding2);
        exporter("__values", __values2);
        exporter("__read", __read2);
        exporter("__spread", __spread2);
        exporter("__spreadArrays", __spreadArrays2);
        exporter("__spreadArray", __spreadArray2);
        exporter("__await", __await2);
        exporter("__asyncGenerator", __asyncGenerator2);
        exporter("__asyncDelegator", __asyncDelegator2);
        exporter("__asyncValues", __asyncValues2);
        exporter("__makeTemplateObject", __makeTemplateObject2);
        exporter("__importStar", __importStar2);
        exporter("__importDefault", __importDefault2);
        exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
        exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
        exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
      });
    }
  });

  // ../src/lib/predefineTinypass.ts
  window.pnFullTPVersion = true;

  // ../src/lib/commonPolyfill.ts
  if (typeof Object.assign != "function") {
    Object.defineProperty(Object, "assign", {
      value: function assign(target, varArgs) {
        "use strict";
        if (target == null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        var to = Object(target);
        for (var index = 1; index < arguments.length; index++) {
          var nextSource = arguments[index];
          if (nextSource != null) {
            for (var nextKey in nextSource) {
              if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
        return to;
      },
      writable: true,
      configurable: true
    });
  }
  var Metadata = /* @__PURE__ */ new WeakMap();
  function decorateProperty(decorators, target, propertyKey, descriptor) {
    decorators.reverse().forEach((decorator) => {
      descriptor = decorator(target, propertyKey, descriptor) || descriptor;
    });
    return descriptor;
  }
  function decorateConstructor(decorators, target) {
    decorators.reverse().forEach((decorator) => {
      const decorated = decorator(target);
      if (decorated) {
        target = decorated;
      }
    });
    return target;
  }
  function decorate(decorators, target, propertyKey, attributes) {
    if (!Array.isArray(decorators) || decorators.length === 0) {
      throw new TypeError();
    }
    if (propertyKey !== void 0) {
      return decorateProperty(decorators, target, propertyKey, attributes);
    }
    if (typeof target === "function") {
      return decorateConstructor(decorators, target);
    }
    return;
  }
  function getMetadataMap(target, propertyKey) {
    return Metadata.get(target) && Metadata.get(target).get(propertyKey);
  }
  function ordinaryGetOwnMetadata(metadataKey, target, propertyKey) {
    if (target === void 0) {
      throw new TypeError();
    }
    const metadataMap = getMetadataMap(target, propertyKey);
    return metadataMap && metadataMap.get(metadataKey);
  }
  function createMetadataMap(target, propertyKey) {
    const targetMetadata = Metadata.get(target) || /* @__PURE__ */ new Map();
    Metadata.set(target, targetMetadata);
    const metadataMap = targetMetadata.get(propertyKey) || /* @__PURE__ */ new Map();
    targetMetadata.set(propertyKey, metadataMap);
    return metadataMap;
  }
  function ordinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey) {
    if (propertyKey && !["string", "symbol"].includes(typeof propertyKey)) {
      throw new TypeError();
    }
    (getMetadataMap(target, propertyKey) || createMetadataMap(target, propertyKey)).set(metadataKey, metadataValue);
  }
  function ordinaryGetMetadata(metadataKey, target, propertyKey) {
    return ordinaryGetOwnMetadata(metadataKey, target, propertyKey) ? ordinaryGetOwnMetadata(metadataKey, target, propertyKey) : Object.getPrototypeOf(target) ? ordinaryGetMetadata(metadataKey, Object.getPrototypeOf(target), propertyKey) : void 0;
  }
  function metadata(metadataKey, metadataValue) {
    return function decorator(target, propertyKey) {
      ordinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    };
  }
  function getMetadata(metadataKey, target, propertyKey) {
    return ordinaryGetMetadata(metadataKey, target, propertyKey);
  }
  function getOwnMetadata(metadataKey, target, propertyKey) {
    return ordinaryGetOwnMetadata(metadataKey, target, propertyKey);
  }
  function hasOwnMetadata(metadataKey, target, propertyKey) {
    return !!ordinaryGetOwnMetadata(metadataKey, target, propertyKey);
  }
  function hasMetadata(metadataKey, target, propertyKey) {
    return !!ordinaryGetMetadata(metadataKey, target, propertyKey);
  }
  function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
    ordinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
  }
  var Reflection = {
    decorate,
    defineMetadata,
    getMetadata,
    getOwnMetadata,
    hasMetadata,
    hasOwnMetadata,
    metadata
  };
  window.Reflect = window.Reflect || {};
  Object.assign(window.Reflect, Reflection);

  // ../../../node_modules/tsyringe/dist/esm5/types/lifecycle.js
  var Lifecycle;
  (function(Lifecycle2) {
    Lifecycle2[Lifecycle2["Transient"] = 0] = "Transient";
    Lifecycle2[Lifecycle2["Singleton"] = 1] = "Singleton";
    Lifecycle2[Lifecycle2["ResolutionScoped"] = 2] = "ResolutionScoped";
    Lifecycle2[Lifecycle2["ContainerScoped"] = 3] = "ContainerScoped";
  })(Lifecycle || (Lifecycle = {}));
  var lifecycle_default = Lifecycle;

  // ../../../node_modules/tslib/modules/index.js
  var import_tslib = __toESM(require_tslib(), 1);
  var {
    __extends,
    __assign,
    __rest,
    __decorate,
    __param,
    __metadata,
    __awaiter,
    __generator,
    __exportStar,
    __createBinding,
    __values,
    __read,
    __spread,
    __spreadArrays,
    __spreadArray,
    __await,
    __asyncGenerator,
    __asyncDelegator,
    __asyncValues,
    __makeTemplateObject,
    __importStar,
    __importDefault,
    __classPrivateFieldGet,
    __classPrivateFieldSet,
    __classPrivateFieldIn
  } = import_tslib.default;

  // ../../../node_modules/tsyringe/dist/esm5/reflection-helpers.js
  var INJECTION_TOKEN_METADATA_KEY = "injectionTokens";
  function getParamInfo(target) {
    var params = Reflect.getMetadata("design:paramtypes", target) || [];
    var injectionTokens = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
    Object.keys(injectionTokens).forEach(function(key2) {
      params[+key2] = injectionTokens[key2];
    });
    return params;
  }
  function defineInjectionTokenMetadata(data, transform) {
    return function(target, _propertyKey, parameterIndex) {
      var descriptors = Reflect.getOwnMetadata(INJECTION_TOKEN_METADATA_KEY, target) || {};
      descriptors[parameterIndex] = transform ? {
        token: data,
        transform: transform.transformToken,
        transformArgs: transform.args || []
      } : data;
      Reflect.defineMetadata(INJECTION_TOKEN_METADATA_KEY, descriptors, target);
    };
  }

  // ../../../node_modules/tsyringe/dist/esm5/providers/class-provider.js
  function isClassProvider(provider) {
    return !!provider.useClass;
  }

  // ../../../node_modules/tsyringe/dist/esm5/providers/factory-provider.js
  function isFactoryProvider(provider) {
    return !!provider.useFactory;
  }

  // ../../../node_modules/tsyringe/dist/esm5/lazy-helpers.js
  var DelayedConstructor = function() {
    function DelayedConstructor2(wrap) {
      this.wrap = wrap;
      this.reflectMethods = [
        "get",
        "getPrototypeOf",
        "setPrototypeOf",
        "getOwnPropertyDescriptor",
        "defineProperty",
        "has",
        "set",
        "deleteProperty",
        "apply",
        "construct",
        "ownKeys"
      ];
    }
    DelayedConstructor2.prototype.createProxy = function(createObject) {
      var _this = this;
      var target = {};
      var init = false;
      var value;
      var delayedObject = function() {
        if (!init) {
          value = createObject(_this.wrap());
          init = true;
        }
        return value;
      };
      return new Proxy(target, this.createHandler(delayedObject));
    };
    DelayedConstructor2.prototype.createHandler = function(delayedObject) {
      var handler = {};
      var install = function(name3) {
        handler[name3] = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          args[0] = delayedObject();
          var method = Reflect[name3];
          return method.apply(void 0, __spread(args));
        };
      };
      this.reflectMethods.forEach(install);
      return handler;
    };
    return DelayedConstructor2;
  }();

  // ../../../node_modules/tsyringe/dist/esm5/providers/injection-token.js
  function isNormalToken(token) {
    return typeof token === "string" || typeof token === "symbol";
  }
  function isTokenDescriptor(descriptor) {
    return typeof descriptor === "object" && "token" in descriptor && "multiple" in descriptor;
  }
  function isTransformDescriptor(descriptor) {
    return typeof descriptor === "object" && "token" in descriptor && "transform" in descriptor;
  }
  function isConstructorToken(token) {
    return typeof token === "function" || token instanceof DelayedConstructor;
  }

  // ../../../node_modules/tsyringe/dist/esm5/providers/token-provider.js
  function isTokenProvider(provider) {
    return !!provider.useToken;
  }

  // ../../../node_modules/tsyringe/dist/esm5/providers/value-provider.js
  function isValueProvider(provider) {
    return provider.useValue != void 0;
  }

  // ../../../node_modules/tsyringe/dist/esm5/providers/provider.js
  function isProvider(provider) {
    return isClassProvider(provider) || isValueProvider(provider) || isTokenProvider(provider) || isFactoryProvider(provider);
  }

  // ../../../node_modules/tsyringe/dist/esm5/registry-base.js
  var RegistryBase = function() {
    function RegistryBase2() {
      this._registryMap = /* @__PURE__ */ new Map();
    }
    RegistryBase2.prototype.entries = function() {
      return this._registryMap.entries();
    };
    RegistryBase2.prototype.getAll = function(key2) {
      this.ensure(key2);
      return this._registryMap.get(key2);
    };
    RegistryBase2.prototype.get = function(key2) {
      this.ensure(key2);
      var value = this._registryMap.get(key2);
      return value[value.length - 1] || null;
    };
    RegistryBase2.prototype.set = function(key2, value) {
      this.ensure(key2);
      this._registryMap.get(key2).push(value);
    };
    RegistryBase2.prototype.setAll = function(key2, value) {
      this._registryMap.set(key2, value);
    };
    RegistryBase2.prototype.has = function(key2) {
      this.ensure(key2);
      return this._registryMap.get(key2).length > 0;
    };
    RegistryBase2.prototype.clear = function() {
      this._registryMap.clear();
    };
    RegistryBase2.prototype.ensure = function(key2) {
      if (!this._registryMap.has(key2)) {
        this._registryMap.set(key2, []);
      }
    };
    return RegistryBase2;
  }();
  var registry_base_default = RegistryBase;

  // ../../../node_modules/tsyringe/dist/esm5/registry.js
  var Registry = function(_super) {
    __extends(Registry2, _super);
    function Registry2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return Registry2;
  }(registry_base_default);
  var registry_default = Registry;

  // ../../../node_modules/tsyringe/dist/esm5/resolution-context.js
  var ResolutionContext = function() {
    function ResolutionContext2() {
      this.scopedResolutions = /* @__PURE__ */ new Map();
    }
    return ResolutionContext2;
  }();
  var resolution_context_default = ResolutionContext;

  // ../../../node_modules/tsyringe/dist/esm5/error-helpers.js
  function formatDependency(params, idx) {
    if (params === null) {
      return "at position #" + idx;
    }
    var argName = params.split(",")[idx].trim();
    return '"' + argName + '" at position #' + idx;
  }
  function composeErrorMessage(msg, e, indent) {
    if (indent === void 0) {
      indent = "    ";
    }
    return __spread([msg], e.message.split("\n").map(function(l) {
      return indent + l;
    })).join("\n");
  }
  function formatErrorCtor(ctor, paramIdx, error) {
    var _a = __read(ctor.toString().match(/constructor\(([\w, ]+)\)/) || [], 2), _b = _a[1], params = _b === void 0 ? null : _b;
    var dep = formatDependency(params, paramIdx);
    return composeErrorMessage("Cannot inject the dependency " + dep + ' of "' + ctor.name + '" constructor. Reason:', error);
  }

  // ../../../node_modules/tsyringe/dist/esm5/types/disposable.js
  function isDisposable(value) {
    if (typeof value.dispose !== "function")
      return false;
    var disposeFun = value.dispose;
    if (disposeFun.length > 0) {
      return false;
    }
    return true;
  }

  // ../../../node_modules/tsyringe/dist/esm5/interceptors.js
  var PreResolutionInterceptors = function(_super) {
    __extends(PreResolutionInterceptors2, _super);
    function PreResolutionInterceptors2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return PreResolutionInterceptors2;
  }(registry_base_default);
  var PostResolutionInterceptors = function(_super) {
    __extends(PostResolutionInterceptors2, _super);
    function PostResolutionInterceptors2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    return PostResolutionInterceptors2;
  }(registry_base_default);
  var Interceptors = function() {
    function Interceptors2() {
      this.preResolution = new PreResolutionInterceptors();
      this.postResolution = new PostResolutionInterceptors();
    }
    return Interceptors2;
  }();
  var interceptors_default = Interceptors;

  // ../../../node_modules/tsyringe/dist/esm5/dependency-container.js
  var typeInfo = /* @__PURE__ */ new Map();
  var InternalDependencyContainer = function() {
    function InternalDependencyContainer2(parent2) {
      this.parent = parent2;
      this._registry = new registry_default();
      this.interceptors = new interceptors_default();
      this.disposed = false;
      this.disposables = /* @__PURE__ */ new Set();
    }
    InternalDependencyContainer2.prototype.register = function(token, providerOrConstructor, options) {
      if (options === void 0) {
        options = { lifecycle: lifecycle_default.Transient };
      }
      this.ensureNotDisposed();
      var provider;
      if (!isProvider(providerOrConstructor)) {
        provider = { useClass: providerOrConstructor };
      } else {
        provider = providerOrConstructor;
      }
      if (isTokenProvider(provider)) {
        var path = [token];
        var tokenProvider = provider;
        while (tokenProvider != null) {
          var currentToken = tokenProvider.useToken;
          if (path.includes(currentToken)) {
            throw new Error("Token registration cycle detected! " + __spread(path, [currentToken]).join(" -> "));
          }
          path.push(currentToken);
          var registration = this._registry.get(currentToken);
          if (registration && isTokenProvider(registration.provider)) {
            tokenProvider = registration.provider;
          } else {
            tokenProvider = null;
          }
        }
      }
      if (options.lifecycle === lifecycle_default.Singleton || options.lifecycle == lifecycle_default.ContainerScoped || options.lifecycle == lifecycle_default.ResolutionScoped) {
        if (isValueProvider(provider) || isFactoryProvider(provider)) {
          throw new Error('Cannot use lifecycle "' + lifecycle_default[options.lifecycle] + '" with ValueProviders or FactoryProviders');
        }
      }
      this._registry.set(token, { provider, options });
      return this;
    };
    InternalDependencyContainer2.prototype.registerType = function(from, to) {
      this.ensureNotDisposed();
      if (isNormalToken(to)) {
        return this.register(from, {
          useToken: to
        });
      }
      return this.register(from, {
        useClass: to
      });
    };
    InternalDependencyContainer2.prototype.registerInstance = function(token, instance2) {
      this.ensureNotDisposed();
      return this.register(token, {
        useValue: instance2
      });
    };
    InternalDependencyContainer2.prototype.registerSingleton = function(from, to) {
      this.ensureNotDisposed();
      if (isNormalToken(from)) {
        if (isNormalToken(to)) {
          return this.register(from, {
            useToken: to
          }, { lifecycle: lifecycle_default.Singleton });
        } else if (to) {
          return this.register(from, {
            useClass: to
          }, { lifecycle: lifecycle_default.Singleton });
        }
        throw new Error('Cannot register a type name as a singleton without a "to" token');
      }
      var useClass = from;
      if (to && !isNormalToken(to)) {
        useClass = to;
      }
      return this.register(from, {
        useClass
      }, { lifecycle: lifecycle_default.Singleton });
    };
    InternalDependencyContainer2.prototype.resolve = function(token, context) {
      if (context === void 0) {
        context = new resolution_context_default();
      }
      this.ensureNotDisposed();
      var registration = this.getRegistration(token);
      if (!registration && isNormalToken(token)) {
        throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
      }
      this.executePreResolutionInterceptor(token, "Single");
      if (registration) {
        var result = this.resolveRegistration(registration, context);
        this.executePostResolutionInterceptor(token, result, "Single");
        return result;
      }
      if (isConstructorToken(token)) {
        var result = this.construct(token, context);
        this.executePostResolutionInterceptor(token, result, "Single");
        return result;
      }
      throw new Error("Attempted to construct an undefined constructor. Could mean a circular dependency problem. Try using `delay` function.");
    };
    InternalDependencyContainer2.prototype.executePreResolutionInterceptor = function(token, resolutionType) {
      var e_1, _a;
      if (this.interceptors.preResolution.has(token)) {
        var remainingInterceptors = [];
        try {
          for (var _b = __values(this.interceptors.preResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var interceptor = _c.value;
            if (interceptor.options.frequency != "Once") {
              remainingInterceptors.push(interceptor);
            }
            interceptor.callback(token, resolutionType);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        this.interceptors.preResolution.setAll(token, remainingInterceptors);
      }
    };
    InternalDependencyContainer2.prototype.executePostResolutionInterceptor = function(token, result, resolutionType) {
      var e_2, _a;
      if (this.interceptors.postResolution.has(token)) {
        var remainingInterceptors = [];
        try {
          for (var _b = __values(this.interceptors.postResolution.getAll(token)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var interceptor = _c.value;
            if (interceptor.options.frequency != "Once") {
              remainingInterceptors.push(interceptor);
            }
            interceptor.callback(token, result, resolutionType);
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        this.interceptors.postResolution.setAll(token, remainingInterceptors);
      }
    };
    InternalDependencyContainer2.prototype.resolveRegistration = function(registration, context) {
      this.ensureNotDisposed();
      if (registration.options.lifecycle === lifecycle_default.ResolutionScoped && context.scopedResolutions.has(registration)) {
        return context.scopedResolutions.get(registration);
      }
      var isSingleton = registration.options.lifecycle === lifecycle_default.Singleton;
      var isContainerScoped = registration.options.lifecycle === lifecycle_default.ContainerScoped;
      var returnInstance = isSingleton || isContainerScoped;
      var resolved;
      if (isValueProvider(registration.provider)) {
        resolved = registration.provider.useValue;
      } else if (isTokenProvider(registration.provider)) {
        resolved = returnInstance ? registration.instance || (registration.instance = this.resolve(registration.provider.useToken, context)) : this.resolve(registration.provider.useToken, context);
      } else if (isClassProvider(registration.provider)) {
        resolved = returnInstance ? registration.instance || (registration.instance = this.construct(registration.provider.useClass, context)) : this.construct(registration.provider.useClass, context);
      } else if (isFactoryProvider(registration.provider)) {
        resolved = registration.provider.useFactory(this);
      } else {
        resolved = this.construct(registration.provider, context);
      }
      if (registration.options.lifecycle === lifecycle_default.ResolutionScoped) {
        context.scopedResolutions.set(registration, resolved);
      }
      return resolved;
    };
    InternalDependencyContainer2.prototype.resolveAll = function(token, context) {
      var _this = this;
      if (context === void 0) {
        context = new resolution_context_default();
      }
      this.ensureNotDisposed();
      var registrations = this.getAllRegistrations(token);
      if (!registrations && isNormalToken(token)) {
        throw new Error('Attempted to resolve unregistered dependency token: "' + token.toString() + '"');
      }
      this.executePreResolutionInterceptor(token, "All");
      if (registrations) {
        var result_1 = registrations.map(function(item) {
          return _this.resolveRegistration(item, context);
        });
        this.executePostResolutionInterceptor(token, result_1, "All");
        return result_1;
      }
      var result = [this.construct(token, context)];
      this.executePostResolutionInterceptor(token, result, "All");
      return result;
    };
    InternalDependencyContainer2.prototype.isRegistered = function(token, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      this.ensureNotDisposed();
      return this._registry.has(token) || recursive && (this.parent || false) && this.parent.isRegistered(token, true);
    };
    InternalDependencyContainer2.prototype.reset = function() {
      this.ensureNotDisposed();
      this._registry.clear();
      this.interceptors.preResolution.clear();
      this.interceptors.postResolution.clear();
    };
    InternalDependencyContainer2.prototype.clearInstances = function() {
      var e_3, _a;
      this.ensureNotDisposed();
      try {
        for (var _b = __values(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
          this._registry.setAll(token, registrations.filter(function(registration) {
            return !isValueProvider(registration.provider);
          }).map(function(registration) {
            registration.instance = void 0;
            return registration;
          }));
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    };
    InternalDependencyContainer2.prototype.createChildContainer = function() {
      var e_4, _a;
      this.ensureNotDisposed();
      var childContainer = new InternalDependencyContainer2(this);
      try {
        for (var _b = __values(this._registry.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var _d = __read(_c.value, 2), token = _d[0], registrations = _d[1];
          if (registrations.some(function(_a2) {
            var options = _a2.options;
            return options.lifecycle === lifecycle_default.ContainerScoped;
          })) {
            childContainer._registry.setAll(token, registrations.map(function(registration) {
              if (registration.options.lifecycle === lifecycle_default.ContainerScoped) {
                return {
                  provider: registration.provider,
                  options: registration.options
                };
              }
              return registration;
            }));
          }
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return childContainer;
    };
    InternalDependencyContainer2.prototype.beforeResolution = function(token, callback, options) {
      if (options === void 0) {
        options = { frequency: "Always" };
      }
      this.interceptors.preResolution.set(token, {
        callback,
        options
      });
    };
    InternalDependencyContainer2.prototype.afterResolution = function(token, callback, options) {
      if (options === void 0) {
        options = { frequency: "Always" };
      }
      this.interceptors.postResolution.set(token, {
        callback,
        options
      });
    };
    InternalDependencyContainer2.prototype.dispose = function() {
      return __awaiter(this, void 0, void 0, function() {
        var promises;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              this.disposed = true;
              promises = [];
              this.disposables.forEach(function(disposable) {
                var maybePromise = disposable.dispose();
                if (maybePromise) {
                  promises.push(maybePromise);
                }
              });
              return [4, Promise.all(promises)];
            case 1:
              _a.sent();
              return [2];
          }
        });
      });
    };
    InternalDependencyContainer2.prototype.getRegistration = function(token) {
      if (this.isRegistered(token)) {
        return this._registry.get(token);
      }
      if (this.parent) {
        return this.parent.getRegistration(token);
      }
      return null;
    };
    InternalDependencyContainer2.prototype.getAllRegistrations = function(token) {
      if (this.isRegistered(token)) {
        return this._registry.getAll(token);
      }
      if (this.parent) {
        return this.parent.getAllRegistrations(token);
      }
      return null;
    };
    InternalDependencyContainer2.prototype.construct = function(ctor, context) {
      var _this = this;
      if (ctor instanceof DelayedConstructor) {
        return ctor.createProxy(function(target) {
          return _this.resolve(target, context);
        });
      }
      var instance2 = function() {
        var paramInfo = typeInfo.get(ctor);
        if (!paramInfo || paramInfo.length === 0) {
          if (ctor.length === 0) {
            return new ctor();
          } else {
            throw new Error('TypeInfo not known for "' + ctor.name + '"');
          }
        }
        var params = paramInfo.map(_this.resolveParams(context, ctor));
        return new (ctor.bind.apply(ctor, __spread([void 0], params)))();
      }();
      if (isDisposable(instance2)) {
        this.disposables.add(instance2);
      }
      return instance2;
    };
    InternalDependencyContainer2.prototype.resolveParams = function(context, ctor) {
      var _this = this;
      return function(param2, idx) {
        var _a, _b, _c;
        try {
          if (isTokenDescriptor(param2)) {
            if (isTransformDescriptor(param2)) {
              return param2.multiple ? (_a = _this.resolve(param2.transform)).transform.apply(_a, __spread([_this.resolveAll(param2.token)], param2.transformArgs)) : (_b = _this.resolve(param2.transform)).transform.apply(_b, __spread([_this.resolve(param2.token, context)], param2.transformArgs));
            } else {
              return param2.multiple ? _this.resolveAll(param2.token) : _this.resolve(param2.token, context);
            }
          } else if (isTransformDescriptor(param2)) {
            return (_c = _this.resolve(param2.transform, context)).transform.apply(_c, __spread([_this.resolve(param2.token, context)], param2.transformArgs));
          }
          return _this.resolve(param2, context);
        } catch (e) {
          throw new Error(formatErrorCtor(ctor, idx, e));
        }
      };
    };
    InternalDependencyContainer2.prototype.ensureNotDisposed = function() {
      if (this.disposed) {
        throw new Error("This container has been disposed, you cannot interact with a disposed container");
      }
    };
    return InternalDependencyContainer2;
  }();
  var instance = new InternalDependencyContainer();

  // ../../../node_modules/tsyringe/dist/esm5/decorators/inject.js
  function inject(token) {
    return defineInjectionTokenMetadata(token);
  }
  var inject_default = inject;

  // ../../../node_modules/tsyringe/dist/esm5/decorators/injectable.js
  function injectable() {
    return function(target) {
      typeInfo.set(target, getParamInfo(target));
    };
  }
  var injectable_default = injectable;

  // ../../../node_modules/tsyringe/dist/esm5/decorators/registry.js
  function registry(registrations) {
    if (registrations === void 0) {
      registrations = [];
    }
    return function(target) {
      registrations.forEach(function(_a) {
        var token = _a.token, options = _a.options, provider = __rest(_a, ["token", "options"]);
        return instance.register(token, provider, options);
      });
      return target;
    };
  }
  var registry_default2 = registry;

  // ../../../node_modules/tsyringe/dist/esm5/decorators/singleton.js
  function singleton() {
    return function(target) {
      injectable_default()(target);
      instance.registerSingleton(target);
    };
  }
  var singleton_default = singleton;

  // ../../../node_modules/tsyringe/dist/esm5/factories/instance-caching-factory.js
  function instanceCachingFactory(factoryFunc) {
    var instance2;
    return function(dependencyContainer) {
      if (instance2 == void 0) {
        instance2 = factoryFunc(dependencyContainer);
      }
      return instance2;
    };
  }

  // ../../../node_modules/tsyringe/dist/esm5/index.js
  if (typeof Reflect === "undefined" || !Reflect.getMetadata) {
    throw new Error(`tsyringe requires a reflect polyfill. Please add 'import "reflect-metadata"' to the top of your entry point.`);
  }

  // ../src/lib/predefine.ts
  window.pnInitPerformance = performance.now();
  if (!window.pnHasPolyfilled) {
    window.pnHasPolyfilled = false;
  }
  if (!window.pnFullTPVersion) {
    window.pnFullTPVersion = false;
  }
  if (typeof window.pn !== "undefined" && typeof window.pn.container !== "undefined") {
    throw new Error("Piano SDK is loaded twice on same page. Try to fix that to prevent the message.");
  } else {
    if (!window.pnFullTPVersion && typeof Proxy !== "undefined") {
      const commonMockedFunction = function() {
        return commonProxy;
      };
      const commonProxy = new Proxy({}, {
        get: function(target, p, receiver) {
          if (p === "isv") {
            return true;
          }
          return commonMockedFunction;
        },
        apply: function(target, thisArg, argArray) {
          return commonProxy;
        }
      });
      instance.resolve = new Proxy(instance.resolve, {
        apply: function(target, thisArg, argArray) {
          if (instance.isRegistered(argArray[0])) {
            return Reflect.apply(target, thisArg, argArray);
          } else {
            instance.register(argArray[0], {
              useValue: commonProxy
            });
            const module = instance.resolve(argArray[0]);
            pn2[argArray[0]] = module;
            return module;
          }
        }
      });
    }
    const predefinedOptions = window.pn || {};
    const pn2 = window.pn = {};
    pn2.container = instance;
    pn2.singleton = singleton_default;
    pn2.injectable = injectable_default;
    pn2.inject = inject_default;
    pn2.registry = registry_default2;
    pn2.instanceCachingFactory = instanceCachingFactory;
    pn2.predefinedOptions = predefinedOptions;
    instance.register("predefinedOptions", {
      useValue: predefinedOptions
    });
  }

  // ../src/lib/checkTinypass.ts
  var needToLoadFullVersion = false;
  try {
    if (!window.pnHasPolyfilled) {
      if (typeof Proxy === "undefined") {
        throw new Error("The browser cannot Proxy");
      }
      new Promise((res) => {
      });
      Object.assign({}, {});
      [""].includes("");
      if (!Element.prototype.closest) {
        throw new Error("There is no closest method of a DOM element");
      }
    }
  } catch (e) {
    needToLoadFullVersion = true;
  }
  function getSDKDomainName() {
    var _a;
    const scripts = document.querySelectorAll("script");
    if (scripts.length) {
      for (let script of scripts) {
        const sdkDomainName = (_a = script == null ? void 0 : script.src) == null ? void 0 : _a.match(/^.*?(tinypass.com|piano.io)/i);
        if (sdkDomainName) {
          return sdkDomainName[0];
        }
      }
    }
    return "https://sandbox.tinypass.com";
  }
  if (needToLoadFullVersion) {
    const domainName = getSDKDomainName();
    delete window.pn;
    const a = document.createElement("script");
    a.type = "text/javascript";
    a.async = true;
    a.src = `${domainName}/api/piano.es5.js`;
    document.getElementsByTagName("head")[0].appendChild(a);
    throw new Error("Load full version of piano SDK");
  }

  // ../src/styles/offer.css
  var offer_default = `.tp-backdrop {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #121214;
    z-index: 300000;
    opacity: 0;
    transition: opacity .25s linear;
}

.tp-backdrop.tp-active {
    opacity: .9;
}

.tp-modal .tp-close.tp-square {
    background: #ccc;
    border-radius: 0;
    border: 0;
    top: 0;
    right: -40px;
}

.tp-modal .tp-close {
    display: none;
    position: absolute;
    top: -15px;
    right: -15px;
    width: 30px;
    height: 30px;
    background: #fff url("data:image/svg+xml,%3Csvg width='20' height='20' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M13.51 7.208l-.706-.708-2.798 2.798L7.207 6.5l-.707.707 2.798 2.799L6.503 12.8l.707.707 2.796-2.795 2.792 2.792.707-.707-2.792-2.792 2.798-2.798z' fill='%23000' fill-opacity='.4'/%3E%3C/svg%3E") center center no-repeat;
    border: none;
    box-shadow: 0 0 10px 0 rgba(28, 37, 68, 0.15);
    outline: none;
    z-index: 300100;
    border-radius: 40px;
    opacity: 0;
    cursor: pointer;
    transform: scale(.25, .25);
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
}

.tp-modal .tp-close:hover,
.tp-modal .tp-close:focus {
    box-shadow: 0 0 10px 2px rgba(28, 37, 68, 0.15);
}

.tp-modal .tp-close:focus {
    border: 1px solid;
}

.tp-modal .tp-close.tp-active {
    display: block;
    opacity: 1;
    transform: scale(1, 1);
}

.tp-modal .tp-iframe-wrapper[dir="rtl"] .tp-close {
    right: initial;
    left: -20px;
}

.tp-modal .tp-iframe-wrapper.piano-id-modal-ver-2 .tp-close {
    top: 0;
    right: 0;
    width: 64px;
    height: 64px;
    box-shadow: none;
    outline: none;
    border-radius: 0;
    border-left: 1px solid rgba(15, 15, 21, 0.2);
    background: url("data:image/svg+xml,%3Csvg width='16' height='16' viewBox='0 0 16 16' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cg %3E%3Cpath d='M3 3L13 13M13 3L3 13' stroke='%230F0F15' stroke-width='2'/%3E%3C/g%3E%3C/svg%3E%0A") center center no-repeat;
    opacity: 0.3;
}

.tp-modal .tp-iframe-wrapper.piano-id-modal-ver-2 .tp-close.tp-active {
    opacity: 0.3;
}

.tp-modal .tp-iframe-wrapper.piano-id-modal-ver-2 .tp-close:hover,
.tp-modal .tp-iframe-wrapper.piano-id-modal-ver-2 .tp-close:focus {
    box-shadow: none;
    border: none;
    border-left: 1px solid rgba(15, 15, 21, 0.06);
    opacity: 1;
}

.tp-modal .tp-iframe-wrapper.piano-id-modal-ver-2[dir="rtl"] .tp-close {
    right: auto;
    left: 0;
    border-left: none;
    border-right: 1px solid rgba(15, 15, 21, 0.2);
}

.tp-modal .tp-iframe-wrapper.piano-id-modal-ver-2[dir="rtl"] .tp-close:hover,
.tp-modal .tp-iframe-wrapper.piano-id-modal-ver-2[dir="rtl"] .tp-close:focus {
    border-left: none;
    border-right: 1px solid rgba(15, 15, 21, 0.06);
}

.tp-modal {
    z-index: 300050;
}

@media screen and (max-width: 650px) {
    .tp-modal .tp-close {
        right: 0;
    }

    .tp-modal .tp-iframe-wrapper[dir="rtl"] .tp-close {
        right: initial;
        left: 0;
    }
}

.tp-modal .tp-iframe-wrapper.tp-curtain {
    width: 600px;
    height: 480px;
}

.tp-modal-open {
    overflow: hidden !important;
    height: 100vh;
    -webkit-overflow-scrolling: touch;
}

.tp-modal-open.tp-modal-resizing {
    -webkit-overflow-scrolling: auto;
}

/*Bug fix of firefox v57*/
.tp-modal-close {
    overflow: auto;
}

.tp-iframe-wrapper {
    position: relative;
    margin: 50px auto;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.21);
}

.tp-iframe-wrapper.no-shadow {
    box-shadow: unset;
}

.tp-modal {
    overflow-x: hidden;
    overflow-y: scroll !important;
    display: none;
    position: fixed;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    transform: translate3d(0, 0, 0);
}

.tp-modal .tp-message {
    font-family: "Graphik Web Regular", Helvetica, Arial, sans-serif;
    padding: 10px;
}

.tp-modal .tp-btn-container {
    padding-left: 10px;
    padding-bottom: 10px;
}

.tp-cxense-placeholder-modal {
    width: 100%;
    background-color: #fff;
    max-width: 912px;
    display: block;
    overflow: hidden;
    height: auto;
    opacity: 1;
}

.tp-widget-placeholder > div::after {
    display: block;
    content: "";
    clear: both;
}

.tp-btn {
    text-decoration: none;
    cursor: pointer;
    padding: 0 18px;
    line-height: 40px;
    border-collapse: separate;
    border-radius: 4px;
    text-align: center;
    vertical-align: middle;
    display: inline-block;
    color: #fff;
    border: none;
    box-shadow: inset 0 -1px 0 rgba(216, 218, 221, 0.0);
    background: #3878D8;
    background-position: bottom;
    text-shadow: none;
    font-family: "Graphik Web Regular", Helvetica, Arial, sans-serif;
    white-space: nowrap;
    outline: 0;
}

.tp-please-wait.tp-active {
    display: block;
    opacity: .9;
    transition: opacity .25s linear;
}

.tp-please-wait {
    position: absolute;
    top: 0;
    left: 0;
    background-color: #999;
    opacity: 0;
    width: 100%;
    height: 100%;
    display: none;
    text-align: center;
    color: #fff;
    font-weight: lighter;
    font-family: "Open Sans", sans-serif;
    font-size: 15px;
}

.tp-please-wait.tp-overlap {
    position: fixed;
    z-index: 300150;
}

.tp-please-wait.tp-local-overlap {
    position: absolute;
}

.tp-please-wait > .tp-icon {
    width: 80px;
    height: 80px;
    margin: 100px auto 20px auto;
}

.pn-spinner {
    color: grey;
    display: inline-block;
    position: relative;
    width: 80px;
    height: 80px;
}

.pn-spinner div {
    transform-origin: 40px 40px;
    animation: pn-spinner 1.2s linear infinite;
}

.pn-spinner div:after {
    content: " ";
    display: block;
    position: absolute;
    top: 3px;
    left: 37px;
    width: 6px;
    height: 18px;
    border-radius: 20%;
    background: #fff;
}

.pn-spinner div:nth-child(1) {
    transform: rotate(0deg);
    animation-delay: -1.1s;
}

.pn-spinner div:nth-child(2) {
    transform: rotate(30deg);
    animation-delay: -1s;
}

.pn-spinner div:nth-child(3) {
    transform: rotate(60deg);
    animation-delay: -0.9s;
}

.pn-spinner div:nth-child(4) {
    transform: rotate(90deg);
    animation-delay: -0.8s;
}

.pn-spinner div:nth-child(5) {
    transform: rotate(120deg);
    animation-delay: -0.7s;
}

.pn-spinner div:nth-child(6) {
    transform: rotate(150deg);
    animation-delay: -0.6s;
}

.pn-spinner div:nth-child(7) {
    transform: rotate(180deg);
    animation-delay: -0.5s;
}

.pn-spinner div:nth-child(8) {
    transform: rotate(210deg);
    animation-delay: -0.4s;
}

.pn-spinner div:nth-child(9) {
    transform: rotate(240deg);
    animation-delay: -0.3s;
}

.pn-spinner div:nth-child(10) {
    transform: rotate(270deg);
    animation-delay: -0.2s;
}

.pn-spinner div:nth-child(11) {
    transform: rotate(300deg);
    animation-delay: -0.1s;
}

.pn-spinner div:nth-child(12) {
    transform: rotate(330deg);
    animation-delay: 0s;
}

@keyframes pn-spinner {
    0% {
        opacity: 1;
    }
    100% {
        opacity: 0;
    }
}

.tp-please-wait > .tp-icon.tp-centered {
    margin: 0;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}

.tp-iframe-wrapper.no-width .tp-close,
.tp-iframe-wrapper.no-height .tp-close,
.tp-modal.no-width .tp-close,
.tp-modal.no-height .tp-close {
    display: none;
}

.tp-banner {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
}

.tp-banner > .tp-container-inner,
.tp-banner > .tp-container-inner > iframe {
    width: inherit !important;
}

.tp-modal-overscroll-prevented {
    overscroll-behavior: contain;
    width: 100%;
    overflow-x: unset;
    overflow-y: scroll;
}

.tp-scroll-prevented {
    height: 100vh;
    overflow: hidden;
    /*position: fixed;*/
    touch-action: none;
}

.tp-body-scroll-prevented {
    touch-action: none;
}`;

  // ../src/lib/css.ts
  var css = (() => {
    const name3 = "css";
    const loadOfferCss = () => {
      requireCssFile(offer_default);
    };
    const requireCssFile = (cssText) => {
      return new Promise((resolve, reject) => {
        const style = document.createElement("style");
        style.type = "text/css";
        style.innerHTML = cssText;
        style.onload = resolve;
        style.onerror = reject;
        document.getElementsByTagName("head")[0].appendChild(style);
      });
    };
    return {
      name: name3,
      loadOfferCss
    };
  })();
  pn.container.register("css", {
    useValue: css
  });
  pn.css = pn.container.resolve("css");

  // ../src/lib/ajax-jq.js
  var type = (obj) => {
    return {}.toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
  };
  var jsonpID = Math.round(1e4 * Math.random());
  var document2 = window.document;
  var key;
  var name;
  var scriptTypeRE = /^(?:text|application)\/javascript/i;
  var xmlTypeRE = /^(?:text|application)\/xml/i;
  var jsonType = "application/json";
  var htmlType = "text/html";
  var blankRE = /^\s*$/;
  var ajax = function(options) {
    var settings = extend({}, options || {});
    for (key in ajax.settings)
      if (settings[key] === void 0)
        settings[key] = ajax.settings[key];
    ajaxStart(settings);
    if (!settings.crossDomain)
      settings.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(settings.url) && RegExp.$2 != window.location.host;
    var dataType = settings.dataType, hasPlaceholder = /=\?/.test(settings.url);
    if (dataType == "jsonp" || hasPlaceholder) {
      if (!hasPlaceholder)
        settings.url = appendQuery(settings.url, "callback=?");
      return ajax.JSONP(settings);
    }
    if (!settings.url)
      settings.url = window.location.toString();
    serializeData(settings);
    var mime = settings.accepts[dataType], baseHeaders = {}, protocol = /^([\w-]+:)\/\//.test(settings.url) ? RegExp.$1 : window.location.protocol, xhr = ajax.settings.xhr(), abortTimeout;
    if (!settings.crossDomain)
      baseHeaders["X-Requested-With"] = "XMLHttpRequest";
    if (mime) {
      baseHeaders["Accept"] = mime;
      if (mime.indexOf(",") > -1)
        mime = mime.split(",", 2)[0];
      xhr.overrideMimeType && xhr.overrideMimeType(mime);
    }
    if (settings.contentType || settings.data && settings.type.toUpperCase() != "GET")
      baseHeaders["Content-Type"] = settings.contentType || "application/x-www-form-urlencoded";
    settings.headers = extend(baseHeaders, settings.headers || {});
    var withCredentials = settings.xhrFields && settings.xhrFields.withCredentials;
    if (withCredentials) {
      xhr.withCredentials = withCredentials;
    }
    xhr.onreadystatechange = function() {
      if (xhr.readyState == 4) {
        clearTimeout(abortTimeout);
        var result, error = false;
        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 || xhr.status == 0 && protocol == "file:") {
          dataType = dataType || mimeToDataType(xhr.getResponseHeader("content-type"));
          result = xhr.responseText;
          try {
            if (dataType == "script")
              (1, eval)(result);
            else if (dataType == "xml")
              result = xhr.responseXML;
            else if (dataType == "json")
              result = blankRE.test(result) ? null : JSON.parse(result);
          } catch (e) {
            error = e;
          }
          if (error)
            ajaxError(error, "parsererror", xhr, settings);
          else
            ajaxSuccess(result, xhr, settings);
        } else {
          ajaxError(null, "error", xhr, settings);
        }
      }
    };
    var async = "async" in settings ? settings.async : true;
    xhr.open(settings.type, settings.url, async);
    for (name in settings.headers)
      xhr.setRequestHeader(name, settings.headers[name]);
    if (ajaxBeforeSend(xhr, settings) === false) {
      xhr.abort();
      return false;
    }
    if (settings.timeout > 0)
      abortTimeout = setTimeout(function() {
        xhr.onreadystatechange = empty;
        xhr.abort();
        ajaxError(null, "timeout", xhr, settings);
      }, settings.timeout);
    xhr.send(settings.data ? settings.data : null);
    return xhr;
  };
  function triggerAndReturn(context, eventName, data) {
    return true;
  }
  function triggerGlobal(settings, context, eventName, data) {
    if (settings.global)
      return triggerAndReturn(context || document2, eventName, data);
  }
  ajax.active = 0;
  function ajaxStart(settings) {
    if (settings.global && ajax.active++ === 0)
      triggerGlobal(settings, null, "ajaxStart");
  }
  function ajaxStop(settings) {
    if (settings.global && !--ajax.active)
      triggerGlobal(settings, null, "ajaxStop");
  }
  function ajaxBeforeSend(xhr, settings) {
    var context = settings.context;
    if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, "ajaxBeforeSend", [xhr, settings]) === false)
      return false;
    triggerGlobal(settings, context, "ajaxSend", [xhr, settings]);
  }
  function ajaxSuccess(data, xhr, settings) {
    var context = settings.context, status = "success";
    settings.success.call(context, data, status, xhr);
    triggerGlobal(settings, context, "ajaxSuccess", [xhr, settings, data]);
    ajaxComplete(status, xhr, settings);
  }
  function ajaxError(error, type2, xhr, settings) {
    var context = settings.context;
    settings.error.call(context, xhr, type2, error);
    triggerGlobal(settings, context, "ajaxError", [xhr, settings, error]);
    ajaxComplete(type2, xhr, settings);
  }
  function ajaxComplete(status, xhr, settings) {
    var context = settings.context;
    settings.complete.call(context, xhr, status);
    triggerGlobal(settings, context, "ajaxComplete", [xhr, settings]);
    ajaxStop(settings);
  }
  function empty() {
  }
  ajax.JSONP = function(options) {
    if (!("type" in options))
      return ajax(options);
    var callbackName = "jsonp" + (options.cache ? "Callback" : ++jsonpID), script = document2.createElement("script"), abort = function() {
      if (callbackName in window)
        window[callbackName] = empty;
      ajaxComplete("abort", xhr, options);
    }, xhr = { abort }, abortTimeout, head = document2.getElementsByTagName("head")[0] || document2.documentElement;
    if (options.error)
      script.onerror = function() {
        xhr.abort();
        options.error();
      };
    window[callbackName] = function(data) {
      clearTimeout(abortTimeout);
      delete window[callbackName];
      ajaxSuccess(data, xhr, options);
    };
    serializeData(options);
    script.src = options.url.replace(/=\?/, "=" + callbackName);
    head.insertBefore(script, head.firstChild);
    if (options.timeout > 0)
      abortTimeout = setTimeout(function() {
        xhr.abort();
        ajaxComplete("timeout", xhr, options);
      }, options.timeout);
    return xhr;
  };
  ajax.settings = {
    type: "GET",
    beforeSend: empty,
    success: empty,
    error: empty,
    complete: empty,
    context: null,
    global: true,
    xhr: function() {
      return new window.XMLHttpRequest();
    },
    accepts: {
      script: "text/javascript, application/javascript",
      json: jsonType,
      xml: "application/xml, text/xml",
      html: htmlType,
      text: "text/plain"
    },
    crossDomain: false,
    timeout: 0
  };
  function mimeToDataType(mime) {
    return mime && (mime == htmlType ? "html" : mime == jsonType ? "json" : scriptTypeRE.test(mime) ? "script" : xmlTypeRE.test(mime) && "xml") || "text";
  }
  function appendQuery(url, query2) {
    return (url + "&" + query2).replace(/[&?]{1,2}/, "?");
  }
  function serializeData(options) {
    if (type(options.data) === "object")
      options.data = param(options.data);
    if (options.data && (!options.type || options.type.toUpperCase() == "GET"))
      options.url = appendQuery(options.url, options.data);
  }
  ajax.get = function(url, success) {
    return ajax({ url, success });
  };
  ajax.post = function(url, data, success, dataType) {
    if (type(data) === "function")
      dataType = dataType || success, success = data, data = null;
    return ajax({ type: "POST", url, data, success, dataType });
  };
  ajax.getJSON = function(url, success) {
    return ajax({ url, success, dataType: "json" });
  };
  var escape = encodeURIComponent;
  function serialize(params, obj, traditional, scope) {
    var array = type(obj) === "array";
    for (var key2 in obj) {
      var value = obj[key2];
      if (scope)
        key2 = traditional ? scope : scope + "[" + (array ? "" : key2) + "]";
      if (!scope && array)
        params.add(value.name, value.value);
      else if (traditional ? type(value) === "array" : type(value) === "object")
        serialize(params, value, traditional, key2);
      else
        params.add(key2, value);
    }
  }
  function param(obj, traditional) {
    var params = [];
    params.add = function(k, v) {
      if (v === void 0) {
        return;
      }
      v = v == null ? "" : v;
      this.push(escape(k) + "=" + escape(v));
    };
    serialize(params, obj, traditional);
    return params.join("&").replace("%20", "+");
  }
  function extend(target) {
    var slice = Array.prototype.slice;
    slice.call(arguments, 1).forEach(function(source) {
      for (key in source)
        if (source[key] !== void 0)
          target[key] = source[key];
    });
    return target;
  }
  var ajaxJq = ajax;

  // ../src/lib/ajax.ts
  var ajax2 = (() => {
    const send = (url, callback, method, data, contentType, async = true) => {
      if (async === void 0) {
        async = true;
      }
      const x = new XMLHttpRequest();
      x.open(method, url, async);
      x.onreadystatechange = function() {
        if (x.readyState === 4 && callback) {
          callback(x.responseText);
        }
      };
      x.setRequestHeader("Content-type", contentType);
      x.send(data);
    };
    const request = (options) => {
      options.dataType = options.dataType || "json";
      return ajaxJq(options);
    };
    return {
      send,
      request
    };
  })();
  pn.container.register("ajax", {
    useValue: ajax2
  });
  pn.ajax = pn.container.resolve("ajax");

  // ../src/lib/jqUtils.ts
  var jqUtils = () => {
    const scrollTop = () => {
      return window.pageYOffset || document.documentElement.scrollTop;
    };
    const winSize = () => {
      const w = window, d = document, e = d.documentElement, g = d.getElementsByTagName("body")[0], x = w.innerWidth || e.clientWidth || g.clientWidth, y = w.innerHeight || e.clientHeight || g.clientHeight;
      return {
        height: y,
        width: x
      };
    };
    const isPlainObject = (obj) => {
      return Object.prototype.toString.call(obj) === "[object Object]";
    };
    const isEmptyObject = (obj) => {
      return Object.keys(obj).length === 0 && obj.constructor === Object;
    };
    const isFunction = (func) => {
      return typeof func === "function";
    };
    const inArray = (item, array) => {
      return array.indexOf(item);
    };
    const type2 = (obj) => {
      return Object.prototype.toString.call(obj).replace(/^\[object (.+)\]$/, "$1").toLowerCase();
    };
    const remove = (el) => {
      var _a;
      (_a = el.parentNode) == null ? void 0 : _a.removeChild(el);
    };
    const empty2 = (el) => {
      while (el.firstChild)
        el.removeChild(el.firstChild);
    };
    const queryEl = (query2, container) => {
      if (!query2) {
        return null;
      }
      return qa(query2, container)[0];
    };
    const qa = (query2, container) => {
      if (!query2) {
        return [];
      }
      const parentContainer = container ? container : document;
      const splitQuery = query2.split(",");
      let resElements = [];
      splitQuery.forEach((splQEl) => {
        const trimmedSplQEl = splQEl.trim();
        try {
          resElements = resElements.concat(Array.prototype.slice.call(parentContainer.querySelectorAll(trimmedSplQEl)));
        } catch (e) {
          const isComplexSelector = trimmedSplQEl.indexOf(" ") > -1;
          if (trimmedSplQEl[0] === "." && !isComplexSelector) {
            resElements = resElements.concat(Array.prototype.slice.call(parentContainer.getElementsByClassName(trimmedSplQEl.substring(1))));
          } else if (trimmedSplQEl[0] === "#" && !isComplexSelector) {
            const fEl = document.getElementById(trimmedSplQEl.substring(1));
            resElements = resElements.concat(fEl ? [fEl] : []);
          } else {
            resElements = resElements.concat(Array.prototype.slice.call(parentContainer.querySelectorAll(trimmedSplQEl)));
          }
        }
      });
      return resElements;
    };
    const filter = (query2, filterFn) => {
      return Array.prototype.filter.call(document.querySelectorAll(query2), filterFn);
    };
    const addClass = (className, el) => {
      el.classList.add(className);
    };
    const toggleClass = (className, el) => {
      el.classList.toggle(className);
    };
    const removeClass = (className, el) => {
      el.classList.remove(className);
    };
    const getWidth = (el) => {
      const { paddingLeft, paddingRight } = getComputedStyle(el, null);
      let { width } = el.getBoundingClientRect();
      width -= parseFloat(paddingLeft) + parseFloat(paddingRight);
      return width;
    };
    const show = (el) => {
      el.style.display = "block";
    };
    const hide = (el) => {
      el.style.display = "none";
    };
    const getHeight = (el) => {
      const { paddingTop, paddingBottom } = getComputedStyle(el, null);
      let { height } = el.getBoundingClientRect();
      height -= parseFloat(paddingTop) + parseFloat(paddingBottom);
      return height;
    };
    const visible = (el) => {
      return !!(el.offsetWidth || el.offsetHeight || el.getClientRects().length);
    };
    const append2 = (parent2, el) => {
      parent2.appendChild(el);
    };
    const setAttr = (attr, val, el) => {
      el.setAttribute(attr, val);
    };
    const setAttrs = (attrs, el) => {
      Object.keys(attrs).forEach((key2) => {
        setAttr(key2, attrs[key2], el);
      });
    };
    const getAttr = (el, attr) => {
      if (typeof el === "string") {
        el = queryEl(el);
      }
      return el ? el.getAttribute(attr) : null;
    };
    const ready = (fn) => {
      if (document.readyState != "loading") {
        fn();
      } else {
        document.addEventListener("DOMContentLoaded", () => fn());
      }
    };
    let delegateList = [];
    const delegate = (parentEl, elementSelector, eventName, handler) => {
      const _handler = (e) => {
        for (var target = e.target; target && target != void 0; target = target.parentNode) {
          const foundIndex = delegateList.findIndex((item) => {
            return item.parentEl === parentEl && item.elementSelector === elementSelector;
          });
          if (target.matches && target.matches(elementSelector) && foundIndex >= 0) {
            handler.call(target, e);
            break;
          }
        }
      };
      delegateList.push({
        parentEl,
        elementSelector,
        handler: _handler,
        eventName
      });
      parentEl.addEventListener(eventName, _handler, false);
    };
    const undelegate = (parentEl, elementSelector) => {
      delegateList = delegateList.filter((item) => {
        const notMatch = item.parentEl !== parentEl && item.elementSelector !== elementSelector;
        if (!notMatch) {
          item.parentEl.removeEventListener(item.eventName, item.handler);
        }
        return notMatch;
      });
    };
    const on = (element, eventName, callback) => {
      element.addEventListener(eventName, (e) => {
        callback(e);
      }, false);
    };
    const off = (element, eventName, callback) => {
      element.removeEventListener(eventName, callback);
    };
    const deepExtend = (...args) => {
      const extended = {};
      let i = 0;
      const merge = (obj) => {
        for (const prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            if (Object.prototype.toString.call(obj[prop]) === "[object Object]") {
              extended[prop] = deepExtend(extended[prop], obj[prop]);
            } else {
              extended[prop] = obj[prop];
            }
          }
        }
      };
      for (; i < args.length; i++) {
        merge(args[i]);
      }
      return extended;
    };
    const param2 = (obj, excludedParams) => {
      const paramsArr = [];
      const buildParam = (field, value) => {
        return encodeURIComponent(field) + "=" + encodeURIComponent(isFunction(value) ? value() : value || value === 0 || value === false ? value : "");
      };
      Object.keys(obj).forEach((k) => {
        if (excludedParams && excludedParams[k]) {
          return;
        }
        if (Array.isArray(obj[k])) {
          obj[k].forEach((fieldVal) => {
            paramsArr.push(buildParam(k, fieldVal));
          });
        } else {
          paramsArr.push(buildParam(k, obj[k]));
        }
      });
      return paramsArr.join("&");
    };
    return {
      scrollTop,
      winSize,
      isPlainObject,
      isEmptyObject,
      isFunction,
      inArray,
      type: type2,
      remove,
      empty: empty2,
      queryEl,
      qa,
      filter,
      addClass,
      toggleClass,
      removeClass,
      getWidth,
      show,
      hide,
      getHeight,
      visible,
      append: append2,
      setAttr,
      setAttrs,
      getAttr,
      ready,
      delegate,
      undelegate,
      on,
      off,
      deepExtend,
      param: param2
    };
  };
  pn.container.register("jqUtils", {
    useValue: jqUtils()
  });
  pn.jqUtils = pn.container.resolve("jqUtils");

  // ../../../node_modules/@piano-sdk/storage/dist/index.js
  var dist_exports = {};
  __export(dist_exports, {
    cookie: () => cookie,
    localStorage: () => localStorage2,
    sessionStorage: () => sessionStorage
  });
  var randomStr = function randomStr2() {
    var date = new Date().getTime().toString(36);
    var prefix = Math.round(Math.random() * 2147483647).toString(36);
    return date + prefix;
  };
  var byteCount = function byteCount2(str) {
    return encodeURI(str).split(/%(?:u[\dA-F]{2})?[\dA-F]{2}|./).length - 1;
  };
  var expiresToDate = function expiresToDate2(expires) {
    var date = new Date();
    var increaseDays = function increaseDays2(days2) {
      if (days2) {
        date.setDate(date.getDate() + days2);
      }
    };
    if (expires instanceof Date) {
      date = expires;
    } else if (typeof expires === "number") {
      increaseDays(expires);
    } else {
      var _a = expires, days = _a.days, minutes = _a.minutes;
      increaseDays(days);
      if (minutes) {
        date.setMinutes(date.getMinutes() + minutes);
      }
    }
    return date;
  };
  var decode = function decode2(s) {
    var res = s.replace(/\+/g, " ").replace(/^\s+|\s+$/g, "");
    try {
      return decodeURIComponent(res);
    } catch (e) {
      return res;
    }
  };
  var decodeValue = function decodeValue2(s) {
    if (s.indexOf('"') === 0) {
      s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, "\\");
    }
    return decode(s);
  };
  var cookie = function() {
    var _generateCookieString = function _generateCookieString2(name3, value, _a) {
      var _b = _a === void 0 ? {} : _a, path = _b.path, domain = _b.domain, expires = _b.expires, secure = _b.secure, samesite = _b.samesite, raw = _b.raw, priority = _b.priority;
      return (raw ? name3 : encodeURIComponent(name3)) + "=" + (raw ? value : encodeURIComponent(value)) + (expires ? "; expires=".concat(expiresToDate(expires).toUTCString()) : "") + (path ? "; path=".concat(path) : "") + (domain ? "; domain=".concat(domain) : "") + (secure ? "; secure" : "") + (samesite ? typeof samesite === "boolean" ? "; sameSite" : "; sameSite=".concat(samesite) : "") + (priority ? "; priority=".concat(priority) : "");
    };
    var setCookie = function setCookie2(name3, value, cookieOptions, limitValue) {
      if (value === void 0 || limitValue !== void 0 && byteCount(value) > limitValue) {
        return;
      }
      document.cookie = _generateCookieString(name3, value, cookieOptions);
    };
    var parseCookie = function parseCookie2(cb) {
      var allCookies = document.cookie.split(";");
      for (var i = 0; i < allCookies.length; i++) {
        var _cookie = allCookies[i].split("=");
        var cookieName = decode(_cookie[0]);
        var cookieValue = _cookie[1] || "";
        if (cb(cookieName, cookieValue)) {
          return void 0;
        }
      }
    };
    function getCookie(name3) {
      var result = null;
      var cookies = {};
      parseCookie(function(cookieName, cookieValue) {
        if (name3) {
          if (cookieName === name3) {
            result = decodeValue(cookieValue);
            return true;
          }
        } else {
          cookies[cookieName] = decodeValue(cookieValue);
        }
      });
      if (name3) {
        return result;
      }
      return cookies;
    }
    var getNames = function getNames2() {
      var result = [];
      parseCookie(function(cookieName) {
        result.push(cookieName);
      });
      return result;
    };
    var removeCookie = function removeCookie2(name3, cookieOptions) {
      setCookie(name3, "", Object.assign({}, cookieOptions, {
        expires: -1
      }));
    };
    var getTopLevelDomain = function() {
      var testName = "_cookie_test";
      var secure = document.location.protocol === "https:";
      return function(domainExceptions2) {
        if (domainExceptions2 === void 0) {
          domainExceptions2 = [];
        }
        var domainParts = window.location.hostname.split(".");
        var testValue = randomStr();
        var expires = new Date();
        expires.setSeconds(expires.getSeconds() + 30);
        for (var i = 0; i < domainParts.length; i++) {
          try {
            var candidate = domainParts.slice(-(i + 1)).join(".");
            if (!domainExceptions2.includes(candidate)) {
              setCookie(testName, testValue, {
                expires,
                path: "/",
                domain: candidate,
                secure
              });
              var allowed = getCookie(testName) === testValue;
              removeCookie(testName, {
                path: "/",
                domain: candidate
              });
              if (allowed) {
                return candidate;
              }
            }
          } catch (e) {
          }
        }
      };
    }();
    return {
      set: setCookie,
      get: getCookie,
      getNames,
      remove: removeCookie,
      getTopLevelDomain,
      __private__: {
        _generateCookieString
      }
    };
  }();
  var localStorage2 = function() {
    var TTL_NAME_ITEMS = "_ls_ttl";
    var _checkTTl = function _checkTTl2(ttl) {
      return ttl ? ttl > Date.now() : true;
    };
    var _parseTTLValues = function _parseTTLValues2() {
      try {
        var value = window.localStorage.getItem(TTL_NAME_ITEMS);
        if (value) {
          var obj = JSON.parse(value);
          return obj;
        }
        return null;
      } catch (e) {
        return null;
      }
    };
    var _setTTLValues = function _setTTLValues2(ttlValues) {
      try {
        if (Object.keys(ttlValues).length) {
          window.localStorage.setItem(TTL_NAME_ITEMS, JSON.stringify(ttlValues));
        } else {
          window.localStorage.removeItem(TTL_NAME_ITEMS);
        }
      } catch (e) {
      }
    };
    var _saveTTLValues = function _saveTTLValues2(name3, expires) {
      var ttlValues = _parseTTLValues();
      if (expires === void 0) {
        if (ttlValues === null || ttlValues === void 0 ? void 0 : ttlValues[name3]) {
          delete ttlValues[name3];
          _setTTLValues(ttlValues);
        }
        return true;
      }
      var expiresTime = expiresToDate(expires).getTime();
      if (expiresTime > Date.now()) {
        ttlValues = ttlValues || {};
        ttlValues[name3] = expiresTime.toString(36);
        _setTTLValues(ttlValues);
        return true;
      }
      return false;
    };
    var _checkTTLValues = function _checkTTLValues2() {
      var names = _getNames();
      var ttls = _parseTTLValues();
      var ttlsUpdated = {};
      if (!ttls) {
        return;
      }
      Object.keys(ttls).forEach(function(key2) {
        if (names.includes(key2)) {
          var expire = ttls[key2] ? parseInt(ttls[key2], 36) : null;
          if (!_checkTTl(expire)) {
            try {
              window.localStorage.removeItem(key2);
            } catch (e) {
            }
          } else {
            ttlsUpdated[key2] = ttls[key2];
          }
        }
      });
      if (JSON.stringify(ttls) !== JSON.stringify(ttlsUpdated)) {
        _setTTLValues(ttlsUpdated);
      }
    };
    var _get = function _get2(key2) {
      var _a;
      _checkTTLValues();
      try {
        return (_a = window.localStorage.getItem(key2)) !== null && _a !== void 0 ? _a : null;
      } catch (e) {
        return null;
      }
    };
    var _getNames = function _getNames2() {
      try {
        return Object.keys(window.localStorage);
      } catch (e) {
        return [];
      }
    };
    var _set = function _set2(key2, value, options) {
      if (options === void 0) {
        options = {};
      }
      if (_saveTTLValues(key2, options.expires)) {
        try {
          window.localStorage.setItem(key2, value);
        } catch (e) {
        }
      }
    };
    var _remove = function _remove2(key2) {
      try {
        window.localStorage.removeItem(key2);
      } catch (e) {
      }
      _checkTTLValues();
    };
    _checkTTLValues();
    return {
      get: _get,
      set: _set,
      getNames: _getNames,
      remove: _remove,
      expires: _checkTTLValues,
      __protected__: {
        get ttlName() {
          return TTL_NAME_ITEMS;
        }
      }
    };
  }();
  var sessionStorage = function() {
    var _get = function _get2(key2) {
      try {
        return window.sessionStorage.getItem(key2);
      } catch (e) {
        return null;
      }
    };
    var _set = function _set2(key2, value) {
      try {
        window.sessionStorage.setItem(key2, value);
      } catch (e) {
      }
    };
    var _remove = function _remove2(key2) {
      try {
        window.sessionStorage.removeItem(key2);
      } catch (e) {
      }
    };
    var _getNames = function _getNames2() {
      try {
        return Object.keys(window.sessionStorage);
      } catch (e) {
        return [];
      }
    };
    return {
      get: _get,
      set: _set,
      getNames: _getNames,
      remove: _remove
    };
  }();

  // ../../../node_modules/@piano-sdk/data-layer/index.js
  var __assign2 = function() {
    __assign2 = Object.assign || function __assign3(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign2.apply(this, arguments);
  };
  var createBaseParam = function(defaultValue, cookieName) {
    if (cookieName === void 0) {
      cookieName = "_pctx";
    }
    return {
      cookieName,
      readonly: false,
      init: function(valueFromCookie) {
        var _a;
        return (_a = valueFromCookie !== null && valueFromCookie !== void 0 ? valueFromCookie : defaultValue) !== null && _a !== void 0 ? _a : null;
      },
      refresh: function(prevValue) {
        return prevValue;
      },
      update: function(prevValue) {
        return prevValue;
      },
      set: function(newValue) {
        return newValue;
      },
      get: function(value) {
        return value;
      }
    };
  };
  var createStaticParam = function(defaultValue) {
    return __assign2(__assign2({}, createBaseParam(defaultValue)), { cookieName: null });
  };
  var userState = createBaseParam("anon");
  var keys = function(v) {
    return v ? Object.keys(v) : [];
  };
  var isArray = function(v) {
    return Array.isArray(v);
  };
  var isEmpty = function(val) {
    return val === null || val === void 0;
  };
  var isNotEmpty = function(val) {
    return !isEmpty(val);
  };
  var isObject = function(val) {
    return typeof val === "object";
  };
  var isString = function(val) {
    return typeof val === "string";
  };
  var isNumber = function(val) {
    return typeof val === "number";
  };
  var randomStringCxCompatible = function() {
    var randomString = new Date().getTime().toString(36);
    while (randomString.length < 16) {
      randomString += Math.round(Math.random() * 2147483647).toString(36);
    }
    return randomString.substr(0, 16);
  };
  var filterObjectValues = function(obj, filter) {
    if (!obj) {
      return obj;
    }
    return keys(obj).filter(function(k) {
      return filter(obj[k]);
    }).reduce(function(a, k) {
      var _a;
      return __assign2(__assign2({}, a), (_a = {}, _a[k] = obj[k], _a));
    }, {});
  };
  var combineCookieConfig = function(params, cookieWrappers2) {
    return {
      fields: keys(params).reduce(function(res, paramName) {
        var cookieName = params[paramName].cookieName;
        if (cookieName !== null) {
          res[paramName] = cookieName;
        }
        return res;
      }, {}),
      cookieByName: cookieWrappers2
    };
  };
  var stringSet = function() {
    var data = {};
    return {
      add: function(value) {
        data[value] = true;
      },
      values: function() {
        return keys(data);
      }
    };
  };
  var validateObj = function(obj, mapFilter) {
    if (!isObject(obj)) {
      return obj;
    }
    return keys(obj).reduce(function(r, k) {
      var val = obj[k];
      var validate = mapFilter[k];
      var value = validate && validate(val);
      if (value !== void 0) {
        r[k] = value;
      }
      return r;
    }, {});
  };
  var toBoolean = function(val) {
    return val === "true" || val === true;
  };
  var memo = function(fn, checkDeps) {
    var prevDeps = NaN;
    var prevValue = NaN;
    var prevRes;
    return function(a) {
      var curDeps = checkDeps === null || checkDeps === void 0 ? void 0 : checkDeps();
      if (a !== prevValue || prevDeps !== curDeps) {
        prevDeps = curDeps;
        prevValue = a;
        prevRes = fn(a);
      }
      return prevRes;
    };
  };
  var onMemo = function(fn) {
    var prevRes;
    return function(onChange) {
      var res = fn();
      if (res !== prevRes) {
        prevRes = res;
        onChange(res);
      }
    };
  };
  var tryFn = function(resolve, reject) {
    try {
      return resolve();
    } catch (e) {
      return reject ? tryFn(reject) : null;
    }
  };
  var parseJSON = function(data, useBase64) {
    if (useBase64 === void 0) {
      useBase64 = false;
    }
    return tryFn(function() {
      return JSON.parse(data);
    }, function() {
      return useBase64 ? JSON.parse(window.atob(data)) : null;
    }) || null;
  };
  var toJSON = function(data, useBase64) {
    if (useBase64 === void 0) {
      useBase64 = false;
    }
    var str = JSON.stringify(data);
    return tryFn(function() {
      return useBase64 ? window.btoa(str) : str;
    }) || str;
  };
  var shallowEqual = function(obj, obj2) {
    if (obj === obj2) {
      return true;
    }
    if (!obj || !obj2) {
      return null;
    }
    var keys1 = keys(obj);
    var keys2 = keys(obj2);
    if (keys1.length !== keys2.length) {
      return false;
    }
    return !keys1.some(function(key2) {
      var val1 = obj[key2];
      var val2 = obj2[key2];
      return val1 !== val2;
    });
  };
  var removeCxUsers = function(allUsers) {
    return filterObjectValues(allUsers, function(val) {
      return (val === null || val === void 0 ? void 0 : val.type) !== "CX";
    });
  };
  var users = __assign2(__assign2({}, createBaseParam(null)), { init: function(valueFromCookie) {
    return removeCxUsers(valueFromCookie || null);
  }, refresh: removeCxUsers, set: function(value, prev) {
    if (value === null) {
      return null;
    }
    return filterObjectValues(__assign2(__assign2({}, prev), value), function(val) {
      return val !== null;
    });
  } });
  var GLOBAL_CONFIG_NAME = "pdl";
  var getGlobalConfig$1 = function() {
    return window[GLOBAL_CONFIG_NAME] || {};
  };
  var generateInitProtectedValue$1 = function(_prev, changeConfig) {
    changeConfig({
      protect: true
    });
    return getGlobalConfig$1().pageViewId || randomStringCxCompatible();
  };
  var generateAnewProtectedValue = function(_prev, changeConfig) {
    changeConfig({
      protect: true
    });
    return randomStringCxCompatible();
  };
  var pageViewId = __assign2(__assign2({}, createStaticParam()), { init: generateInitProtectedValue$1, refresh: generateAnewProtectedValue, update: generateAnewProtectedValue, set: function(value, _prevValue, changeConfig) {
    changeConfig({
      protect: true
    });
    return value;
  } });
  var RESERVED_PRODUCT = "DL";
  var PRODUCTS_LIST = ["PA", "DMP", "COMPOSER", "ID", "VX", "ESP", "SOCIAL_FLOW", RESERVED_PRODUCT];
  var PRODUCTS = PRODUCTS_LIST.map(function(name3, id) {
    return {
      name: name3,
      id
    };
  });
  var PRODUCTS_MAP = PRODUCTS.reduce(function(res, _a, index) {
    var _b;
    var name3 = _a.name;
    return __assign2(__assign2({}, res), (_b = {}, _b[name3] = index, _b[name3.toLowerCase()] = index, _b));
  }, {});
  PRODUCTS_MAP["social flow"] = PRODUCTS_MAP.SOCIAL_FLOW;
  PRODUCTS_MAP["Social Flow"] = PRODUCTS_MAP.SOCIAL_FLOW;
  var getPdlProductNames = function() {
    var _a;
    return (_a = validateConsentMemo(getGlobalConfig$1().consent)) === null || _a === void 0 ? void 0 : _a.products;
  };
  var onChangePdlProducts = onMemo(getPdlProductNames);
  var getProducts = function() {
    var result = PRODUCTS;
    return function() {
      onChangePdlProducts(function(config) {
        if (config) {
          result = PRODUCTS.filter(function(product) {
            return config.includes(product.name) || product.name === RESERVED_PRODUCT;
          });
        } else {
          result = PRODUCTS;
        }
      });
      return result;
    };
  }();
  var filterByProduct = function(value, prevValue, updateConfig) {
    var newData = getProducts().reduce(function(res, product) {
      var pid = product.id;
      res[pid] = updateConfig(value === null || value === void 0 ? void 0 : value[pid], prevValue === null || prevValue === void 0 ? void 0 : prevValue[pid], pid);
      return res;
    }, {});
    if (shallowEqual(newData, prevValue)) {
      return prevValue;
    }
    return newData;
  };
  var getPid = function(key2) {
    var pid = Number(key2);
    if (Number.isNaN(pid)) {
      var product = PRODUCTS_MAP[key2.toLowerCase()];
      return product !== null && product !== void 0 ? product : null;
    }
    return pid < PRODUCTS.length ? pid : null;
  };
  var fillProductNameReduce = function(dataObj, reduce) {
    return keys(dataObj).reduce(function(res, productId) {
      var productName = PRODUCTS[Number(productId)].name;
      var value = dataObj[productId];
      res[productName] = reduce ? reduce(value, productName) : value;
      return res;
    }, {});
  };
  var OPT_IN_MODE = "opt-in";
  var ESSENTIAL_MODE = "essential";
  var OPT_OUT_MODE = "opt-out";
  var CUSTOM_MODE = "custom";
  var modeListBase = [OPT_IN_MODE, ESSENTIAL_MODE, OPT_OUT_MODE];
  var modesList = modeListBase.concat(CUSTOM_MODE);
  var modeIdMap = modesList.reduce(function(res, mode, index) {
    var _a;
    return __assign2(__assign2({}, res), (_a = {}, _a[index] = mode, _a));
  }, {});
  var priorityList = [OPT_IN_MODE, CUSTOM_MODE, ESSENTIAL_MODE, OPT_OUT_MODE];
  var getStrictMode = function(mode1, mode2) {
    var index1 = priorityList.indexOf(mode1);
    var index2 = priorityList.indexOf(mode2);
    return priorityList[Math.max(index1, index2)];
  };
  var isConsentMode = function(mode) {
    return modesList.includes(mode);
  };
  var isConsentBaseMode = function(mode) {
    return modeListBase.includes(mode);
  };
  var purposeByProduct = {
    AD: ["DMP", "SOCIAL_FLOW"],
    CP: ["COMPOSER"],
    AM: ["PA"],
    PR: ["ESP", "VX", "ID"],
    DL: ["DL"]
  };
  var initialPurposeMap = keys(purposeByProduct).reduce(function(res, purpose) {
    purposeByProduct[purpose].forEach(function(product) {
      var productId = PRODUCTS_MAP[product];
      res[productId] = purpose;
    });
    return res;
  }, {});
  var onChangeConfigPurpose = onMemo(function() {
    var _a;
    return (_a = validateConsentMemo(getGlobalConfig$1().consent)) === null || _a === void 0 ? void 0 : _a.defaultPurposes;
  });
  var getDefaultPurposes = function() {
    var result = __assign2({}, initialPurposeMap);
    return function() {
      onChangeConfigPurpose(function(defaultPurpose) {
        result = __assign2({}, initialPurposeMap);
        if (defaultPurpose) {
          keys(defaultPurpose).forEach(function(productName) {
            var _a;
            var productId = PRODUCTS_MAP[productName];
            result[productId] = (_a = defaultPurpose[productName]) === null || _a === void 0 ? void 0 : _a.substring(0, 32);
          });
        }
      });
      return result;
    };
  }();
  var filterByProductPurposes = function(value, prevValue) {
    return filterByProduct(value, prevValue, function(config, prevConfig, pid) {
      return config || prevConfig || getDefaultPurposes()[pid];
    });
  };
  var convertToPurposes = function(val) {
    return keys(val).reduce(function(res, key2) {
      var pid = getPid(key2);
      var purpose = toPurpose(val[key2]);
      if (pid === null) {
        return res;
      }
      if (purpose === RESERVED_PURPOSE || pid === PRODUCTS_MAP[RESERVED_PRODUCT]) {
        return res;
      }
      if (purpose) {
        res[pid] = purpose;
      }
      return res;
    }, {});
  };
  var purposes = __assign2(__assign2({}, createBaseParam(null, "_pprv")), { init: function(valueFromCookie) {
    return isRequireConsentV2() ? filterByProductPurposes(valueFromCookie || null, null) : null;
  }, set: function(val, prevVal) {
    if (!isRequireConsentV2()) {
      return null;
    }
    if (val === null || val === void 0) {
      return prevVal;
    }
    return filterByProductPurposes(convertToPurposes(val), prevVal);
  } });
  var getGlobalConfigModifiers = function() {
    return getGlobalConfig$1().consent_modifiers || null;
  };
  var getRequireConsent = function() {
    return !!getGlobalConfig$1().requireConsent;
  };
  var isRequireConsentV2 = function() {
    return getGlobalConfig$1().requireConsent === "v2";
  };
  var isInvalidCustomMode = function(mode, product) {
    var _a;
    return mode === CUSTOM_MODE && !((_a = getGlobalConfigModifiers()) === null || _a === void 0 ? void 0 : _a[product]);
  };
  var RESERVED_PURPOSE = "DL";
  var purposesMap = [
    "AD",
    "AM",
    "CP",
    "PR",
    RESERVED_PURPOSE
  ].reduce(function(res, i) {
    var _a;
    return __assign2(__assign2({}, res), (_a = {}, _a[i] = i, _a[i.toLowerCase()] = i, _a));
  }, {});
  var toBasePurpose = function(purpose) {
    return purposesMap[(purpose === null || purpose === void 0 ? void 0 : purpose.toLowerCase()) || ""] || null;
  };
  var toPurpose = function(purpose) {
    return toBasePurpose(purpose) || (purpose === null || purpose === void 0 ? void 0 : purpose.substring(0, 32));
  };
  var productsString = function(products2, single, plural) {
    return "".concat(products2.join(", "), " ").concat(products2.length > 1 ? plural : single);
  };
  var consentV2IsDisabled = "Consent v2 is disabled";
  var errorDlReserved = 'the "DL" purpose is reserved';
  var errorDlProductReserved = function(purpose) {
    return '"'.concat(purpose, '" can not be applied for the dl product');
  };
  var modeIsUnknown = function(mode) {
    return "".concat(mode, " is unknown consent mode");
  };
  var productsDoesntHaveModifier = function(products2) {
    return productsString(products2, "does", "do") + "n't have modifier in the pdl. Custom mode can't be applied";
  };
  var unknownPurpose = "Unknown purpose. Provide a product or define within pdl config";
  var unknownProducts = function(products2) {
    return "Custom purpose: " + productsString(products2, "is", "are") + " unknown";
  };
  function setExtendedConsent(purposes2, consent4, modeOrType, mode, products2) {
    var error = function(msg) {
      return {
        error: msg
      };
    };
    var getConsentsByProducts = function(modeLocal, purposeLocal, productsLocal) {
      var invalidProducts = [];
      if (!isConsentMode(modeLocal)) {
        return error(modeIsUnknown(modeLocal));
      }
      var newConsent = getProducts().reduce(function(res, _a) {
        var id = _a.id, name3 = _a.name;
        if (!purposeLocal || (purposes2 === null || purposes2 === void 0 ? void 0 : purposes2[id]) === purposeLocal || (productsLocal === null || productsLocal === void 0 ? void 0 : productsLocal.includes(id))) {
          if (isInvalidCustomMode(modeLocal, name3)) {
            invalidProducts.push(name3);
          } else {
            res[id] = { mode: modeLocal };
          }
        }
        return res;
      }, {});
      if (invalidProducts.length) {
        return error(productsDoesntHaveModifier(invalidProducts));
      }
      if (!Object.keys(newConsent).length) {
        return null;
      }
      return {
        consent: newConsent
      };
    };
    var setAllModes = function(modeLocal) {
      return getConsentsByProducts(modeLocal);
    };
    var setByPurpose = function(modeLocal, purposeRaw) {
      var purpose = toPurpose(purposeRaw);
      if (!purposesMap[purpose] && !Object.values(purposes2 || {}).includes(purpose)) {
        return error(unknownPurpose);
      }
      return getConsentsByProducts(modeLocal, purpose);
    };
    var setByPurposeAndProduct = function(modelLocal, purposeRaw, productsRaw) {
      var purpose = toPurpose(purposeRaw);
      var productArrayRaw = isArray(productsRaw) ? productsRaw : [productsRaw];
      var pids = productArrayRaw.map(getPid).filter(isNotEmpty);
      if (!pids.length) {
        if (!toBasePurpose(purposeRaw)) {
          return error(unknownProducts(productArrayRaw));
        }
        return setByPurpose(modelLocal, purposeRaw);
      }
      if (purpose !== RESERVED_PURPOSE && pids.includes(PRODUCTS_MAP.DL)) {
        return {
          error: errorDlProductReserved(purpose)
        };
      }
      if (purpose === RESERVED_PURPOSE && pids.some(function(product) {
        return product !== PRODUCTS_MAP.DL;
      })) {
        return error(errorDlReserved);
      }
      var consentResult = getConsentsByProducts(modelLocal, purpose, pids);
      if (consentResult === null || consentResult === void 0 ? void 0 : consentResult.error) {
        return consentResult;
      }
      var newPurposes = pids.reduce(function(res, productId) {
        res[productId] = purpose;
        return res;
      }, {});
      return {
        consent: (consentResult === null || consentResult === void 0 ? void 0 : consentResult.consent) || null,
        purposes: newPurposes
      };
    };
    if (!isRequireConsentV2()) {
      return error(consentV2IsDisabled);
    }
    if (products2) {
      return setByPurposeAndProduct(mode, modeOrType, products2);
    } else if (mode) {
      return setByPurpose(mode, modeOrType);
    } else {
      return setAllModes(modeOrType);
    }
  }
  var getExtendedConsent = function(consent4, purposes2) {
    if (!consent4) {
      return null;
    }
    var purposesLocal = purposes2 || initialPurposeMap;
    var purposesNames = fillProductNameReduce(purposesLocal);
    return getProducts().reduce(function(res, _a) {
      var _b;
      var productName = _a.name;
      var purpose = purposesNames[productName];
      var productMode = ((_b = consent4[productName]) === null || _b === void 0 ? void 0 : _b.mode) || OPT_IN_MODE;
      if (!res[purpose]) {
        res[purpose] = {
          mode: productMode,
          products: [productName]
        };
      } else {
        res[purpose].mode = getStrictMode(res[purpose].mode, productMode);
        res[purpose].products.push(productName);
      }
      return res;
    }, {});
  };
  var getNotAcquiredConsent = function() {
    return isRequireConsentV2() ? keys(purposeByProduct).reduce(function(res, purpose) {
      res[purpose] = {
        mode: "not-acquired",
        products: purposeByProduct[purpose]
      };
      return res;
    }, {}) : null;
  };
  var actions = ["include", "exclude", "obfuscate"];
  var validateBrowserId = function(val) {
    var length = val && val.length;
    return length === 16 || length === 36 ? val : null;
  };
  var oneOf = function(name3, value) {
    return '"'.concat(name3, '" should be one of ').concat(value.join(", "));
  };
  var emptyFn = function() {
  };
  var addPrefix = function(prefix, log3) {
    return function(val) {
      return log3(prefix + val);
    };
  };
  var toProduct = function(product, log3) {
    if (log3 === void 0) {
      log3 = emptyFn;
    }
    var index = PRODUCTS_MAP[product.toLowerCase()];
    if (index !== void 0) {
      return PRODUCTS[index].name;
    }
    log3('"'.concat(product, '" is not found'));
    return null;
  };
  var toMode = function(mode) {
    return isConsentBaseMode(mode) ? mode : null;
  };
  var validateModifier = function(modifier, log3) {
    if (log3 === void 0) {
      log3 = emptyFn;
    }
    var source = modifier.source;
    var newPatches = modifier.patches || [];
    if (!toMode(source)) {
      log3(oneOf("source", modeListBase));
      source = OPT_IN_MODE;
    }
    if (!isArray(newPatches)) {
      log3('"patches" should be an array');
      newPatches = [];
    }
    newPatches = newPatches.reduce(function(res, patch, i) {
      if (!isObject(patch) || isArray(patch)) {
        log3("patch[".concat(i, "]: should be type of {action, item, with?}"));
        return res;
      }
      var action = patch.action, item = patch.item;
      if (!actions.includes(action)) {
        log3("patch[".concat(i, "]: ") + oneOf("action", actions));
        return res;
      }
      if (!item || !isObject(item) || !item.key || !item.type) {
        log3("patch[".concat(i, ']: "item" should be type of {key, type}'));
        return res;
      }
      res.push(patch);
      return res;
    }, []);
    return {
      source,
      patches: newPatches
    };
  };
  var validateConsent$1 = function(consent4, log3) {
    if (log3 === void 0) {
      log3 = emptyFn;
    }
    if (!consent4) {
      return null;
    }
    var result = {};
    if (consent4.products) {
      if (!isArray(consent4.products)) {
        log3("consent.products: should be an array");
      } else {
        result.products = consent4.products.reduce(function(res, product) {
          var validProduct = toProduct(product, addPrefix("consent.products: ", log3));
          if (validProduct) {
            res.push(validProduct);
          }
          return res;
        }, []);
      }
    }
    if (consent4.defaultPreset) {
      result.defaultPreset = keys(consent4.defaultPreset).reduce(function(res, productKey) {
        var product = toProduct(productKey, addPrefix("consent.defaultPreset: ", log3));
        var mode = toMode(consent4.defaultPreset[productKey]);
        if (!mode) {
          log3("consent.defaultPreset: " + oneOf(productKey, modeListBase));
        }
        if (product && mode) {
          res[product] = mode;
        }
        return res;
      }, {});
    }
    var purposes2 = consent4.defaultPurposes;
    if (purposes2) {
      result.defaultPurposes = keys(purposes2).reduce(function(res, productKey) {
        var purposeLog = addPrefix("consent.defaultPurposes: ", log3);
        var product = toProduct(productKey, purposeLog);
        var rawPurpose = purposes2[productKey];
        var purpose = toPurpose(rawPurpose);
        if (purpose === RESERVED_PURPOSE || product === RESERVED_PRODUCT) {
          purposeLog('"'.concat(productKey, ": ").concat(rawPurpose, '" - invalid config'));
        } else if (product && purpose) {
          res[product] = purpose;
        }
        return res;
      }, {});
    }
    return result;
  };
  var validateConsentMemo = memo(validateConsent$1);
  var validateMigration = function(migration2, log3) {
    if (log3 === void 0) {
      log3 = emptyFn;
    }
    return keys(migration2 || {}).reduce(function(res, propName) {
      var data = migration2 === null || migration2 === void 0 ? void 0 : migration2[propName];
      var product = toProduct((data === null || data === void 0 ? void 0 : data.source) || "", log3);
      res[propName] = __assign2(__assign2({}, data), { source: product });
      return res;
    }, {});
  };
  var generateInitProtectedValue = function(_cookieInitValue, changeConfig) {
    changeConfig({
      protect: true
    });
    return validateBrowserId(getGlobalConfig$1().browserId || null) || _cookieInitValue || randomStringCxCompatible();
  };
  var browserId = __assign2(__assign2({}, createBaseParam(null, "_pcid")), {
    init: generateInitProtectedValue,
    update: function(_prev, changeConfig) {
      changeConfig({
        protect: true
      });
      return randomStringCxCompatible();
    },
    set: function(value, _prev, changeConfig) {
      changeConfig({
        protect: true
      });
      return value;
    }
  });
  var PRESETS_TABLE = [
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 2, 2, 2, 2, 2, 0],
    [1, 2, 2, 2, 2, 2, 2, 1],
    [0, 2, 0, 2, 2, 2, 0, 0],
    [1, 2, 2, 2, 2, 2, 1, 1],
    [2, 0, 0, 2, 2, 2, 2, 0],
    [2, 0, 2, 2, 2, 2, 2, 0],
    [2, 2, 2, 2, 2, 2, 0, 2],
    [2, 2, 0, 0, 0, 0, 2, 0],
    [2, 2, 1, 2, 1, 2, 2, 1],
    [2, 2, 1, 1, 2, 2, 2, 1]
  ];
  var convertIndexModes = function(modes) {
    return modes.reduce(function(res, modeIndex, productId) {
      var _a;
      return __assign2(__assign2({}, res), (_a = {}, _a[productId] = { mode: modeIdMap[modeIndex] }, _a));
    }, {});
  };
  var PRESETS = PRESETS_TABLE.map(function(modes, id) {
    return {
      id,
      preset: convertIndexModes(modes)
    };
  });
  var onChangeConfigPresets = onMemo(function() {
    var _a;
    return (_a = validateConsentMemo(getGlobalConfig$1().consent)) === null || _a === void 0 ? void 0 : _a.defaultPreset;
  });
  var getPresets = function() {
    var result = PRESETS;
    return function() {
      onChangeConfigPresets(function(defaultPreset) {
        result = PRESETS.slice();
        if (defaultPreset) {
          result[0] = {
            id: 0,
            preset: __assign2({}, result[0].preset)
          };
          keys(defaultPreset).forEach(function(name3) {
            var mode = defaultPreset[name3];
            var productId = PRODUCTS_MAP[name3];
            result[0].preset[productId] = { mode };
          });
        }
      });
      return result;
    };
  }();
  var getDefaultPreset = function() {
    return getPresets()[0].preset;
  };
  var getCalculatedPreset = function(presetIndexes) {
    var currentPreset = null;
    presetIndexes.forEach(function(presetIndex) {
      var preset = PRESETS_TABLE[presetIndex];
      if (!currentPreset && preset) {
        currentPreset = preset;
        return;
      }
      if (!currentPreset || !preset) {
        return;
      }
      currentPreset = currentPreset.map(function(indexMode, productIndex) {
        return Math.min(indexMode, preset[productIndex]);
      });
    });
    return currentPreset && convertIndexModes(currentPreset);
  };
  var convertToConsent = function(val) {
    return keys(val).reduce(function(res, key2) {
      var config = val[key2];
      var pid = getPid(key2);
      if (pid === null) {
        return res;
      }
      var mode = isConsentMode(config.mode) ? config.mode : null;
      if (mode) {
        if (!res) {
          res = {};
        }
        res[pid] = { mode };
      }
      return res;
    }, null);
  };
  var filterByProductConsent = function(value, prevValue) {
    return filterByProduct(value, prevValue, function(config, prevConfig, pid) {
      var mode = (config === null || config === void 0 ? void 0 : config.mode) || (prevConfig === null || prevConfig === void 0 ? void 0 : prevConfig.mode) || getDefaultPreset()[pid].mode;
      if (mode !== (prevConfig === null || prevConfig === void 0 ? void 0 : prevConfig.mode)) {
        return {
          mode
        };
      }
      return prevConfig;
    });
  };
  var consent = __assign2(__assign2({}, createBaseParam(null, "_pprv")), { init: function(valueFromCookie) {
    return getRequireConsent() && valueFromCookie ? filterByProductConsent(valueFromCookie, null) : null;
  }, set: function(val, prevVal) {
    var _a;
    if (!getRequireConsent()) {
      return null;
    }
    if (val === null || val === void 0) {
      return prevVal;
    }
    var newConsent;
    if (isNumber(val)) {
      newConsent = ((_a = getPresets()[val]) === null || _a === void 0 ? void 0 : _a.preset) || null;
    } else if (isArray(val)) {
      newConsent = getCalculatedPreset(val);
    } else {
      newConsent = convertToConsent(val);
    }
    return newConsent ? filterByProductConsent(newConsent, prevVal) : prevVal;
  }, get: memo(function(value) {
    return value && fillProductNameReduce(value, function(config, productName) {
      var _a;
      var newConfig = __assign2({}, config);
      if (newConfig.mode === CUSTOM_MODE) {
        newConfig.modifier = ((_a = getGlobalConfigModifiers()) === null || _a === void 0 ? void 0 : _a[productName]) || null;
      }
      return newConfig;
    });
  }, function() {
    return getGlobalConfigModifiers();
  }) });
  var consentPresets = __assign2(__assign2({}, createStaticParam()), { init: getPresets, set: getPresets });
  var products = __assign2(__assign2({}, createStaticParam()), { init: getProducts, set: getProducts });
  var consentModifiers = __assign2(__assign2({}, createStaticParam(null)), {
    readonly: true,
    set: function() {
      return null;
    },
    get: getGlobalConfigModifiers
  });
  var toDate = function(val) {
    var timeStamp = Number(val);
    if (!Number.isNaN(timeStamp)) {
      return timeStamp;
    }
    return String(val);
  };
  var toArrayString = function(val) {
    return isArray(val) ? val : val.split(",").map(function(s) {
      return s.trim().replace(/^['"](.+)['"]$/, "$1");
    });
  };
  var asIs = function(val) {
    return val;
  };
  var Validators = {
    id: asIs,
    type: asIs,
    zone: asIs,
    createdAt: toDate,
    modifiedAt: toDate,
    authors: toArrayString,
    section: asIs,
    tags: toArrayString,
    keywords: toArrayString,
    title: asIs,
    description: asIs,
    isNative: toBoolean
  };
  var isAll = function(take) {
    return take === "all";
  };
  var isFirst = function(take) {
    return take === "first";
  };
  var isLast = function(take) {
    return take === "last";
  };
  function query(selector, take) {
    if (selector === void 0) {
      selector = "meta";
    }
    if (isFirst(take)) {
      return document.querySelector(selector);
    }
    var els = document.querySelectorAll(selector);
    return isLast(take) ? els[els.length - 1] : Array.from(els);
  }
  var queryMetasMemo = function() {
    var res = null;
    var refresh = function() {
      res = query() || null;
      if (res) {
        setTimeout(function() {
          res = null;
        }, 0);
      }
    };
    return {
      refresh,
      find: function(attrs, hasContent) {
        if (hasContent === void 0) {
          hasContent = false;
        }
        return res ? res.reduce(function(obj, el) {
          for (var _i = 0, attrs_1 = attrs; _i < attrs_1.length; _i++) {
            var attr = attrs_1[_i];
            var name_1 = ((attr === "name" ? el.name : el.getAttribute(attr)) || "").trim().toLowerCase();
            var content2 = el.content;
            if (!name_1 || hasContent && !content2) {
              continue;
            }
            if (!obj[name_1]) {
              obj[name_1] = [];
            }
            obj[name_1].push(el);
            break;
          }
          return obj;
        }, {}) : null;
      }
    };
  }();
  var readMetaValue = function(config) {
    var metaContent = function(meta) {
      return meta.content;
    };
    var getContent = config.getContent || metaContent;
    var readSpecificSelector = function() {
      var el = query(config.selector, config.take || "first");
      return el && getContent(el) || null;
    };
    var readFromMeta = function() {
      var metas = queryMetasMemo.find(config.attr || ["name"], config.hasContent);
      var names = config.names || [];
      var single = !isAll(config.take);
      var last = isLast(config.take);
      if (!metas) {
        return null;
      }
      var _loop_1 = function(name_22) {
        var result = [];
        var elements = metas[name_22];
        if (elements) {
          if (single) {
            var index = last ? elements.length - 1 : 0;
            var meta = elements[index];
            return { value: getContent(meta) || "" };
          }
          elements.forEach(function(el) {
            result = result.concat(getContent(el) || "");
          });
        }
        if (result.length) {
          return { value: result };
        }
      };
      for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
        var name_2 = names_1[_i];
        var state_1 = _loop_1(name_2);
        if (typeof state_1 === "object")
          return state_1.value;
      }
      return null;
    };
    return config.selector ? readSpecificSelector() : readFromMeta();
  };
  var readMetaValues = function(configs) {
    for (var _i = 0, configs_1 = configs; _i < configs_1.length; _i++) {
      var conf = configs_1[_i];
      var val = readMetaValue(conf);
      if (val) {
        return val;
      }
    }
  };
  var append = function(data, name3, config) {
    var validate = Validators[name3];
    var exist = Boolean(data[name3]);
    var readValue = typeof config === "function" ? config : function() {
      return isArray(config) ? readMetaValues(config) : readMetaValue(config);
    };
    if (!exist && validate) {
      var value = readValue();
      var validatedValue = value && validate(value);
      if (validatedValue) {
        data[name3] = validatedValue;
      }
    }
  };
  var property = function(val) {
    return {
      attr: ["property"],
      names: [val]
    };
  };
  var name2 = function(val) {
    return {
      names: [val]
    };
  };
  var appendLegacyComposer = function(prevValue) {
    append(prevValue, "type", property("og:type"));
    append(prevValue, "section", name2("section"));
    append(prevValue, "id", name2("id"));
    append(prevValue, "authors", name2("author"));
  };
  function isArticle(ldJsonPart) {
    return ldJsonPart && isString(ldJsonPart["@type"]) && ldJsonPart["@type"].includes("Article");
  }
  function findArticle(parsedLdJson) {
    if (isArray(parsedLdJson)) {
      return parsedLdJson.find(function(part) {
        return isArticle(part);
      }) || {};
    }
    return {};
  }
  function readLdJson() {
    var ldJsonElements = document.querySelectorAll('script[type="application/ld+json"]');
    if (ldJsonElements) {
      var parsedLdJsons = Array.from(ldJsonElements).flatMap(function(element) {
        return parseJSON(element.innerHTML);
      });
      return findArticle(parsedLdJsons);
    }
    return {};
  }
  var monthNames = {
    januar: "01",
    january: "01",
    jan: "01",
    februar: "02",
    february: "02",
    feb: "02",
    mars: "03",
    march: "03",
    mar: "03",
    april: "04",
    apr: "04",
    mai: "05",
    may: "05",
    juni: "06",
    june: "06",
    jun: "06",
    juli: "07",
    july: "07",
    jul: "07",
    august: "08",
    aug: "08",
    september: "09",
    sept: "09",
    sep: "09",
    oktober: "10",
    october: "10",
    okt: "10",
    oct: "10",
    november: "11",
    nov: "11",
    desember: "12",
    december: "12",
    dec: "12",
    des: "12"
  };
  var dateFormatRegex = function(input) {
    var format = input.replace(/DAY/g, "(0?[1-9]|[12][0-9]|3[01])").replace(/MONTHLONG/g, "(" + keys(monthNames).join("|") + ")").replace(/MONTH/g, "(0?[1-9]|1[012])").replace(/YEAR2/g, "([0-9][0-9])").replace(/YEAR/g, "(197[1-9]|19[8-9][0-9]|20[0-9][0-9])").replace(/TIME/g, "([0-9][0-9]):([0-9][0-9]):([0-9][0-9])(?:\\.[0-9][0-9][0-9])?([zZ]|[+-][0-9][0-9](?::?[0-9][0-9])?)?");
    var order = input.replace(/.*?([YMD])(EAR|ONTH|AY).*?/g, "$1").substring(0, 3);
    return [new RegExp(format), order];
  };
  var dateFormats = function() {
    return [
      "\\bDAY\\.MONTH\\.YEAR\\b",
      "\\bDAY\\.?\\s{0,3}MONTHLONG\\.?\\s{1,3}YEAR\\b",
      "\\bYEAR-MONTH-DAY(?:[tT]|\\b)",
      "\\bMONTHLONG\\.?\\s{0,3}DAY(?:st|nd|rd|th)?,?\\s{1,3}YEAR\\b",
      "\\bDAY(?:st|nd|rd|th|\\.)?\\s{0,3}MONTHLONG\\.?,?\\s{1,3}YEAR\\b",
      "\\bYEAR[/\u5E74]MONTH[/\u6708]DAY(?=\\b|\u65E5)",
      "\\bDAY\\.MONTH\\.YEAR2\\b",
      "\\bDAY/MONTH/YEAR\\b"
    ].map(dateFormatRegex);
  }();
  var dateTimeRegex = dateFormatRegex("YEAR-MONTH-DAY[tT]TIME")[0];
  var int = function(val) {
    return val && parseInt(val, 10) || 0;
  };
  function dateToISO(year, month, day, hour, minute, second, zone) {
    var then = new Date(Date.UTC(int(year), int(month) - 1, int(day), int(hour), int(minute), int(second)));
    var zoneMatch = (zone || "").match(/^([+-][0-9][0-9])(?::?([0-9][0-9])?)$/);
    if (zoneMatch) {
      then = new Date(then.getTime() - Number(zoneMatch[1]) * 36e5 - (Number(zoneMatch[2]) || 0) * 6e4);
    }
    var msPerDay = 1e3 * 24 * 60 * 60;
    var diff = Date.now() - then.getTime();
    return diff > 0 || -diff < 2 * msPerDay ? then.toISOString() : null;
  }
  function anyDateToISODate(date) {
    date = date.toLowerCase();
    var fullMatch = date.match(dateTimeRegex);
    if (fullMatch) {
      return dateToISO(fullMatch[1], fullMatch[2], fullMatch[3], fullMatch[4], fullMatch[5], fullMatch[6], fullMatch[7]);
    }
    for (var _i = 0, dateFormats_1 = dateFormats; _i < dateFormats_1.length; _i++) {
      var format = dateFormats_1[_i];
      var match = date.match(format[0]);
      if (match) {
        match = format[1] === "DMY" ? ["", match[3], match[2], match[1]] : format[1] === "MDY" ? ["", match[3], match[1], match[2]] : match;
        var year = match[1].length === 2 ? (int(match[1]) < 60 ? "20" : "19") + match[1] : match[1];
        var month = match[2].length <= 2 ? match[2] : monthNames[match[2]];
        return dateToISO(year, month, match[3]);
      }
    }
  }
  var clearContent = function(str) {
    return str.replace(/<\/?[^>?]*\/?>/g, " ").replace(/\s+/g, " ").trim();
  };
  function authorNormalization(author) {
    if (author === void 0) {
      author = "";
    }
    return clearContent(author.replace(/,(?=\s*(jr|sr)(\.?)\b)/g, " "));
  }
  function splitAuthors(authors) {
    if (authors === void 0) {
      authors = "";
    }
    var parsedAuthors = authors.replace(/\n+/, ";").replace(/(\<|&lt;)br(\>|&gt;)/, ";").replace(/\b(and|und|og)\b/g, ";");
    return authorNormalization(parsedAuthors).split(/[,;]/);
  }
  var getContentAuthors = function(el) {
    var separator = el.getAttribute("data-separator");
    var content2 = el.content;
    return separator ? authorNormalization(content2).split(separator) : splitAuthors(content2);
  };
  var takeLast = function(config) {
    return __assign2(__assign2({}, config), { take: "last" });
  };
  var hasContentAndLast = function(config) {
    return __assign2(__assign2({}, config), { take: "last", hasContent: true, getContent: function(el) {
      return clearContent(el.content || "");
    } });
  };
  var publishTimeConfig = [
    takeLast({
      attr: ["name", "property", "itemprop"],
      names: [
        "cxenseparse:publishtime",
        "cxenseparse:recs:publishtime",
        "article:published_time",
        "date",
        "dc.date",
        "dc.date.created",
        "dc.terms.issued",
        "pub_date",
        "article.published",
        "datepublished",
        "og:article:published_time"
      ]
    }),
    takeLast({
      selector: "time.published[datetime],time[pubdate][datetime]",
      getContent: function(el) {
        return el.getAttribute("datetime");
      }
    }),
    takeLast({
      selector: 'time[itemprop="datePublished"][datetime]',
      getContent: function(el) {
        return el.getAttribute("datetime");
      }
    })
  ];
  var modifiedTimeConfig = [
    takeLast({
      attr: ["name", "property", "itemprop"],
      names: ["article:modified_time", "datemodified"]
    }),
    takeLast({
      selector: 'time[itemprop="dateModified"][datetime]',
      getContent: function(el) {
        return el.getAttribute("datetime");
      }
    })
  ];
  var authorConfig = [
    {
      attr: ["property", "name"],
      names: [
        "cxenseparse:author",
        "og:article:author",
        "article:author",
        "og:book:author",
        "book:author",
        "author",
        "dc.creator",
        "article.author"
      ],
      take: "all",
      getContent: getContentAuthors
    }
  ];
  var keywordsConfig = [
    hasContentAndLast({
      names: ["cxenseparse:keywords"]
    }),
    hasContentAndLast({
      attr: ["property", "name"],
      names: ["news_keywords"]
    }),
    hasContentAndLast({
      names: ["keywords"]
    })
  ];
  var descriptionConfig = [
    hasContentAndLast({
      names: ["cxenseparse:description"]
    }),
    hasContentAndLast({
      attr: ["property"],
      names: ["og:description"]
    }),
    hasContentAndLast({
      names: ["description"]
    })
  ];
  var internalTitle = [
    {
      names: ["cxenseparse:title"]
    },
    takeLast({
      attr: ["property", "name"],
      names: ["og:title"]
    })
  ];
  var appendLdJsonCrawler = function(data) {
    var maybeArticle = readLdJson();
    if (isArticle(maybeArticle)) {
      append(data, "createdAt", function() {
        var datePublished = maybeArticle.datePublished;
        return datePublished ? anyDateToISODate(datePublished.toLowerCase()) : null;
      });
      append(data, "modifiedAt", function() {
        var dateModified = maybeArticle.dateModified;
        return dateModified ? anyDateToISODate(dateModified.toLowerCase()) : null;
      });
      append(data, "authors", function() {
        var author = maybeArticle.author;
        return author ? isArray(author) ? author.map(function(a) {
          return a.name;
        }).join(", ") : author.name : null;
      });
      append(data, "keywords", function() {
        var keywords = maybeArticle.keywords;
        return isString(keywords) && keywords.length <= 1024 ? keywords : null;
      });
      append(data, "title", function() {
        return maybeArticle.headline;
      });
      append(data, "description", function() {
        return maybeArticle.description;
      });
    }
  };
  var appendLegacyCrawler = function(data) {
    append(data, "createdAt", function() {
      var publishTime = readMetaValues(publishTimeConfig);
      return publishTime ? anyDateToISODate(publishTime.toLowerCase()) : null;
    });
    append(data, "modifiedAt", function() {
      var modifiedTime = readMetaValues(modifiedTimeConfig);
      return modifiedTime ? anyDateToISODate(modifiedTime.toLowerCase()) : null;
    });
    append(data, "authors", authorConfig);
    append(data, "keywords", function() {
      var keywords = readMetaValues(keywordsConfig);
      return keywords && keywords.length <= 1024 ? keywords : null;
    });
    append(data, "title", internalTitle);
    append(data, "description", descriptionConfig);
  };
  var readMetaElements = function() {
    var data = Array.from(document.querySelectorAll("meta[property^=content]")).reduce(function(res, meta) {
      var _a;
      var type2 = (_a = meta === null || meta === void 0 ? void 0 : meta.getAttribute("property")) === null || _a === void 0 ? void 0 : _a.split(":").pop();
      var validate = Validators[type2];
      if (validate && meta) {
        res[type2] = validate((meta === null || meta === void 0 ? void 0 : meta.getAttribute("content")) || "");
      }
      return res;
    }, {});
    queryMetasMemo.refresh();
    appendLegacyComposer(data);
    appendLdJsonCrawler(data);
    appendLegacyCrawler(data);
    return data;
  };
  var content = __assign2(__assign2({}, createStaticParam(null)), { init: function() {
    return readMetaElements();
  }, refresh: function(prevValue) {
    var newValue = readMetaElements();
    if (prevValue === null || prevValue === void 0 ? void 0 : prevValue._fixed_) {
      prevValue === null || prevValue === void 0 ? void 0 : prevValue._fixed_.forEach(function(fieldName) {
        delete newValue[fieldName];
      });
    }
    return __assign2(__assign2({}, prevValue), newValue);
  }, set: function(value, prevValue) {
    if (value === null) {
      return {};
    }
    var fixedSet = new Set(prevValue && prevValue._fixed_);
    var proceedValue = function(filter, forEachCb) {
      keys(filterObjectValues(value, filter)).forEach(forEachCb);
    };
    proceedValue(isNotEmpty, function(val) {
      fixedSet.add(val);
    });
    proceedValue(isEmpty, function(val) {
      fixedSet.delete(val);
    });
    return filterObjectValues(__assign2(__assign2(__assign2({}, prevValue), value), { _fixed_: Array.from(fixedSet.values()) }), isNotEmpty);
  }, get: memo(function(value) {
    var getValue = __assign2({}, value);
    delete getValue._fixed_;
    return value && getValue;
  }) });
  var userSegments = __assign2(__assign2({}, createBaseParam(null, "_pcus")), { init: function(valueFromCookie) {
    if (valueFromCookie === void 0) {
      valueFromCookie = null;
    }
    return valueFromCookie && filterObjectValues(valueFromCookie, function(val) {
      return isObject(val) && isArray(val.segments);
    });
  } });
  var PropertiesMap = {
    pageViewId,
    browserId,
    users,
    userStatus: userState,
    siteId: createBaseParam(),
    consent,
    consentPresets,
    products,
    consentModifiers,
    purposes,
    content,
    userSegments
  };
  var domainExceptions = ["pantheon.io", "go-vip.net", "go-vip.co"];
  var DEFAULT_COOKIE_OPTIONS = {
    path: "/",
    expires: 395,
    samesite: "lax",
    secure: window.location.protocol === "https:",
    domain: cookie.getTopLevelDomain(domainExceptions)
  };
  var createDateByExpires = function(expires) {
    var date = new Date();
    if (expires instanceof Date) {
      date = expires;
    } else if (typeof expires === "number") {
      date.setDate(date.getDate() + expires);
    } else {
      return null;
    }
    return date;
  };
  var dateToString = function(date) {
    return date.getTime().toString(36);
  };
  var stringToDate = function(date) {
    return date ? tryFn(function() {
      return new Date(parseInt(date, 36));
    }) : null;
  };
  var expirationName = "_t";
  var initFixedUtils = function(rawData, _a) {
    var encode2 = _a.encode, decode4 = _a.decode;
    var fixedMode = false;
    var fixedExpirationDate = null;
    var fixedCreationDate = null;
    var _onChangeCb = null;
    (function() {
      var _a2;
      var expiration = (_a2 = decode4(rawData || "")) === null || _a2 === void 0 ? void 0 : _a2[expirationName];
      if (expiration) {
        var splitData = expiration.split("|");
        fixedExpirationDate = stringToDate(splitData[0]);
        fixedCreationDate = stringToDate(splitData[1]);
        fixedMode = !!fixedExpirationDate;
      }
    })();
    var getFixedExpiration = function(options) {
      fixedExpirationDate = fixedExpirationDate || createDateByExpires(options.expires);
      return fixedExpirationDate;
    };
    var getFixedCreation = function() {
      fixedCreationDate = fixedCreationDate || new Date();
      return fixedCreationDate;
    };
    var encodeData = function(data, options) {
      if (fixedMode) {
        fixedExpirationDate = getFixedExpiration(options);
        if (fixedExpirationDate) {
          data[expirationName] = dateToString(fixedExpirationDate) + "|" + dateToString(getFixedCreation());
        }
      } else {
        delete data[expirationName];
      }
      return encode2(data);
    };
    var decodeData = function(data) {
      var result = decode4(data);
      if (result === null || result === void 0 ? void 0 : result[expirationName]) {
        delete result[expirationName];
      }
      return result;
    };
    var bindOptions = function(options) {
      if (fixedMode) {
        fixedExpirationDate = getFixedExpiration(options);
        if (fixedExpirationDate) {
          return __assign2(__assign2({}, options), { expires: fixedExpirationDate });
        }
      }
      return options;
    };
    return {
      get fixedAt() {
        return fixedMode ? [fixedCreationDate, fixedExpirationDate] : null;
      },
      onChange: function(cb) {
        _onChangeCb = cb;
      },
      setMode: function(val) {
        var prevFixedMode = fixedMode;
        fixedMode = val;
        if (fixedMode !== prevFixedMode) {
          fixedExpirationDate = null;
          fixedCreationDate = null;
          _onChangeCb === null || _onChangeCb === void 0 ? void 0 : _onChangeCb(fixedMode);
        }
      },
      bindOptions,
      decode: decodeData,
      encode: encodeData
    };
  };
  var ESSENTIAL_CONFIG = "essential";
  var OPTIONAL_CONFIG = "optional";
  var MANDATORY_CONFIG = "mandatory";
  var createCookieEncoder = function(cookieName, consent4, useBase64) {
    if (consent4 === void 0) {
      consent4 = OPTIONAL_CONFIG;
    }
    if (useBase64 === void 0) {
      useBase64 = false;
    }
    return {
      cookieName,
      consent: consent4,
      encode: function(data) {
        return toJSON(data, useBase64);
      },
      decode: function(data) {
        return parseJSON(data, true);
      }
    };
  };
  var createCookieWrapper = function(encoder) {
    var cookieName = encoder.cookieName, consent4 = encoder.consent;
    var cookieInitialData = cookie.get(cookieName);
    var cookieEnabled = !!cookieInitialData;
    var cookieCreated = cookieEnabled;
    var fixedUtils = initFixedUtils(cookieInitialData, encoder);
    var expirationIsUpdated = !!fixedUtils.fixedAt;
    var lazy = cookieEnabled;
    var obfuscatedValue = null;
    var boundedCookieOptions = __assign2({}, DEFAULT_COOKIE_OPTIONS);
    var cachedData = null;
    var isEnabled = function() {
      return cookieEnabled && lazy;
    };
    var setCookie = function(options) {
      var newOptions = getOptions(options);
      var cookieString = obfuscatedValue || (cachedData ? fixedUtils.encode(cachedData, newOptions) : "");
      if (!cookieString) {
        var raw = cookie.get(cookieName);
        var decodedData = fixedUtils.decode(raw || "");
        cookieString = decodedData ? fixedUtils.encode(decodedData, newOptions) : "";
      }
      if (cookieString) {
        expirationIsUpdated = true;
        cookie.set(cookieName, cookieString, fixedUtils.bindOptions(newOptions));
        cookieCreated = true;
      }
    };
    var getOptions = function(options) {
      return __assign2(__assign2({}, boundedCookieOptions), filterObjectValues(options || {}, isNotEmpty));
    };
    var get = function() {
      return fixedUtils.decode(cookie.get(cookieName) || "");
    };
    var set = function(value, options) {
      cachedData = value;
      if (!isEnabled()) {
        return;
      }
      setCookie(options);
    };
    var remove = function(options) {
      if (!isEnabled()) {
        return;
      }
      if (cookieCreated) {
        cookie.remove(cookieName, getOptions(options));
      }
      cookieCreated = false;
    };
    var checkAndCreateCookie = function(enable, lazyActive) {
      var nowEnabled = enable && lazyActive;
      if (!isEnabled() && nowEnabled) {
        setCookie();
      }
      if (isEnabled() && !nowEnabled) {
        remove();
      }
      if (isEnabled() && nowEnabled && !expirationIsUpdated) {
        setCookie();
      }
      cookieEnabled = enable;
      lazy = lazyActive;
    };
    var lazyAction = function() {
      checkAndCreateCookie(cookieEnabled, true);
    };
    var setCookieOptions = function(options) {
      boundedCookieOptions = getOptions(options);
      if (isEnabled()) {
        setCookie();
      }
    };
    var setCookieEnabled = function(enabled, _obfuscatedValue) {
      if (_obfuscatedValue === void 0) {
        _obfuscatedValue = null;
      }
      obfuscatedValue = enabled ? _obfuscatedValue : null;
      checkAndCreateCookie(enabled, lazy);
    };
    var setFixedMode = function(val) {
      fixedUtils.setMode(val);
    };
    fixedUtils.onChange(function() {
      if (isEnabled()) {
        expirationIsUpdated = false;
        setCookie();
      }
    });
    return {
      get cookieName() {
        return cookieName;
      },
      get cookieEnabled() {
        return isEnabled();
      },
      get fixedAt() {
        return fixedUtils.fixedAt;
      },
      get consent() {
        return consent4;
      },
      set,
      get,
      remove,
      setCookieOptions,
      setCookieEnabled,
      lazyActive: lazyAction,
      setFixedMode
    };
  };
  var createCookieWrappers = function(cookieEncoders2) {
    return keys(cookieEncoders2).reduce(function(res, cookieName) {
      res[cookieName] = createCookieWrapper(cookieEncoders2[cookieName]);
      return res;
    }, {});
  };
  var f = String.fromCharCode;
  var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
  var baseReverseDic = {};
  function _compress(uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null)
      return "";
    var i, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }
      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i = 0; i < 8; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i = 0; i < context_numBits; i++) {
              context_data_val = context_data_val << 1 | value;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i = 0; i < 16; i++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
        if (context_w.charCodeAt(0) < 256) {
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i = 0; i < 8; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i = 0; i < context_numBits; i++) {
            context_data_val = context_data_val << 1 | value;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i = 0; i < 16; i++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i = 0; i < context_numBits; i++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }
    value = 2;
    for (i = 0; i < context_numBits; i++) {
      context_data_val = context_data_val << 1 | value & 1;
      if (context_data_position == bitsPerChar - 1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }
    while (true) {
      context_data_val = context_data_val << 1;
      if (context_data_position == bitsPerChar - 1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      } else
        context_data_position++;
    }
    return context_data.join("");
  }
  function _decompress(length, resetValue, getNextValue) {
    var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i, w, bits, resb, maxpower, power, c, data = { val: getNextValue(0), position: resetValue, index: 1 };
    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }
    bits = 0;
    maxpower = Math.pow(2, 2);
    power = 1;
    while (power != maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb > 0 ? 1 : 0) * power;
      power <<= 1;
    }
    switch (bits) {
      case 0:
        bits = 0;
        maxpower = Math.pow(2, 8);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c = f(bits);
        break;
      case 1:
        bits = 0;
        maxpower = Math.pow(2, 16);
        power = 1;
        while (power != maxpower) {
          resb = data.val & data.position;
          data.position >>= 1;
          if (data.position == 0) {
            data.position = resetValue;
            data.val = getNextValue(data.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }
      bits = 0;
      maxpower = Math.pow(2, numBits);
      power = 1;
      while (power != maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb > 0 ? 1 : 0) * power;
        power <<= 1;
      }
      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2, 8);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize - 1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2, 16);
          power = 1;
          while (power != maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize - 1;
          enlargeIn--;
          break;
        case 2:
          return result.join("");
      }
      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;
      w = entry;
      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
    }
  }
  function getBaseValue(alphabet, character) {
    if (!baseReverseDic[alphabet]) {
      baseReverseDic[alphabet] = {};
      for (var i = 0; i < alphabet.length; i++) {
        baseReverseDic[alphabet][alphabet.charAt(i)] = i;
      }
    }
    return baseReverseDic[alphabet][character];
  }
  function compressToEncodedURIComponent(input) {
    if (input == null)
      return "";
    return _compress(input, 6, function(a) {
      return keyStrUriSafe.charAt(a);
    });
  }
  function decompressFromEncodedURIComponent(input) {
    if (input == null)
      return "";
    if (input == "")
      return null;
    input = input.replace(/ /g, "+");
    return _decompress(input.length, 32, function(index) {
      return getBaseValue(keyStrUriSafe, input.charAt(index));
    });
  }
  var ECompressType;
  (function(ECompressType2) {
    ECompressType2["URI"] = "URI";
  })(ECompressType || (ECompressType = {}));
  var CompressFuncByType = {
    URI: {
      prefix: "{u}",
      compress: compressToEncodedURIComponent,
      decompress: decompressFromEncodedURIComponent
    }
  };
  var CompressFuncByPrefix = keys(CompressFuncByType).reduce(function(res, key2) {
    res[CompressFuncByType[key2].prefix] = CompressFuncByType[key2];
    return res;
  }, {});
  var compress = function(data, type2) {
    if (type2 === void 0) {
      type2 = ECompressType.URI;
    }
    var inputString = JSON.stringify(data);
    var compressString = CompressFuncByType[type2].compress(inputString);
    return CompressFuncByType[type2].prefix + compressString;
  };
  var decompress = function(data) {
    var prefix = data.slice(0, 3);
    var decompressString = data.slice(3);
    if (!CompressFuncByPrefix[prefix]) {
      return null;
    }
    var decompressedString = CompressFuncByPrefix[prefix].decompress(decompressString);
    if (!decompressedString) {
      return null;
    }
    try {
      return JSON.parse(decompressedString);
    } catch (e) {
      return null;
    }
  };
  var _pctx = {
    cookieName: "_pctx",
    consent: MANDATORY_CONFIG,
    encode: compress,
    decode: function(dataString) {
      var data = decompress(dataString || "");
      if (!isObject(data)) {
        return null;
      }
      return data;
    }
  };
  var useJSONPprv = function() {
    var _a, _b;
    return !!((_b = (_a = getGlobalConfig$1().cookies) === null || _a === void 0 ? void 0 : _a._pprv) === null || _b === void 0 ? void 0 : _b.jsonOnly);
  };
  var createCookieEncoders = function() {
    return {
      _pprv: createCookieEncoder("_pprv", MANDATORY_CONFIG, !useJSONPprv()),
      _pcid: createCookieEncoder("_pcid", ESSENTIAL_CONFIG),
      _pcus: createCookieEncoder("_pcus", OPTIONAL_CONFIG, true),
      _pctx
    };
  };
  var cookieEncoders = createCookieEncoders();
  var cookieWrappers = createCookieWrappers(cookieEncoders);
  var createCookieAssociation = function() {
    var fields = null;
    var cookieByName = null;
    var registerConfig = function(config) {
      fields = __assign2(__assign2({}, config.fields), fields);
      cookieByName = __assign2(__assign2({}, config.cookieByName), cookieByName);
      return cookieByName;
    };
    var get = function() {
      var result = {};
      if (cookieByName) {
        keys(cookieByName).forEach(function(key2) {
          result = __assign2(__assign2({}, result), cookieByName[key2].get());
        });
      }
      return result;
    };
    var set = function(data, prevData) {
      if (prevData === void 0) {
        prevData = null;
      }
      var groupedData = {};
      keys(data).forEach(function(fieldName) {
        var fieldValue = data[fieldName];
        var cookieWrapperName = fields === null || fields === void 0 ? void 0 : fields[fieldName];
        if (cookieWrapperName) {
          if (!groupedData[cookieWrapperName]) {
            groupedData[cookieWrapperName] = {
              wrapper: cookieByName === null || cookieByName === void 0 ? void 0 : cookieByName[cookieWrapperName],
              data: {},
              update: false,
              remove: true
            };
          }
          groupedData[cookieWrapperName].data[fieldName] = fieldValue;
          groupedData[cookieWrapperName].remove = groupedData[cookieWrapperName].remove && fieldValue === null;
          if (!prevData || !groupedData[cookieWrapperName].update && fieldValue !== prevData[fieldName]) {
            groupedData[cookieWrapperName].update = true;
          }
        }
      });
      keys(groupedData).forEach(function(key2) {
        var _a = groupedData[key2], wrapper = _a.wrapper, update = _a.update, remove = _a.remove;
        if (remove) {
          wrapper.remove();
        }
        if (update && !remove) {
          wrapper.set(groupedData[key2].data);
        }
      });
    };
    return {
      register: registerConfig,
      get wrappers() {
        return cookieByName;
      },
      get,
      set
    };
  };
  var CONNECTION_NAME_OBJ = "__pctx_connection__";
  var KEY = "uvm42pas28m";
  var emptyObjectData = {};
  var getConnection = function() {
    var cookieAssociation = createCookieAssociation();
    var initCookieData = {};
    var cachedData = null;
    var connections = /* @__PURE__ */ new Map();
    var protectedKeys = /* @__PURE__ */ new Map();
    var updateListeners = [];
    var addListener = function(key2, cb) {
      updateListeners.push([key2, cb]);
    };
    var removeListener = function(key2) {
      updateListeners = updateListeners.filter(function(item) {
        return item[0] !== key2;
      });
    };
    var updateData = function(_, data) {
      var rejectedData = {};
      var newData = {};
      keys(data).forEach(function(key2) {
        if (protectedKeys.has(key2)) {
          rejectedData[key2] = (cachedData === null || cachedData === void 0 ? void 0 : cachedData[key2]) || null;
        } else {
          newData[key2] = data[key2];
        }
      });
      var oldCachedData = cachedData || initCookieData;
      var newCachedData = __assign2(__assign2({}, cachedData), newData);
      if (!shallowEqual(newCachedData, oldCachedData)) {
        cookieAssociation.set(newCachedData, oldCachedData);
        cachedData = newCachedData;
        updateListeners.forEach(function(_a) {
          var cb = _a[1];
          return cb(newData);
        });
      }
      return keys(rejectedData).length > 0 ? rejectedData : null;
    };
    var setProtection = function(connectKey, data, force) {
      if (force === void 0) {
        force = false;
      }
      var rejectKeys = [];
      keys(data).forEach(function(key2) {
        var value = data[key2];
        var actionIsPermitted = !protectedKeys.has(key2) || protectedKeys.get(key2) === connectKey || force;
        if (value && actionIsPermitted) {
          protectedKeys.set(key2, connectKey);
        } else if (!value && actionIsPermitted) {
          protectedKeys.delete(key2);
        } else {
          rejectKeys.push(key2);
        }
      });
      return rejectKeys.length > 0 ? rejectKeys : null;
    };
    return function(name3, currentCookieConfig) {
      var connectionKey = randomStringCxCompatible();
      connections.set(connectionKey, name3);
      if (currentCookieConfig) {
        cookieAssociation.register(currentCookieConfig);
      }
      initCookieData = __assign2(__assign2({}, cookieAssociation.get()), initCookieData);
      return {
        getInitCookieData: function() {
          return initCookieData;
        },
        getCachedData: function() {
          return cachedData || emptyObjectData;
        },
        setProtectionData: function(value) {
          return setProtection(connectionKey, value);
        },
        setProtectionDataUnsafe: function(value) {
          return setProtection(connectionKey, value, true);
        },
        updateData: function(data) {
          return updateData(connectionKey, data);
        },
        onUpdateData: function(cb) {
          addListener(connectionKey, cb);
        },
        terminate: function() {
          removeListener(connectionKey);
          connections.delete(connectionKey);
        },
        setCookieOptions: function() {
          return null;
        },
        setCookieEnabled: function() {
          return null;
        },
        get registeredCookiesWrapper() {
          return cookieAssociation.wrappers;
        }
      };
    };
  };
  var GENERATE_NEW_CONNECTION = "mrlqf5trgho";
  var createConnectFn = function(configurable) {
    if (configurable === void 0) {
      configurable = false;
    }
    return function(name3, cookiesMap) {
      var connection = getConnection();
      try {
        Object.defineProperty(window, CONNECTION_NAME_OBJ, {
          configurable,
          set: function(cb) {
            var key2 = cb();
            if (key2 === KEY) {
              cb(connection);
            } else if (key2 === GENERATE_NEW_CONNECTION) {
              connection = getConnection();
            }
          }
        });
      } catch (e) {
      }
      window[CONNECTION_NAME_OBJ] = function(val) {
        if (val) {
          connection = val;
        }
        return KEY;
      };
      return connection(name3, cookiesMap);
    };
  };
  var connect = createConnectFn();
  var isMask = function(str) {
    return str.includes("*");
  };
  var createMask = function(name3, value) {
    return [
      new RegExp("^" + name3.replace(/\*/g, ".*") + "$"),
      value
    ];
  };
  var itemsToMask = function(items) {
    return keys(items).filter(isMask).map(function(i) {
      return createMask(i, items[i]);
    });
  };
  var getByMask = function(name3, masks) {
    for (var _i = 0, masks_1 = masks; _i < masks_1.length; _i++) {
      var mask = masks_1[_i];
      if (mask[0].test(name3)) {
        return mask[1];
      }
    }
    return null;
  };
  var getConsentModifier = function(itemType, modifierNoStrict, log3) {
    var modifier = modifierNoStrict && validateModifier(modifierNoStrict, log3);
    if (!modifier) {
      return null;
    }
    var masks = [];
    var keys2 = {};
    for (var _i = 0, _a = modifier.patches; _i < _a.length; _i++) {
      var patch = _a[_i];
      var action = patch.action, _b = patch.with, data = _b === void 0 ? null : _b, item = patch.item;
      if (item.type === itemType) {
        var modifierResult = {
          action,
          data
        };
        keys2[item.key] = modifierResult;
        if (isMask(item.key)) {
          masks.push(createMask(item.key, modifierResult));
        }
      }
    }
    var _getModifier = function(name3) {
      return keys2[name3] || getByMask(name3, masks);
    };
    return {
      source: modifier.source,
      getModifier: _getModifier
    };
  };
  var checkMode = function(mode, config) {
    switch (mode) {
      case OPT_IN_MODE:
        return true;
      case ESSENTIAL_MODE:
        return config === ESSENTIAL_CONFIG || config === MANDATORY_CONFIG;
      case OPT_OUT_MODE:
        return config === MANDATORY_CONFIG;
      default:
        return true;
    }
  };
  var checkAction = function(action) {
    switch (action) {
      case "include":
        return true;
      case "exclude":
        return false;
      case "obfuscate":
        return true;
    }
  };
  var getData = function(action, data) {
    return action === "obfuscate" ? data : null;
  };
  var checkProductDisabled = function(productName) {
    if (productName && productName !== RESERVED_PRODUCT) {
      var pdlProducts = getPdlProductNames();
      return !!(pdlProducts && !pdlProducts.includes(productName));
    }
    return false;
  };
  var createCheckConsentWrapper = function(config) {
    var productName = config.product || null;
    var items = Object.assign({}, config.items);
    var masks = itemsToMask(items);
    var getConfigByName = function(name3) {
      return items[name3] || getByMask(name3, masks) || OPTIONAL_CONFIG;
    };
    function checkConsent2(name3, consentValue) {
      var requireConsent = getGlobalConfig$1().requireConsent;
      var isSingle = !isArray(name3);
      var names = isSingle ? [name3] : name3;
      var result = function() {
        var getDefaultResult = function() {
          return names.map(function(cName) {
            return {
              name: cName,
              allowed: !requireConsent || checkProductDisabled(productName)
            };
          });
        };
        var consent4 = consentValue || config.getConsent();
        if (!consent4) {
          return getDefaultResult();
        }
        if (consent4.mode === CUSTOM_MODE) {
          var consentModifier_1 = getConsentModifier(config.type, consent4.modifier, config.log);
          if (!consentModifier_1) {
            return getDefaultResult();
          }
          var source_1 = consentModifier_1.source;
          return names.map(function(itemName) {
            var modifier = consentModifier_1.getModifier(itemName);
            var data = getData(modifier === null || modifier === void 0 ? void 0 : modifier.action, modifier === null || modifier === void 0 ? void 0 : modifier.data);
            var item = {
              name: itemName,
              allowed: (modifier === null || modifier === void 0 ? void 0 : modifier.action) ? checkAction(modifier.action) : checkMode(source_1, getConfigByName(itemName))
            };
            if (data !== null) {
              item.data = data;
            }
            return item;
          });
        }
        return names.map(function(i) {
          return {
            name: i,
            allowed: checkMode(consent4.mode, getConfigByName(i))
          };
        });
      }();
      return isSingle ? result[0] : result;
    }
    return checkConsent2;
  };
  var checkConsent$1 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    createCheckConsentWrapper,
    createMask,
    getByMask,
    isMask,
    itemsToMask
  });
  var localStorageGet = function(name3) {
    var getItem = function(key2) {
      return tryFn(function() {
        return window.localStorage.getItem(key2);
      });
    };
    var value = getItem(name3);
    var ttl = tryFn(function() {
      return parseInt(parseJSON(getItem("_ls_ttl"))[name3], 36);
    });
    return ttl && ttl <= Date.now() ? null : value;
  };
  var getMigrationValue = function() {
    var cookies = {
      pa_vid: function(data) {
        return validateBrowserId(parseJSON(data || "", true) || data);
      },
      atuserid: function(data) {
        var _a;
        return validateBrowserId(((_a = parseJSON(data || "", true)) === null || _a === void 0 ? void 0 : _a.val) || "");
      }
    };
    return function(names) {
      var _loop_1 = function(name_12) {
        try {
          var data = function() {
            if (name_12.ls) {
              return localStorageGet(name_12.ls) || null;
            }
            var raw = cookie.get(name_12);
            return cookies[name_12] && raw ? cookies[name_12](raw) : raw;
          }();
          if (data) {
            return { value: data };
          }
        } catch (e) {
        }
      };
      for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
        var name_1 = names_1[_i];
        var state_1 = _loop_1(name_1);
        if (typeof state_1 === "object")
          return state_1.value;
      }
      return null;
    };
  }();
  var migrationMaps = {
    PA: {
      browserId: ["pa_vid", "atuserid"]
    }
  };
  var migrate = function(_private) {
    var _a;
    var migrationData = __assign2({}, validateMigration((_a = getGlobalConfig$1()) === null || _a === void 0 ? void 0 : _a.migration));
    keys(migrationData).forEach(function(propName) {
      var _a2, _b;
      var param2 = _private.params.get(propName);
      var product = (_a2 = migrationData[propName]) === null || _a2 === void 0 ? void 0 : _a2.source;
      var configs = product && ((_b = migrationMaps[product]) === null || _b === void 0 ? void 0 : _b[propName]) || [];
      if (param2 && configs.length) {
        var fromGlobalConfig = getGlobalConfig$1()[propName];
        var migrationValue = getMigrationValue(configs);
        if (migrationValue && !fromGlobalConfig) {
          param2.readonly = false;
          _private.updateValues(propName, migrationValue, true);
          param2.readonly = true;
        }
      }
    });
  };
  var PREFIX = "@@Data-layer/";
  var UPDATE_VALUE = PREFIX + "update_value";
  var REFRESH_VALUE = PREFIX + "refresh_value";
  var REFRESH_LOCKED_KEY = PREFIX + "refresh_locked_key";
  var getGlobalConfig = function() {
    var config = __assign2({}, window[GLOBAL_CONFIG_NAME]);
    var validateCookieOption = function(cookieOptions) {
      return validateObj(cookieOptions, {
        path: String,
        domain: String,
        secure: toBoolean,
        expires: function(val) {
          return val instanceof Date ? val : Number(val);
        },
        samesite: function(val) {
          if (isString(val)) {
            return val;
          }
          return toBoolean(val);
        }
      });
    };
    if (config === null || config === void 0 ? void 0 : config.cookies) {
      config.cookies = keys(config.cookies).reduce(function(res, cookieName) {
        res[cookieName] = validateCookieOption(config.cookies[cookieName]);
        return res;
      }, {});
    }
    if (config === null || config === void 0 ? void 0 : config.cookieDefault) {
      config.cookieDefault = validateCookieOption(config.cookieDefault);
    }
    return config;
  };
  var DataLayer = function(paramsArgs, cookiesArgs, onInit) {
    var cookieConfig = combineCookieConfig(paramsArgs, cookiesArgs);
    var syncConnection = connect("data-layer", cookieConfig);
    var cachedValue;
    var ready = false;
    var listenersByNames = /* @__PURE__ */ new Map();
    var listenersCommon = /* @__PURE__ */ new Set();
    var params = /* @__PURE__ */ new Map();
    var getConnection2 = function() {
      if (!syncConnection) {
        throw new Error("DataLayer can't be connected");
      }
      return syncConnection;
    };
    var getCookieWrappers = function(cb) {
      var cookieWrappers2 = getConnection2().registeredCookiesWrapper;
      if (cookieWrappers2) {
        cb(cookieWrappers2);
      }
    };
    var setCookieEnabled = function(cookiesEnabled) {
      getCookieWrappers(function(cookieWrappers2) {
        var cookieNames = keys(cookiesEnabled);
        if (cookieNames.length) {
          cookieNames.forEach(function(cookieName) {
            var wrapper = cookieWrappers2[cookieName];
            if (wrapper) {
              wrapper.setCookieEnabled(cookiesEnabled[cookieName]);
            }
          });
        } else {
          keys(cookieWrappers2).forEach(function(key2) {
            cookieWrappers2[key2].setCookieEnabled(cookiesEnabled);
          });
        }
      });
    };
    var resolveCookieLazyAction = function(cookieNames) {
      getCookieWrappers(function(cookieWrappers2) {
        cookieNames.forEach(function(cookieName) {
          var wrapper = cookieWrappers2[cookieName];
          if (wrapper) {
            wrapper.lazyActive();
          }
        });
      });
    };
    var getCookieConfig = function() {
      var result = null;
      getCookieWrappers(function(cookieWrappers2) {
        result = keys(cookieWrappers2).reduce(function(res, key2) {
          var enabled = cookieWrappers2[key2].cookieEnabled;
          var fixedAt = cookieWrappers2[key2].fixedAt || null;
          var cookieName = cookieWrappers2[key2].cookieName;
          res[cookieName] = enabled ? {
            enabled,
            fixedAt
          } : null;
          return res;
        }, {});
      });
      return result;
    };
    var initConfig = function(config) {
      var globalConfig = __assign2(__assign2({}, config), getGlobalConfig());
      var cookieOptions = globalConfig.cookieDefault;
      getCookieWrappers(function(cookieWrappers2) {
        keys(cookieWrappers2).forEach(function(key2) {
          var _a, _b, _c, _d;
          var cookieName = cookieWrappers2[key2].cookieName;
          var options = (_a = globalConfig.cookies) === null || _a === void 0 ? void 0 : _a[cookieName];
          var fixedMode = ((_b = globalConfig.cookies) === null || _b === void 0 ? void 0 : _b.storageMode) === "fixed";
          (_d = (_c = cookieWrappers2[key2]).setFixedMode) === null || _d === void 0 ? void 0 : _d.call(_c, fixedMode);
          if (cookieOptions || options) {
            cookieWrappers2[key2].setCookieOptions(__assign2(__assign2({}, cookieOptions), options));
          }
        });
      });
    };
    var createConfigParameters = function() {
      var configs = {};
      var getValuesByPropName = function(propName) {
        return keys(configs).reduce(function(res, key2) {
          var config = configs[key2];
          if (config[propName] !== void 0) {
            res[key2] = config[propName];
          }
          return res;
        }, {});
      };
      var updateProtection = function() {
        var values = getValuesByPropName("protect");
        if (keys(values).length > 0) {
          getConnection2().setProtectionData(values);
        }
      };
      var updateProtectionUnsafe = function() {
        var values = getValuesByPropName("protectUnsafe");
        if (keys(values).length > 0) {
          getConnection2().setProtectionDataUnsafe(values);
        }
      };
      return {
        add: function(key2, config) {
          configs[key2] = config;
        },
        call: function() {
          updateProtection();
          updateProtectionUnsafe();
        }
      };
    };
    var normalizeCachedValue = function(cachedValues, cb) {
      return keys(cachedValues).reduce(function(result, paramName) {
        var param2 = params.get(paramName);
        var value = cachedValues[paramName];
        if (param2) {
          result[paramName] = cb ? cb(param2, value) : param2.get(value);
        }
        return result;
      }, {});
    };
    var _getPrivateContext = function() {
      return {
        params,
        getConnection: getConnection2,
        addChangeListener,
        get,
        updateValues
      };
    };
    var init = function(options) {
      if (options === void 0) {
        options = {};
      }
      if (ready) {
        return;
      }
      if (!syncConnection) {
        syncConnection = connect("data-layer", cookieConfig);
      }
      initConfig(options);
      ready = true;
      keys(paramsArgs).forEach(function(key2) {
        var param2 = paramsArgs[key2];
        listenersByNames.set(key2, /* @__PURE__ */ new Set());
        params.set(key2, param2);
      });
      var needToUpdateCookie = false;
      var initCookieData = getConnection2().getInitCookieData();
      var cachedData = getConnection2().getCachedData();
      var configToChange = createConfigParameters();
      var initData = keys(paramsArgs).reduce(function(res, key2) {
        var _key = key2;
        var param2 = paramsArgs[key2];
        res[key2] = (cachedData === null || cachedData === void 0 ? void 0 : cachedData[_key]) || param2.init(initCookieData === null || initCookieData === void 0 ? void 0 : initCookieData[_key], function(config) {
          configToChange.add(_key, config);
        });
        if (!(cachedData === null || cachedData === void 0 ? void 0 : cachedData[_key])) {
          needToUpdateCookie = true;
        }
        return res;
      }, {});
      cachedValue = initData;
      if (needToUpdateCookie) {
        getConnection2().updateData(initData);
      }
      configToChange.call();
      getConnection2().onUpdateData(function(data) {
        return onUpdateData(data);
      });
      onInit === null || onInit === void 0 ? void 0 : onInit(_getPrivateContext());
    };
    var onUpdateData = function(data) {
      var cachedValueWasUpdated = false;
      keys(data).forEach(function(key2) {
        var _a;
        var _key = key2;
        var param2 = params.get(_key);
        if (param2) {
          var value_1 = data[_key];
          var prevValue = cachedValue[_key];
          if (prevValue !== value_1) {
            cachedValue[_key] = value_1;
            cachedValueWasUpdated = true;
            (_a = listenersByNames.get(_key)) === null || _a === void 0 ? void 0 : _a.forEach(function(cb) {
              return cb(param2.get(value_1));
            });
          }
        }
      });
      if (cachedValueWasUpdated) {
        listenersCommon.forEach(function(cb) {
          return cb(normalizeCachedValue(cachedValue));
        });
      }
    };
    var updateValues = function(arg1, arg2, force) {
      var _a;
      if (force === void 0) {
        force = false;
      }
      var data = arg1;
      var cookiesActions = stringSet();
      if (isString(arg1)) {
        data = (_a = {}, _a[arg1] = arg2, _a);
      }
      var configsToResetProtection = createConfigParameters();
      var configsToChange = createConfigParameters();
      data = keys(data).reduce(function(res, key2) {
        var value = data[key2];
        var param2 = params.get(key2);
        var keyString = key2;
        if (param2 === null || param2 === void 0 ? void 0 : param2.readonly) {
          return res;
        }
        if (param2 && param2.cookieName) {
          cookiesActions.add(param2.cookieName);
        }
        if (!param2 || value === cachedValue[key2]) {
          return res;
        }
        if (value === REFRESH_VALUE) {
          res[key2] = param2.refresh(cachedValue[key2], function(config) {
            configsToChange.add(keyString, config);
          });
          if (res[key2] !== cachedValue[key2]) {
            configsToResetProtection.add(keyString, { protectUnsafe: false });
          }
          return res;
        }
        if (value === UPDATE_VALUE) {
          res[key2] = param2.update(cachedValue[key2], function(config) {
            configsToChange.add(keyString, config);
          });
          return res;
        }
        res[key2] = param2.set(value, cachedValue[key2], function(config) {
          configsToChange.add(keyString, config);
        });
        return res;
      }, {});
      resolveCookieLazyAction(cookiesActions.values());
      configsToResetProtection.call();
      var rejectedData = getConnection2().updateData(data);
      if (rejectedData && force) {
        var unprotectKeys = keys(rejectedData).reduce(function(res, key2) {
          var _a2;
          return __assign2(__assign2({}, res), (_a2 = {}, _a2[key2] = false, _a2));
        }, {});
        getConnection2().setProtectionDataUnsafe(unprotectKeys);
        getConnection2().updateData(data);
      }
      configsToChange.call();
      return rejectedData && normalizeCachedValue(rejectedData);
    };
    function get(arg1) {
      var _a;
      var cookiesActions = stringSet();
      var isSingleValue = isString(arg1);
      var result;
      if (arg1 === void 0) {
        result = cachedValue;
      } else if (isSingleValue) {
        result = (_a = {}, _a[arg1] = cachedValue[arg1], _a);
      } else {
        result = arg1.reduce(function(res, key2) {
          if (params.has(key2)) {
            res[key2] = cachedValue[key2];
          }
          return res;
        }, {});
      }
      result = normalizeCachedValue(result, function(param2, value) {
        if (param2.cookieName) {
          cookiesActions.add(param2.cookieName);
        }
        return param2.get(value);
      });
      resolveCookieLazyAction(cookiesActions.values());
      return isSingleValue ? result[arg1] : result;
    }
    function set(arg1, arg2) {
      return updateValues(arg1, arg2, false);
    }
    function setUnsafe(arg1, arg2) {
      updateValues(arg1, arg2, true);
    }
    var updateSafeUnsafe = function(arg1, unsafe) {
      if (unsafe === void 0) {
        unsafe = false;
      }
      var names = arg1;
      if (!isArray(arg1)) {
        names = [arg1];
      }
      return updateValues(names.reduce(function(res, name3) {
        res[name3] = UPDATE_VALUE;
        return res;
      }, {}), void 0, unsafe);
    };
    var update = function(arg1) {
      return updateSafeUnsafe(arg1);
    };
    var updateUnsafe = function(arg1) {
      return updateSafeUnsafe(arg1, true);
    };
    var protectPrivate = function(arg1, arg2, force) {
      var _a;
      if (force === void 0) {
        force = false;
      }
      var protectMethod = force ? getConnection2().setProtectionDataUnsafe : getConnection2().setProtectionData;
      var values = arg1;
      if (isString(arg1)) {
        values = (_a = {}, _a[arg1] = arg2, _a);
      }
      return protectMethod(values);
    };
    function protect(arg1, arg2) {
      return protectPrivate(arg1, arg2);
    }
    function protectUnsafe(arg1, arg2) {
      return protectPrivate(arg1, arg2, true);
    }
    function addChangeListener(arg1, arg2) {
      var _a;
      if (isString(arg1)) {
        (_a = listenersByNames.get(arg1)) === null || _a === void 0 ? void 0 : _a.add(arg2);
        return;
      }
      listenersCommon.add(arg1);
    }
    var removeChangeListener = function(cb) {
      listenersCommon.delete(cb);
      listenersByNames.forEach(function(listeners) {
        return listeners.delete(cb);
      });
    };
    var refresh = function() {
      var _a;
      if (getConnection2().setProtectionData((_a = {}, _a[REFRESH_LOCKED_KEY] = true, _a))) {
        return false;
      }
      var paramKeys = [];
      params.forEach(function(_v, key2) {
        return paramKeys.push(key2);
      });
      var refreshData = paramKeys.reduce(function(res, key2) {
        res[key2] = REFRESH_VALUE;
        return res;
      }, {});
      updateValues(refreshData);
      return true;
    };
    var terminate = function() {
      syncConnection === null || syncConnection === void 0 ? void 0 : syncConnection.terminate();
      listenersByNames.clear();
      listenersCommon.clear();
      syncConnection = null;
      ready = false;
      cachedValue = {};
    };
    var updateMigration = function() {
      if (ready) {
        migrate(_getPrivateContext());
      }
    };
    function setConsent(arg1, arg2, arg3) {
      var consent4 = get("consent");
      var purposes2 = get("purposes");
      var result = setExtendedConsent(purposes2, consent4, arg1, arg2, arg3);
      if (!result) {
        return null;
      }
      if (result.error) {
        return result.error;
      }
      set({
        consent: result.consent,
        purposes: result.purposes
      });
      return null;
    }
    var getConsent = function() {
      var _a = get(["consent", "purposes"]), consent4 = _a.consent, purposes2 = _a.purposes;
      return getExtendedConsent(consent4, purposes2);
    };
    return {
      init,
      set,
      get,
      update,
      refresh,
      protect,
      addChangeListener,
      removeChangeListener,
      terminate,
      updateMigration,
      get isReady() {
        return ready;
      },
      utils: {
        validateModifier,
        validateConsent: validateConsent$1,
        checkConsent: checkConsent$1,
        setConsent,
        getConsent,
        notAcquiredConsent: getNotAcquiredConsent(),
        compressLz: compressToEncodedURIComponent,
        decompressLz: decompressFromEncodedURIComponent
      },
      get cookies() {
        return getCookieConfig();
      },
      get cookieEnabled() {
        return getCookieConfig();
      },
      setUnsafe,
      protectUnsafe,
      updateUnsafe,
      setCookieEnabled
    };
  };
  var isPAConsentOnly = function(con) {
    var _a, _b;
    var conf = getGlobalConfig$1();
    var products2 = ((_a = conf.consent) === null || _a === void 0 ? void 0 : _a.products) || [];
    var paOnly = products2.length === 1 && products2[0] === "PA";
    var isOptOut = ((_b = con === null || con === void 0 ? void 0 : con.PA) === null || _b === void 0 ? void 0 : _b.mode) === "opt-out";
    return !!conf.requireConsent && paOnly && isOptOut;
  };
  var getCookieProhibition = function(con) {
    var prohibitForPaProducts = isPAConsentOnly(con);
    return {
      _pprv: !getGlobalConfig$1().requireConsent,
      _pctx: prohibitForPaProducts,
      _pcid: prohibitForPaProducts,
      _pcus: prohibitForPaProducts
    };
  };
  var checkConsent = function(_private) {
    var _a;
    var items = keys(cookieEncoders).reduce(function(res, cookieName) {
      res[cookieName] = cookieEncoders[cookieName].consent;
      return res;
    }, {});
    var getConsent = function(data) {
      var _a2;
      return data || ((_a2 = _private.get("consent")) === null || _a2 === void 0 ? void 0 : _a2.DL) || null;
    };
    var check = createCheckConsentWrapper({
      items,
      type: "cookie",
      getConsent
    });
    var prevValueDlConsent = getConsent();
    var prevValuePAConsent = ((_a = _private.get("consent")) === null || _a === void 0 ? void 0 : _a.PA) || null;
    var checkCookieWrappers = function(con, allConsents) {
      var _a2;
      var prohibition = getCookieProhibition(allConsents);
      var cookieWrapperMap = (_a2 = _private.getConnection()) === null || _a2 === void 0 ? void 0 : _a2.registeredCookiesWrapper;
      if (cookieWrapperMap) {
        var names = keys(cookieWrapperMap).map(function(key2) {
          return cookieWrapperMap[key2].cookieName;
        });
        check(names, con).forEach(function(_a3) {
          var name3 = _a3.name, allowed = _a3.allowed, data = _a3.data;
          var cookieName = name3;
          var cookieAllowed = allowed && !prohibition[cookieName];
          cookieWrapperMap[cookieName].setCookieEnabled(cookieAllowed, data || null);
        });
      }
    };
    _private.addChangeListener("consent", function(data) {
      var newDLValue = (data === null || data === void 0 ? void 0 : data.DL) || null;
      var newPAValue = (data === null || data === void 0 ? void 0 : data.PA) || null;
      if ((prevValueDlConsent === null || prevValueDlConsent === void 0 ? void 0 : prevValueDlConsent.mode) !== (newDLValue === null || newDLValue === void 0 ? void 0 : newDLValue.mode) || (prevValuePAConsent === null || prevValuePAConsent === void 0 ? void 0 : prevValuePAConsent.mode) !== (newPAValue === null || newPAValue === void 0 ? void 0 : newPAValue.mode)) {
        prevValueDlConsent = newDLValue;
        prevValuePAConsent = newPAValue;
        checkCookieWrappers(newDLValue, data);
      }
    });
    checkCookieWrappers(prevValueDlConsent, _private.get("consent"));
  };
  var log = function(product, mode, type2) {
    var prefix = type2 === 1 ? "can not be" : "was";
    console.warn('[DL]: Consent v2: the "'.concat(product, '" has a conflicted consent mode, ') + "mode ".concat(prefix, ' changed to "').concat(mode, '"'));
  };
  var validateConsent = function(_private) {
    var timer = null;
    var customInvalidProducts = {};
    var validate = function(consent4) {
      var currentConsent = getExtendedConsent(consent4, _private.get("purposes"));
      if (currentConsent && consent4) {
        var needUpdate_1 = false;
        var newConsent = keys(currentConsent).reduce(function(res, key2) {
          var newMode = currentConsent[key2].mode;
          currentConsent[key2].products.forEach(function(productName) {
            var _a;
            if (newMode !== ((_a = consent4[productName]) === null || _a === void 0 ? void 0 : _a.mode)) {
              if (isInvalidCustomMode(newMode, productName)) {
                if (!customInvalidProducts[productName]) {
                  customInvalidProducts[productName] = true;
                  log(productName, newMode, 1);
                }
              } else {
                res[productName] = { mode: newMode };
                needUpdate_1 = true;
                log(productName, newMode, 2);
              }
            }
          });
          return res;
        }, {});
        if (needUpdate_1) {
          _private.updateValues({ consent: newConsent });
        }
      }
    };
    _private.addChangeListener("consent", function(consent4) {
      if (isRequireConsentV2()) {
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        timer = setTimeout(function() {
          validate(consent4);
          timer = null;
        }, 200);
      }
    });
    if (isRequireConsentV2()) {
      validate(_private.get("consent"));
    }
  };
  var onDataLayerInit = function(_private) {
    checkConsent(_private);
    migrate(_private);
    validateConsent(_private);
  };
  var dataLayer = DataLayer(PropertiesMap, cookieWrappers, onDataLayerInit);

  // ../../../node_modules/@piano-sdk/consent/dist/index.js
  var createConsentWrapper = function createConsentWrapper2(config) {
    return function() {
      var consent22 = config.dataLayer.get("consent");
      return consent22 && consent22[config.productName] || null;
    };
  };
  var onDlChangeConsent = function onDlChangeConsent2(config, cb) {
    var prevValue = null;
    var _onChangeHandler = function _onChangeHandler2(data) {
      var consent22 = (data === null || data === void 0 ? void 0 : data[config.productName]) || null;
      if (consent22 !== prevValue) {
        prevValue = consent22;
        cb(consent22);
      }
    };
    config.dataLayer.addChangeListener("consent", _onChangeHandler);
    return function() {
      config.dataLayer.removeChangeListener(_onChangeHandler);
    };
  };
  var createCheckConsentWrapper2 = function createCheckConsentWrapper3(dataLayer2, config) {
    return dataLayer2.utils.checkConsent.createCheckConsentWrapper(config);
  };
  var itemsToNames = function itemsToNames2(dataLayer2, items, getNames) {
    var utils = dataLayer2.utils.checkConsent;
    var masks = utils.itemsToMask(items);
    var keys2 = Object.keys(items).filter(function(key2) {
      return !utils.isMask(key2);
    });
    return getNames().filter(function(name3) {
      return keys2.includes(name3) || utils.getByMask(name3, masks);
    });
  };
  var createBaseConsentStorage = function createBaseConsentStorage2(storage2, itemType, config) {
    var getConsent = createConsentWrapper(config);
    var checkProperty = createCheckConsentWrapper2(config.dataLayer, {
      items: config.items,
      type: itemType,
      getConsent,
      product: config.productName
    });
    var _init = function _init2() {
      var removeOnInit = config.checkConsentOnInit === void 0 ? config.enableAutoRemove : false;
      if (config.enableAutoRemove) {
        onDlChangeConsent(config, onChangeConsentMode);
      }
      if (removeOnInit) {
        onChangeConsentMode(getConsent());
      }
    };
    var onChangeConsentMode = function onChangeConsentMode2(consent22) {
      var _a;
      (_a = checkProperty(itemsToNames(config.dataLayer, config.items, storage2.getNames), consent22)) === null || _a === void 0 ? void 0 : _a.forEach(function(item) {
        if (!item.allowed) {
          storage2.remove(item.name);
        } else if (item.data) {
          storage2.set(item.name, item.data);
        }
      });
    };
    var set = function set2(name3, value, options) {
      var _a;
      var consent22 = checkProperty(name3);
      if (consent22 === null || consent22 === void 0 ? void 0 : consent22.allowed) {
        var newValue = (_a = consent22.data) !== null && _a !== void 0 ? _a : value;
        var args = options ? [name3, newValue, options] : [name3, newValue];
        storage2.set.apply(null, args);
      }
    };
    _init();
    return Object.assign({}, storage2, {
      set,
      check: checkProperty
    });
  };
  var createTTLChecker = function createTTLChecker2(dataLayer2) {
    var name3 = localStorage2.__protected__.ttlName;
    var config = {
      dataLayer: dataLayer2,
      productName: "DL"
    };
    var check = function() {
      var _a;
      var checker = createCheckConsentWrapper2(config.dataLayer, {
        items: (_a = {}, _a[name3] = "mandatory", _a),
        type: "localStorage",
        getConsent: createConsentWrapper(config),
        product: config.productName
      });
      return function() {
        var result = checker(name3);
        return result.allowed && !result.data;
      };
    }();
    var allowed = true;
    var updateMemoValue = function updateMemoValue2() {
      allowed = check();
      if (!allowed) {
        localStorage2.remove(name3);
      }
    };
    onDlChangeConsent(config, updateMemoValue);
    updateMemoValue();
    return function() {
      return allowed;
    };
  };
  var createLocalStorage = function createLocalStorage2(config) {
    var checkTTL = createTTLChecker(config.dataLayer);
    var lsConsent = createBaseConsentStorage(localStorage2, "localStorage", config);
    var set = function set2(name3, value, options) {
      var newOptions = options;
      if ((options === null || options === void 0 ? void 0 : options.expires) && !checkTTL()) {
        newOptions = Object.assign({}, options);
        delete newOptions.expires;
      }
      return lsConsent.set(name3, value, newOptions);
    };
    return Object.assign({}, lsConsent, {
      set
    });
  };
  var ITEM_TYPE = "cookie";
  var createCookie = function createCookie2(config) {
    var consentUtils = config.dataLayer.utils.checkConsent;
    var getConsent = createConsentWrapper(config);
    var cookieOptionsByCookie = {};
    var cookieOptionsByMasks = [];
    var items = {};
    var cookieOptions = {};
    (function() {
      Object.keys(config.items).forEach(function(itemName) {
        var option = config.items[itemName];
        if (option.type) {
          var _a = option, type2 = _a.type, domain = _a.domain, path = _a.path;
          var options = {};
          items[itemName] = type2;
          if (domain) {
            options.domain = domain;
          }
          if (path) {
            options.path = path;
          }
          if (consentUtils.isMask(itemName)) {
            cookieOptionsByMasks.push(consentUtils.createMask(itemName, options));
          } else {
            cookieOptionsByCookie[itemName] = options;
          }
        } else {
          items[itemName] = option;
        }
      });
    })();
    var checkProperty = createCheckConsentWrapper2(config.dataLayer, {
      items,
      type: ITEM_TYPE,
      getConsent,
      product: config.productName
    });
    var _init = function _init2() {
      var removeOnInit = !!(config.checkConsentOnInit === void 0 ? config.enableAutoRemove : false);
      if (config.enableAutoRemove) {
        cookieOptions = config.enableAutoRemove;
        onDlChangeConsent(config, onChangeConsentMode);
      }
      if (removeOnInit) {
        onChangeConsentMode(getConsent());
      }
    };
    var onChangeConsentMode = function onChangeConsentMode2(consent22) {
      var _a;
      (_a = checkProperty(itemsToNames(config.dataLayer, items, cookie.getNames), consent22)) === null || _a === void 0 ? void 0 : _a.forEach(function(item) {
        var getOptions = function getOptions2() {
          return cookieOptionsByCookie[item.name] || consentUtils.getByMask(item.name, cookieOptionsByMasks) || cookieOptions;
        };
        if (!item.allowed) {
          cookie.remove(item.name, getOptions());
        } else if (item.data) {
          cookie.set(item.name, item.data, getOptions());
        }
      });
    };
    _init();
    var set = function set2(name3, value, options, limitValue) {
      var _a;
      var consent22 = checkProperty(name3);
      if (consent22 === null || consent22 === void 0 ? void 0 : consent22.allowed) {
        cookie.set(name3, (_a = consent22.data) !== null && _a !== void 0 ? _a : value, options, limitValue);
      }
    };
    return Object.assign({}, cookie, {
      check: checkProperty,
      set
    });
  };
  var createSessionStorage = function createSessionStorage2(config) {
    return createBaseConsentStorage(sessionStorage, "sessionStorage", config);
  };
  var createBasePropertyWrapper = function createBasePropertyWrapper2(itemType, config) {
    return {
      check: createCheckConsentWrapper2(config.dataLayer, {
        items: config.items,
        type: itemType,
        getConsent: createConsentWrapper(config),
        product: config.productName
      })
    };
  };
  var createProperty = function createProperty2(config) {
    return createBasePropertyWrapper("property", config);
  };
  var createEvent = function createEvent2(config) {
    return createBasePropertyWrapper("event", config);
  };
  var consent2 = {
    createLocalStorage,
    createProperty,
    createCookie,
    createSessionStorage,
    createEvent
  };

  // ../src/lib/deprecated.ts
  var deprecatedMethods = (obj, prefix = "") => {
    function deprecated(fn, methodName = "Method") {
      const resultFn = function() {
        var _a;
        (_a = pn == null ? void 0 : pn.util) == null ? void 0 : _a.debug(`${methodName} is deprecated`);
        return fn.apply(this, arguments);
      };
      resultFn.skipLog = fn;
      return resultFn;
    }
    return Object.entries(obj).reduce((res, [key2, fn]) => {
      res[key2] = deprecated(fn, prefix + String(key2));
      return res;
    }, {});
  };

  // ../src/lib/consent.ts
  var isIpAddress = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(location.hostname);
  var tld = dist_exports.cookie.getTopLevelDomain();
  var CONSENT_CONFIG = {
    COMPOSER: {
      cookie: {
        items: {
          "__tbc": "mandatory",
          "xbc": "mandatory",
          "__tac": "mandatory",
          "__tae": "mandatory",
          "__pls": { type: "mandatory", domain: tld, path: "/" },
          "__pls_*": { type: "mandatory", domain: tld, path: "/" },
          "_pc_*": { type: "mandatory", domain: "", path: "/" },
          "_pcfe": "optional",
          "_pcus": "optional",
          "_pcer": { type: "essential", domain: tld, path: "/" },
          "_pnpd": "optional"
        }
      },
      localStorage: {
        items: {
          "__pnml": "mandatory",
          "__tp-customVariables": "essential",
          "__tp-customVariables-expiration": "essential"
        },
        enableAutoRemove: true
      }
    },
    VX: {
      cookie: {
        items: {
          "__ut_*": "mandatory",
          "__ut": "mandatory",
          "__pvi": "optional",
          "__pat": "optional",
          "__pnahc": "mandatory",
          "glt_*": "optional",
          "__utg_*": "optional",
          "__gom": "optional",
          "tpcc_*": { type: "optional", domain: isIpAddress ? "" : tld, path: "/" }
        }
      },
      localStorage: {
        items: {
          "__tp-gaAccount": "optional",
          "__tp-trackOnlyAids": "optional",
          "__tp-metricsGAAccount": "optional",
          "__tp-exrs": "optional",
          "tp__unprocessedCookies": "optional",
          "tp__unprocessed\u0421ookies": "optional",
          "__tp-gaAccount-expiration": "optional",
          "__tp-trackOnlyAids-expiration": "optional",
          "__tp-metricsGAAccount-expiration": "optional",
          "__tp-exrs-expiration": "optional"
        },
        enableAutoRemove: true
      }
    },
    DMP: {
      cookie: {
        items: {
          "cX_P": "essential"
        },
        enableAutoRemove: {
          domain: tld,
          path: "/"
        }
      },
      localStorage: {
        items: {
          "_cX_P": "essential"
        },
        enableAutoRemove: true
      }
    },
    ID: {
      cookie: {
        items: {
          "__utp": "mandatory",
          "__utp_*": "mandatory",
          "__pid": "mandatory",
          "__pil": "essential",
          "__idr": "essential",
          "__eea": "essential",
          "piano-id-initial-gm-sso-shown-*": "mandatory"
        }
      },
      localStorage: {
        items: {
          "pnid-tc-string": "optional"
        },
        enableAutoRemove: true
      }
    }
  };
  var CUSTOM_MODE2 = "custom";
  var consentModes = ["opt-in", "essential", "opt-out", CUSTOM_MODE2];
  var consentProducts = ["PA", "DMP", "COMPOSER", "ID", "VX", "ESP", "SOCIAL_FLOW", "DL"];
  var consentProductMap = consentProducts.reduce((res, val, index) => __spreadProps(__spreadValues({}, res), {
    [val.toLowerCase()]: {
      name: val,
      id: index
    }
  }), {});
  consentProductMap["social flow"] = consentProductMap.SOCIAL_FLOW;
  var getConsentModeId = (mode) => consentModes.indexOf(mode);
  var toProduct2 = (product) => consentProductMap[product.toLowerCase()] || null;
  var notAcquiredMode = 4;
  var getPdl = () => window.pdl || null;
  var getConsentModifiers = () => {
    var _a;
    return ((_a = getPdl()) == null ? void 0 : _a.consent_modifiers) || null;
  };
  var isConsentEnabled = () => {
    var _a;
    return !!((_a = getPdl()) == null ? void 0 : _a.requireConsent);
  };
  var isConsentV2Enabled = () => {
    var _a;
    return ((_a = getPdl()) == null ? void 0 : _a.requireConsent) === "v2";
  };
  var isConsentV1Enabled = () => isConsentEnabled() && !isConsentV2Enabled();
  var getVersionConsent = () => isConsentEnabled() ? isConsentV2Enabled() ? 2 : 1 : null;
  var checkConsentV2 = () => {
    if (isConsentV1Enabled()) {
      console.error('Consent v2 is disabled. To use the feature set pdl.requireConsent = "v2"');
      return false;
    }
    return true;
  };
  var checkConsentV1 = () => {
    if (isConsentV2Enabled()) {
      console.error("Consent v2 is enabled. To change consent use tp.consent.setByPurpose or tp.consent.setAllPurposes");
      return false;
    }
    return true;
  };
  var defaultPurposeByProduct = Object.entries({
    AD: ["DMP", "SOCIAL_FLOW"],
    CP: ["COMPOSER"],
    AM: ["PA"],
    PR: ["ESP", "VX", "ID"],
    DL: ["DL"]
  }).reduce((res, [purpose, products2]) => {
    products2.forEach((product) => {
      res[toProduct2(product).id] = purpose;
    });
    return res;
  }, {});
  var createConsentParameters = (allProducts) => {
    let modes = allProducts.reduce((res, { id }) => __spreadProps(__spreadValues({}, res), {
      [id]: notAcquiredMode
    }), {});
    let purposes2 = dataLayer.get("purposes") || {};
    return {
      addConsent: (productName, mode) => {
        const productId = toProduct2(productName).id;
        modes[productId] = getConsentModeId(mode);
      },
      addPurpose: (productName, purpose) => {
        purposes2[toProduct2(productName).id] = purpose;
      },
      toModeParamString: () => {
        return JSON.stringify(modes);
      },
      toPurposeParamString: () => {
        return Object.entries(purposes2).some(([id, purpose]) => purpose !== defaultPurposeByProduct[id]) ? JSON.stringify(purposes2) : null;
      }
    };
  };
  var consent3 = () => {
    let ready = false;
    let callQueue = [];
    const products2 = {
      composer: null,
      vx: null,
      dmp: null,
      id: null
    };
    const setByPreset = (presets) => {
      if (checkConsentV1()) {
        dataLayer.set("consent", presets);
      }
    };
    function set(arg1, arg2) {
      if (checkConsentV1()) {
        if (typeof arg1 === "string") {
          dataLayer.set("consent", { [arg1]: arg2 });
        } else {
          dataLayer.set("consent", arg1);
        }
      }
    }
    function get(product) {
      const extendedConsent = dataLayer.get("consent");
      if (!product || !extendedConsent) {
        return extendedConsent;
      }
      return extendedConsent[product];
    }
    function setByPurpose(purpose, mode, products3) {
      if (!checkConsentV2()) {
        return;
      }
      if (!mode) {
        pn.util.error("consent.setByPurpose: mode is required");
        return;
      }
      const result = dataLayer.utils.setConsent(purpose, mode, products3);
      if (result) {
        pn.util.error("consent.setByPurpose: [DL]: " + result);
      }
    }
    function setAllPurposes(mode) {
      if (!checkConsentV2()) {
        return;
      }
      const result = dataLayer.utils.setConsent(mode);
      if (result) {
        pn.util.error("consent.setAllPurpose: [DL]: " + result);
      }
    }
    function getByPurpose() {
      return dataLayer.utils.getConsent();
    }
    const addConsentsToParams = (params) => {
      var _a;
      const products3 = dataLayer.get("products");
      const consentExtended = getVersionConsent() === 2 ? dataLayer.utils.getConsent() : null;
      const consentV1 = getVersionConsent() === 1 ? dataLayer.get("consent") : null;
      const consentRequire = !!((_a = getPdl()) == null ? void 0 : _a.requireConsent);
      if ((!consentExtended || !consentV1) && !consentRequire) {
        return params;
      }
      const consentParameters = createConsentParameters(products3);
      if (consentV1) {
        Object.keys(consentV1).forEach((product) => {
          consentParameters.addConsent(product, consentV1[product].mode);
        });
      }
      if (consentExtended) {
        Object.keys(consentExtended).forEach((purpose) => {
          const { mode, products: products4 } = consentExtended[purpose];
          products4.forEach((product) => {
            consentParameters.addConsent(product, mode);
            consentParameters.addPurpose(product, purpose);
          });
        });
      }
      const consentModesParam = consentParameters.toModeParamString();
      const consentPurposesParam = consentParameters.toPurposeParamString();
      if (consentModesParam) {
        params["consent_modes"] = consentModesParam;
      }
      if (consentPurposesParam) {
        params["consent_purposes"] = consentPurposesParam;
      }
      return params;
    };
    const _callAsyncFn = (cb) => {
      cb(products2);
    };
    const init = () => {
      var _a;
      const createLog = (product) => pn.debug ? (value) => {
        var _a2;
        (_a2 = pn.util) == null ? void 0 : _a2.debug(`[PDL validation]: consent_modifier: ${product} - ${value}`);
      } : void 0;
      const consentLog = pn.debug ? (value) => {
        var _a2;
        (_a2 = pn.util) == null ? void 0 : _a2.debug("[PDL validation]: " + value);
      } : void 0;
      const pdl = getPdl();
      const modifiers = getConsentModifiers();
      if (modifiers) {
        Object.keys(modifiers).forEach((key2) => {
          var _a2;
          const modifier = modifiers[key2];
          const productName = (_a2 = toProduct2(key2)) == null ? void 0 : _a2.name;
          if (productName) {
            delete modifiers[key2];
            modifiers[productName] = modifier;
          }
        });
        (_a = dataLayer.get("products")) == null ? void 0 : _a.forEach(({ name: productName }) => {
          if (modifiers[productName]) {
            const log3 = createLog(productName);
            modifiers[productName] = dataLayer.utils.validateModifier(modifiers[productName], log3);
          }
        });
      }
      if (pdl == null ? void 0 : pdl.consent) {
        pdl.consent = dataLayer.utils.validateConsent(pdl.consent, consentLog) || pdl.consent;
      }
      const autoRemoveCookieOptions = {
        domain: pn.cookieDomain || dist_exports.cookie.getTopLevelDomain(),
        path: pn.cookiePath || "/"
      };
      Object.entries(CONSENT_CONFIG).forEach(([key2, config]) => {
        var _a2;
        const productName = key2;
        const productNameLS = productName.toLowerCase();
        const commonConfig = {
          dataLayer,
          productName
        };
        products2[productNameLS] = {
          cookie: consent2.createCookie(__spreadProps(__spreadValues(__spreadValues({}, commonConfig), config.cookie), {
            enableAutoRemove: (_a2 = config.cookie.enableAutoRemove) != null ? _a2 : autoRemoveCookieOptions
          })),
          localStorage: consent2.createLocalStorage(__spreadValues(__spreadValues({}, commonConfig), config.localStorage))
        };
      });
      callQueue.forEach(_callAsyncFn);
      callQueue = [];
      ready = true;
    };
    const getConsentConfig = () => pn.debug ? CONSENT_CONFIG : null;
    const async = (cb) => {
      if (ready) {
        _callAsyncFn(cb);
      } else {
        callQueue.push(cb);
      }
    };
    const deprecatedMethod = deprecatedMethods({
      setByPreset,
      set,
      get
    }, "tp.consent.");
    return {
      setByPreset: deprecatedMethod.setByPreset,
      set: deprecatedMethod.set,
      get: deprecatedMethod.get,
      setByPurpose,
      setAllPurposes,
      getByPurpose,
      get composer() {
        return products2.composer;
      },
      get vx() {
        return products2.vx;
      },
      get dmp() {
        return products2.dmp;
      },
      get id() {
        return products2.id;
      },
      __protected__: {
        getVersion: getVersionConsent,
        addConsentsToParams,
        init,
        getConsentConfig,
        async
      }
    };
  };
  pn.container.register("consent", {
    useValue: consent3()
  });
  pn.consent = pn.container.resolve("consent");

  // ../src/lib/cookie.ts
  var cookie2 = (() => {
    const name3 = "cookie";
    let raw = false;
    const set = (key2, value, options) => {
      const cookieOptions = raw ? __spreadProps(__spreadValues({}, options), { raw }) : options;
      dist_exports.cookie.set(key2, value, cookieOptions);
    };
    const get = (key2) => {
      return dist_exports.cookie.get(key2) || void 0;
    };
    const remove = (key2, options) => {
      if (dist_exports.cookie.get(key2) !== null) {
        dist_exports.cookie.remove(key2, options);
        return true;
      }
      return false;
    };
    return {
      name: name3,
      raw,
      set,
      get,
      remove
    };
  })();
  pn.container.register("cookie", {
    useValue: cookie2
  });
  pn.cookie = pn.container.resolve("cookie");

  // ../src/lib/localStorage.ts
  var localStorage3 = (() => {
    const getLocalStorage = () => {
      try {
        return window.localStorage;
      } catch (error) {
        return null;
      }
    };
    const browserLocalStorage = getLocalStorage();
    if (!window.name) {
      window.name = Math.floor(Math.random() * 1e8);
    }
    const get = (keyName) => {
      if (!browserLocalStorage || typeof browserLocalStorage.getItem !== "function") {
        return;
      }
      const value = dist_exports.localStorage.get(keyName);
      try {
        return JSON.parse(value);
      } catch (e) {
        return value;
      }
    };
    const set = (keyName, value) => {
      if (!browserLocalStorage || typeof browserLocalStorage.getItem !== "function") {
        return;
      }
      dist_exports.localStorage.set(keyName, JSON.stringify(value));
    };
    const remove = (keyName) => {
      if (!browserLocalStorage || typeof browserLocalStorage.getItem !== "function") {
        return;
      }
      dist_exports.localStorage.remove(keyName);
    };
    return {
      get,
      set,
      remove
    };
  })();
  pn.container.register("localStorage", {
    useValue: localStorage3
  });
  pn.localStorage = pn.container.resolve("localStorage");

  // ../src/lib/versionService.ts
  var versionService = (() => {
    const name3 = "versionService";
    const ENV_TP_VERSION = "0";
    const getTinypassVersion = () => {
      return ENV_TP_VERSION;
    };
    const init = () => {
      window.__tpVersion = getTinypassVersion();
    };
    init();
    return {
      name: name3,
      getTinypassVersion
    };
  })();
  pn.container.register("versionService", {
    useValue: versionService
  });
  pn.versionService = pn.container.resolve("versionService");

  // ../src/lib/itp.ts
  var itp = ((container = pn.container) => {
    const ajax3 = container.resolve("ajax");
    const localStorage4 = container.resolve("localStorage");
    const consent4 = container.resolve("consent");
    const name3 = "itp";
    const secondsInHour = 3600;
    const delay2 = 2500;
    const cookiesTempStoreKey = "tp__unprocessedCookies";
    let timeout;
    let cookiesToSend = {};
    (() => {
      const cookiesTempStoreKeyLegacy = "tp__unprocessed\u0421ookies";
      const unprocessedCookiesLegacy = localStorage4.get(cookiesTempStoreKeyLegacy);
      if (unprocessedCookiesLegacy) {
        localStorage4.remove(cookiesTempStoreKeyLegacy);
        if (!localStorage4.get(cookiesTempStoreKey)) {
          localStorage4.set(cookiesTempStoreKey, unprocessedCookiesLegacy);
        }
      }
    })();
    function init() {
      if (!pn.cloudflareWorkerUrl || !pn.util.isSafariOrUiWebView())
        return;
      restoreUnprocessedCookies();
      if (Object.keys(cookiesToSend).length > 0) {
        sendCookiesWithDelay();
      }
    }
    function synchronizeCookie(cookieName, cookieValue, maxHoursOrExpDate) {
      if (!pn.cloudflareWorkerUrl || !pn.util.isSafariOrUiWebView())
        return;
      restoreUnprocessedCookies();
      addCookiesToSend(cookieName, cookieValue, maxHoursOrExpDate);
      storeUnprocessedCookies();
      sendCookiesWithDelay();
    }
    function sendCookiesWithDelay() {
      if (timeout) {
        clearTimeout(timeout);
      }
      timeout = setTimeout(function() {
        ajax3.request({
          url: pn.cloudflareWorkerUrl + "?maxAge=2628000",
          type: "POST",
          data: JSON.stringify(cookiesToSend),
          crossDomain: true,
          xhrFields: {
            withCredentials: true
          },
          success: function() {
            cookiesToSend = {};
            removeProcessedCookiesFromStore();
          },
          error: function(request, textStatus) {
            console.error(textStatus);
          }
        });
      }, delay2);
    }
    function addCookiesToSend(cookieName, cookieValue, maxHoursOrExpDate) {
      cookiesToSend[cookieName] = {
        value: cookieValue
      };
      if (!maxHoursOrExpDate)
        return;
      if (maxHoursOrExpDate instanceof Date) {
        cookiesToSend[cookieName].expires = maxHoursOrExpDate;
      } else {
        cookiesToSend[cookieName].maxAge = maxHoursOrExpDate * secondsInHour;
      }
    }
    function restoreUnprocessedCookies() {
      try {
        const unprocessedCookies = localStorage4.get(cookiesTempStoreKey);
        if (unprocessedCookies) {
          Object.keys(unprocessedCookies).forEach(function(cookieName) {
            cookiesToSend[cookieName] = unprocessedCookies[cookieName];
          });
        }
      } catch (e) {
        console.error(e);
      }
    }
    function storeUnprocessedCookies() {
      const product = consent4["vx"];
      if (product !== null) {
        product.localStorage.set(cookiesTempStoreKey, JSON.stringify(cookiesToSend));
      }
    }
    function removeProcessedCookiesFromStore() {
      localStorage4.remove(cookiesTempStoreKey);
    }
    return {
      name: name3,
      init,
      synchronizeCookie
    };
  })();
  pn.container.register("itp", {
    useValue: itp
  });
  pn.itp = pn.container.resolve("itp");

  // ../src/lib/util.ts
  var util = (container = pn.container) => {
    const jqUtils2 = container.resolve("jqUtils");
    const cookie3 = container.resolve("cookie");
    const versionService2 = container.resolve("versionService");
    const itp2 = container.resolve("itp");
    const consent4 = container.resolve("consent");
    const name3 = "util";
    let appTimezoneOffset;
    let globalAffiliateToken = "";
    const ADBLOCKER_STATUS = {
      ENABLED_AFTER_DISABLED: -2,
      NOT_DETECTED: -1,
      DISABLED: 0,
      ENABLED: 1
    };
    if (typeof "testString".toHex === "undefined") {
      Object.defineProperty(String.prototype, "toHex", {
        enumerable: false,
        value: function() {
          var hex = "";
          for (var i = 0; i < this.length; ++i) {
            hex += "" + this.charCodeAt(i).toString(16);
          }
          return hex;
        }
      });
    }
    const randomString = (length) => {
      if (!length) {
        length = 5;
      }
      var text = "";
      var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
      if (window.crypto && window.crypto.getRandomValues && typeof Uint32Array === "function") {
        var values = new Uint32Array(length);
        window.crypto.getRandomValues(values);
        for (var i = 0; i < length; i++) {
          text += possible.charAt(values[i] % possible.length);
        }
      } else {
        for (var i = 0; i < length; i++) {
          text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
      }
      return text;
    };
    const deleteCookie = (name4, cookieDomain, cookiePath) => {
      var options = { path: "/", expires: 0 };
      if (typeof cookieDomain !== "undefined") {
        options.domain = cookieDomain;
      }
      if (typeof cookiePath !== "undefined") {
        options.path = cookiePath;
      }
      cookie3.remove(name4, options);
    };
    const deleteTLDCookieForSpecificDomains = (name4, cookieDomain, cookiePath) => {
      if (cookieDomain.indexOf("abril.com.br") !== -1) {
        deleteCookie(name4, ".abril.com.br", cookiePath);
      }
      if (cookieDomain.indexOf("scotsman.com") !== -1) {
        deleteCookie(name4, ".scotsman.com", cookiePath);
      }
    };
    const findCookieByName = (regex) => {
      var _a;
      if (document.cookie.length === 0) {
        return null;
      }
      if (regex instanceof RegExp) {
        var cookies = document.cookie.split(";");
        for (var i = 0; i < cookies.length; i++) {
          var equalsPosition = cookies[i].indexOf("=");
          if (equalsPosition !== -1) {
            var cn = cookies[i].substr(0, equalsPosition).trim();
            var cookieValRegExp;
            if (regex.test(cn)) {
              cookieValRegExp = cookies[i].substr(equalsPosition + 1).trim();
              try {
                return decodeURIComponent(cookieValRegExp);
              } catch (e) {
                debug('Could not uri-decode cookie "' + regex.toString() + '"', e);
              }
              return cookieValRegExp;
            }
          }
        }
      } else {
        var value = "; " + document.cookie;
        var parts = value.split("; " + regex + "=");
        if (parts.length >= 2) {
          var cookieVal = (_a = parts.pop()) == null ? void 0 : _a.split(";").shift();
          if (typeof cookieVal === "undefined") {
            return null;
          }
          try {
            return decodeURIComponent(cookieVal);
          } catch (e) {
            debug('Could not uri-decode cookie "' + regex + '"', e);
          }
          return cookieVal;
        }
      }
      return null;
    };
    const findCookiesByName = (regex) => {
      if (document.cookie.length === 0) {
        return [];
      }
      var result = [];
      var cookies = document.cookie.split(";");
      for (var i = 0; i < cookies.length; i++) {
        var equalsPosition = cookies[i].indexOf("=");
        if (equalsPosition !== -1) {
          var cn = cookies[i].substr(0, equalsPosition).trim();
          var cookieVal;
          if (regex instanceof RegExp && regex.test(cn)) {
            cookieVal = cookies[i].substr(equalsPosition + 1).replace(/^\s+|\s+$/g, "");
            try {
              cookieVal = decodeURIComponent(cookieVal);
            } catch (e) {
              debug('Could not uri-decode cookie "' + regex.toString() + '"', e);
            }
            result.push({ name: cn, value: cookieVal });
          } else if (cn === regex) {
            cookieVal = cookies[i].substr(equalsPosition + 1).replace(/^\s+|\s+$/g, "");
            try {
              cookieVal = decodeURIComponent(cookieVal);
            } catch (e) {
              debug('Could not uri-decode cookie "' + regex + '"', e);
            }
            result.push({ name: cn, value: cookieVal });
          }
        }
      }
      return result;
    };
    function debug(...args) {
      if (pn.debug === true) {
        log3(...args);
      }
    }
    ;
    function error(...args) {
      log3(...args);
      var error2;
      if (typeof arguments[0] === "string") {
        error2 = new Error(arguments[0]);
      } else {
        error2 = new Error();
      }
      if (error2.stack) {
        log3(error2.stack);
      }
    }
    ;
    function log3(...args) {
      if (!window.console) {
        return;
      }
      if (!window.console.log) {
        return;
      }
      if (!window.console.log.apply) {
        return;
      }
      if (!window.console.log.apply.call) {
        return;
      }
      if (typeof window.console !== "undefined" && typeof window.console.log !== "undefined") {
        var newArgs = ["TP:"];
        try {
          for (var i = 0; i < args.length; i++) {
            newArgs.push(args[i]);
          }
        } catch (e) {
          newArgs = args;
        }
        if (isBot()) {
          newArgs = buildSeleniumLogMessage(newArgs);
        }
        typeof window.console.log === "object" ? window.console.log.apply.call(this, console, newArgs) : console.log.apply(console, newArgs);
      }
    }
    ;
    const getScroll = () => {
      var a = 0;
      window.pageYOffset ? a = window.pageYOffset : (a = document.documentElement || document.body.parentNode, a = typeof a.scrollTop === "number" ? a.scrollTop : document.body.scrollTop);
      return a;
    };
    const buildSeleniumLogMessage = (args) => {
      var seleniumMessage = "";
      try {
        for (var i = 0; i < args.length; i++) {
          try {
            seleniumMessage += JSON.stringify(args[i]) + ", ";
          } catch (e) {
            seleniumMessage += "" + e;
          }
        }
        return [seleniumMessage];
      } catch (e) {
        return args;
      }
    };
    const isInteger = (value) => {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    const getPageSize = () => {
      var width, height;
      width = Math.max(document.documentElement.clientWidth, document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth);
      height = Math.max(document.documentElement.clientHeight, document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight);
      return { x: width, y: height };
    };
    const getViewport = () => {
      var a, b;
      document.compatMode === "CSS1Compat" ? (a = document.documentElement.clientWidth, b = document.documentElement.clientHeight) : (a = document.body.clientWidth, b = document.body.clientHeight);
      return { x: a, y: b };
    };
    const center = (width, height) => {
      var scrollY = getScroll();
      var d = getViewport();
      d = { x: d.x / 2 - width / 2, y: d.y / 2 - height / 2 + scrollY };
      d.x = Math.max(0, d.x);
      d.y = Math.max(10, d.y);
      return d;
    };
    const centerScreen = (width, height) => {
      width = width || 0;
      height = height || 0;
      var dualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : window.screen.left;
      var dualScreenTop = window.screenTop !== void 0 ? window.screenTop : window.screen.top;
      const winSize = jqUtils2.winSize();
      var screenWidth = winSize.width || document.documentElement.clientWidth || window.screen.width;
      var screenHeight = winSize.height || document.documentElement.clientHeight || window.screen.height;
      var left = screenWidth / 2 - width / 2 + dualScreenLeft;
      var top = screenHeight / 2 - height / 2 + dualScreenTop;
      return { left, top };
    };
    const hasQueryParamByName = (name4) => {
      var qd = {};
      location.search.substr(1).split("&").forEach(function(item) {
        var s = item.split("="), k = s[0], v = s[1] && decodeURIComponent(s[1]);
        k in qd ? qd[k].push(v) : qd[k] = [v];
      });
      return qd.hasOwnProperty(name4);
    };
    const getQueryParamByName = (name4) => {
      name4 = name4.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
      var regex = new RegExp("[\\?&]" + name4 + "=([^&#]*)"), results = regex.exec(location.search);
      return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
    };
    const removeURLParameter = (url, parameters) => {
      var hash;
      var hashParts = url.split("#");
      var urlparts = hashParts[0].split("?");
      if (hashParts.length >= 2) {
        hash = hashParts[1];
      }
      parameters = Array.isArray(parameters) ? parameters : [parameters];
      if (urlparts.length >= 2) {
        var pars = urlparts[1].split(/[&;]/g);
        for (let j = 0; j < parameters.length; j++) {
          var prefix = encodeURIComponent(parameters[j]) + "=";
          for (var i = pars.length; i-- > 0; ) {
            if (pars[i].lastIndexOf(prefix, 0) !== -1) {
              pars.splice(i, 1);
            }
          }
        }
        url = urlparts[0] + (pars.length > 0 ? "?" + pars.join("&") : "");
        return hash ? url + "#" + hash : url;
      } else {
        return url;
      }
    };
    const isNextJsRouter = () => {
      return typeof window.next === "object" && typeof window.next.router === "object";
    };
    const replaceUrl = (urlFunction) => {
      const url = urlFunction(location.href);
      if (history && typeof history.replaceState === "function") {
        const historyState = isNextJsRouter() ? {
          url: urlFunction(history.state.url || ""),
          as: urlFunction(history.state.as || ""),
          options: history.state.options
        } : history.state;
        history.replaceState(historyState, document.title, url);
      } else {
        location.href = url;
      }
    };
    const removeQueryParamByName = (name4) => {
      replaceUrl((url) => removeURLParameter(url, name4));
    };
    const setAccessTokenListCookie = (accessTokenList, userToken, skipLogging) => {
      var __ut = getAidSpecifiedName("__ut");
      if (accessTokenList && jqUtils2.type(accessTokenList.value) === "string") {
        var expireDate = new Date();
        const domain = void 0;
        var options = {
          domain,
          path: "/",
          expires: 730,
          secure: true
        };
        if (accessTokenList.cookie_domain && accessTokenList.cookie_domain !== "localhost" && jqUtils2.inArray(accessTokenList.cookie_domain, getPossibleCookieDomains()) >= 0) {
          options.domain = accessTokenList.cookie_domain;
        }
        if (pn.cookieDomain) {
          options.domain = pn.cookieDomain;
        }
        if (pn.cookiePath) {
          options.path = pn.cookiePath;
        }
        const domains2 = getPossibleCookieDomains();
        for (let i in domains2) {
          deleteCookie("__tac", domains2[i]);
          deleteCookie("__tae", domains2[i]);
          deleteCookie(__ut, domains2[i]);
        }
        if (accessTokenList.value) {
          setCookieConsent("composer", "__tac", accessTokenList.value, options);
        }
        setCookieConsent("composer", "__tae", expireDate.getTime(), options);
        setCookieConsent("vx", __ut, userToken, options);
        if (userToken === "" && !skipLogging) {
          logImplicitLogout(accessTokenList);
        }
      } else {
        var domains = getPossibleCookieDomains();
        domains.push(void 0);
        if (pn.cookieDomain) {
          domains.push(pn.cookieDomain);
        }
        if (pn.cookiePath) {
          for (let i in domains) {
            deleteCookie("__tac", domains[i], pn.cookiePath);
            deleteCookie("__tae", domains[i], pn.cookiePath);
            deleteCookie("__eea", domains[i], pn.cookiePath);
            deleteCookie(__ut, domains[i], pn.cookiePath);
          }
        }
        for (let i in domains) {
          deleteCookie("__tac", domains[i]);
          deleteCookie("__tae", domains[i]);
          deleteCookie("__eea", domains[i]);
          deleteCookie(__ut, domains[i]);
        }
        if (!skipLogging) {
          logImplicitLogout(accessTokenList);
        }
      }
    };
    const setCurrentDomainFromResponse = (data) => {
      if (data && typeof data.browser !== "undefined" && typeof data.browser.cookie_domain !== "undefined") {
        doneCall("domainIsReceived", data.browser.cookie_domain);
      }
      if (data && data.tbc && data.tbc.cookie_domain) {
        doneCall("domainIsReceived", data.tbc.cookie_domain);
      }
    };
    const getCurrentDomainFromCookie = (cookieName, useBase64 = false) => {
      try {
        return parseJSON2(getCookie(cookieName), useBase64).domain;
      } catch (e) {
        startCall("domainIsReceived");
      }
    };
    const updateCookieValueFromResponse = (cookieName, cookieValue, domain) => {
      const options = __spreadValues({
        path: "/",
        expires: 730
      }, domain && { domain });
      const domains = getPossibleCookieDomains();
      for (let i in domains) {
        deleteCookie(cookieName, domains[i]);
      }
      if (options.domain) {
        deleteTLDCookieForSpecificDomains(cookieName, options.domain);
      }
      if (pn.cookieDomain || pn.cookiePath) {
        options.domain = pn.cookieDomain ? pn.cookieDomain : options.domain;
        deleteCookie(cookieName, options.domain, options.path);
        options.path = pn.cookiePath ? pn.cookiePath : options.path;
        deleteCookie(cookieName, options.domain, options.path);
      }
      deleteCookie(cookieName);
      setCookieConsent("composer", cookieName, cookieValue, options);
    };
    const setTbcCookieFromResponse = (json) => {
      if (json && json.browser && typeof json.browser.tbc !== "undefined") {
        updateCookieValueFromResponse("__tbc", json.browser.tbc, json.browser.cookie_domain);
      }
      if (json && json.tbc && json.tbc.cookie_value) {
        updateCookieValueFromResponse("__tbc", json.tbc.cookie_value, json.tbc.cookie_domain);
      }
    };
    const setTacCookieFromResponse = (json) => {
      const taeValue = new Date().getTime();
      const prevValue = getTacCookie();
      const updateCookieValue = (value, domain) => {
        if (!value || value === prevValue) {
          return;
        }
        updateCookieValueFromResponse("__tac", value, domain);
        updateCookieValueFromResponse("__tae", taeValue, domain);
      };
      if (json.browser) {
        updateCookieValue(json.browser.tac, json.browser.cookie_domain);
      }
      if (json.tac) {
        updateCookieValue(json.tac.cookie_value, json.tac.cookie_domain);
      }
    };
    const setXbcCookieFromResponse = (data) => {
      const XB_COOKIE = "xbc";
      if (data.xbc && data.xbc.cookie_value) {
        var options = {
          path: "/",
          expires: 730
        };
        if (data.xbc.cookie_domain && data.xbc.cookie_domain !== "localhost") {
          options.domain = data.xbc.cookie_domain;
          deleteTLDCookieForSpecificDomains(XB_COOKIE, data.xbc.cookie_domain);
        }
        if (pn.cookieDomain || pn.cookiePath) {
          const domains = getPossibleCookieDomains();
          for (let i in domains) {
            deleteCookie(XB_COOKIE, domains[i]);
          }
          options.domain = pn.cookieDomain ? pn.cookieDomain : options.domain;
          deleteTLDCookieForSpecificDomains(XB_COOKIE, options.domain, options.path);
          options.path = pn.cookiePath ? pn.cookiePath : options.path;
          deleteTLDCookieForSpecificDomains(XB_COOKIE, options.domain, options.path);
        }
        deleteCookie(XB_COOKIE);
        setCookieConsent("composer", XB_COOKIE, data.xbc.cookie_value, options);
      }
    };
    const getTbcCookie = () => {
      return getCookie("__tbc");
    };
    const getPcidCookie = () => {
      return getCookie("_pcid");
    };
    const getTopLevelDomain = () => dist_exports.cookie.getTopLevelDomain();
    const setTpccCookies = () => {
      var tpcc = getQueryParamByName("tpcc");
      if (tpcc) {
        var d = new Date();
        var campaignCodeDate = JSON.stringify({
          date: d.getTime()
        });
        var baseDomain = getTopLevelDomain();
        if (/^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(location.hostname)) {
          baseDomain = "";
        }
        if (!baseDomain) {
          baseDomain = "";
        }
        setCookieConsent("vx", "tpcc_" + tpcc, campaignCodeDate, { path: "/", expires: 90, domain: baseDomain });
      }
    };
    const getAidSpecifiedName = (name4) => {
      if (pn.useAidSpecifiedCookies && pn.aid) {
        return name4 + "_" + pn.aid;
      }
      return name4;
    };
    const getUserTokenCookie = () => {
      var cookieName = getAidSpecifiedName("__ut");
      var ut = findCookieByName(cookieName);
      if (typeof ut !== "undefined" && ut && ut.length >= 0) {
        return ut;
      } else {
        return null;
      }
    };
    const getPushListsCookie = () => {
      var cookieName = getAidSpecifiedName("__pls");
      var pushListSubscriptions;
      const jsonStr = findCookieByName(cookieName);
      if (jsonStr) {
        try {
          pushListSubscriptions = JSON.parse(jsonStr);
          if (pushListSubscriptions && !Array.isArray(pushListSubscriptions)) {
            throw new Error("Push list subscriptions must be an array");
          }
        } catch (e) {
          debug("Can't get push list subscriptions", e);
        }
      }
      return pushListSubscriptions;
    };
    const setPushListsCookie = (pushListId) => {
      if (!pushListId) {
        return;
      }
      var cookieName = getAidSpecifiedName("__pls");
      var pushListSubscriptions = getPushListsCookie() || [];
      if (pushListSubscriptions.indexOf(pushListId) > -1) {
        return;
      }
      pushListSubscriptions.push(pushListId);
      deleteCookie(cookieName);
      setCookieConsent("composer", cookieName, JSON.stringify(pushListSubscriptions), { path: "/", expires: 730, domain: getTopLevelDomain() });
    };
    const getBrowserTimezoneOffset = () => {
      return -Math.round(new Date().getTimezoneOffset());
    };
    const getAppTimezoneOffset = () => {
      if (appTimezoneOffset === void 0 || appTimezoneOffset === null) {
        appTimezoneOffset = getCookie("__pat");
      }
      return appTimezoneOffset || 0;
    };
    const setAppTimezoneOffset = (offsetInMillis) => {
      appTimezoneOffset = offsetInMillis;
      var baseDomain = getTopLevelDomain();
      setCookieConsent("vx", "__pat", appTimezoneOffset, { path: "/", expires: 30, domain: baseDomain });
    };
    const setAppTimezoneOffsetFromResponse = (json) => {
      if (json && json.browser && json.browser.app_timezone_offset !== void 0) {
        setAppTimezoneOffset(json.browser.app_timezone_offset);
      } else if (json && json.timezone_offset !== void 0) {
        setAppTimezoneOffset(json.timezone_offset);
      }
    };
    const getCampaigns = (params) => {
      const campaignsCookies = findCookiesByName(/^tpcc_.+/);
      const tpccQueryParam = getQueryParamByName("tpcc");
      const currentTPCCCookieName = `tpcc_${tpccQueryParam}`;
      let foundCurrentTPCCInCookies = false;
      campaignsCookies.forEach((cookie4) => {
        params[cookie4.name] = cookie4.value;
        if (tpccQueryParam && cookie4.name === currentTPCCCookieName) {
          foundCurrentTPCCInCookies = true;
        }
      });
      if (tpccQueryParam && !foundCurrentTPCCInCookies) {
        params[currentTPCCCookieName] = JSON.stringify({
          date: Date.now()
        });
      }
    };
    const getCustomCookies = () => {
      var result = {};
      var customCookies = findCookiesByName(/^_pc_.+/);
      customCookies.forEach((cookie4) => {
        result[decodeURIComponent(cookie4.name)] = cookie4.value;
      });
      return result;
    };
    const getPossibleCookieDomains = () => {
      var _a;
      var domains = [];
      domains.push(document.domain);
      var domainPartials = ((_a = document.domain) == null ? void 0 : _a.split(".")) || [];
      while (domainPartials.length >= 2) {
        domains.push("." + domainPartials.join("."));
        domainPartials.shift();
      }
      return domains;
    };
    const readAdblockerCookie = (cookieName) => {
      var cookieValue = getCookie(cookieName);
      if (jqUtils2.type(cookieValue) === "boolean" || jqUtils2.type(cookieValue) === "string" && cookieValue.length) {
        return cookieValue === true || cookieValue === "true" ? ADBLOCKER_STATUS.ENABLED : ADBLOCKER_STATUS.DISABLED;
      } else {
        return ADBLOCKER_STATUS.NOT_DETECTED;
      }
    };
    const getAdblockerHistoryCookieInfo = () => {
      var cookieValue = getCookie("__pnahc");
      var isFirst2 = false;
      if (typeof cookieValue === "undefined") {
        cookieValue = "0";
        isFirst2 = true;
      }
      return {
        cookieValue: parseInt(cookieValue, 10),
        isFirst: isFirst2
      };
    };
    const saveAdblockerHistoryCookieInfo = (__pnahc, newStatus) => {
      __pnahc = __pnahc << 1;
      if (newStatus === ADBLOCKER_STATUS.ENABLED) {
        __pnahc = __pnahc | 1 << 0;
      } else {
        __pnahc = __pnahc & ~(1 << 0);
      }
      if (newStatus !== ADBLOCKER_STATUS.NOT_DETECTED) {
        setCookieConsent("vx", "__pnahc", __pnahc + "", { path: "/", expires: 90 });
      }
    };
    const isAdblockHappend = (cookieValue) => {
      var _previousBit = cookieValue >> 0 & 1;
      return _previousBit === 1;
    };
    const getAdblockStatus = () => {
      var adblockerStatus = ADBLOCKER_STATUS.NOT_DETECTED;
      var _pnahcCookieInfo = getAdblockerHistoryCookieInfo();
      if (pn.adblockerCookieName) {
        adblockerStatus = readAdblockerCookie(pn.adblockerCookieName);
      }
      if (adblockerStatus === ADBLOCKER_STATUS.NOT_DETECTED) {
        adblockerStatus = readAdblockerCookie("__pac");
      }
      if (adblockerStatus === ADBLOCKER_STATUS.NOT_DETECTED) {
        adblockerStatus = readAdblockerCookie("__adblocker");
      }
      saveAdblockerHistoryCookieInfo(_pnahcCookieInfo.cookieValue, adblockerStatus);
      if (adblockerStatus === ADBLOCKER_STATUS.ENABLED) {
        if (!_pnahcCookieInfo.isFirst) {
          if (!isAdblockHappend(_pnahcCookieInfo.cookieValue)) {
            adblockerStatus = ADBLOCKER_STATUS.ENABLED_AFTER_DISABLED;
          }
        }
      }
      return adblockerStatus;
    };
    const getAdblockerStatusReason = () => {
      var _reason = "";
      if (typeof window.blockAdBlock !== "undefined") {
        _reason = "1";
      } else {
        _reason = "0";
      }
      return _reason;
    };
    const calls = {};
    const hasCall = (callName) => {
      return !!calls[callName];
    };
    const waitCall = (callName, callback) => {
      if (!calls[callName]) {
        callback();
      } else {
        calls[callName].waiters.push(callback);
      }
    };
    const startCall = (callName) => {
      if (!calls[callName]) {
        calls[callName] = {
          counter: 1,
          waiters: []
        };
      } else {
        calls[callName].counter++;
      }
    };
    const doneCall = (callName, args) => {
      if (calls[callName]) {
        calls[callName].counter--;
        if (calls[callName].counter <= 0) {
          var waiters = [];
          calls[callName].waiters.forEach((f2) => {
            waiters.push(f2);
          });
          delete calls[callName];
          waiters.forEach((f2) => {
            f2(args !== void 0 ? args : {});
          });
        }
      }
    };
    const str2timestamp = (str) => {
      if (typeof str === "undefined" || str.length === 0) {
        return;
      }
      if (typeof str !== "string") {
        str = "" + str;
      }
      str = str.trim();
      if (str.match(/^[0-9]{0,10}$/)) {
        return parseInt(str);
      }
      if (str.match(/^[0-9]{13,}$/)) {
        return parseInt(str) / 1e3;
      }
      var ts = Date.parse(str);
      if (ts) {
        return ts / 1e3;
      }
      str = str.replace(/00:([0-9]{2}(:[0-9]{2})?\s*[AP]M)/i, "12:$1").replace(/([0-9]{2})([AP|M])/i, "$1 $2");
      str = str.replace(/\s*(at|@|\-|on|\|)\s*/gi, " ");
      str = str.replace(/\s*(mon(day)?|tue(s?day)?|wed(nesday)?|thu((rs)?day)?|fri(day)?|sat(urday)?|sun(day)?)\s*/gi, "");
      str = str.replace(/([0-9]{1,2})(st|nd|rd|th)/, "$1");
      if (str.match(/\s+ET$/)) {
        var d = new Date();
        if (d.getTimezoneOffset() === 240) {
          str = str.replace(/\s+ET$/, " EDT");
        } else {
          str = str.replace(/\s+ET$/, " EST");
        }
      }
      str = str.trim();
      ts = Date.parse(str);
      if (ts) {
        return ts / 1e3;
      }
      var m = str.match(/!^([a-z]+)[-/ ]([0-9]+)[-/ ]([0-9]+)(.*)$!i/);
      if (m) {
        str = m[2] + " " + m[1] + " " + m[3] + m[4];
      } else if (m = str.match(/!^([0-9]+)[-/ ]([a-z]+)[-/ ]([0-9]+)(.*)$!i/)) {
        str = m[1] + " " + m[2] + " " + m[3] + m[4];
      }
      ts = Date.parse(str);
      if (ts) {
        return ts / 1e3;
      }
    };
    const isMobileTabletIOs = () => {
      var ua = getUserAgent();
      return /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
    };
    const isIphone = () => {
      var ua = getUserAgent();
      return /iPhone/.test(ua) && !window.MSStream;
    };
    const getIphoneVersion = () => {
      const ua = getUserAgent();
      const iPhoneInfo = ua.match(/iPhone OS (\d{2})/);
      if (iPhoneInfo) {
        const [match, currentVersion] = iPhoneInfo;
        return currentVersion ? Number(currentVersion) : null;
      }
      return null;
    };
    const isIphone17OrHigher = () => {
      const iPhoneVersion = getIphoneVersion();
      if (iPhoneVersion) {
        return iPhoneVersion >= 17;
      }
      return false;
    };
    const isIOS = () => {
      var ua = getUserAgent();
      return /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
    };
    const isIOsUiWebView = () => {
      var ua = getUserAgent();
      return /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(ua);
    };
    const isSafariOrIOsUiWebView = () => {
      var ua = getUserAgent();
      return /(iPhone|iPod|iPad).*AppleWebKit/i.test(ua);
    };
    const isSafariOrUiWebView = () => {
      var ua = getUserAgent();
      return /(Macintosh|iPhone|iPod|iPad)(?!.*Chrome)(?!.*Firefox)(?!.*Opera)(?!.*MSIE)(?!.*Trident)(.*AppleWebKit|.*Safari)/i.test(ua);
    };
    const isChrome = () => {
      var isChromium = window.chrome;
      var winNav = window.navigator;
      var vendorName = winNav.vendor;
      var isOpera = typeof window.opr !== "undefined";
      var isIEedge = winNav.userAgent.indexOf("Edg") > -1;
      var isIOSChrome = winNav.userAgent.match("CriOS");
      if (isIOSChrome) {
        return false;
      } else {
        return isChromium !== null && typeof isChromium !== "undefined" && vendorName === "Google Inc." && isOpera === false && isIEedge === false;
      }
    };
    const isFBOrInstWebView = () => {
      var ua = getUserAgent();
      return ua.indexOf("FBAN") > -1 || ua.indexOf("FBAV") > -1 || ua.indexOf("Instagram") > -1;
    };
    const isAndroid = () => {
      var ua = getUserAgent();
      return /(android)/i.test(ua);
    };
    const isCxenseBot = () => {
      var ua = getUserAgent();
      return /(cxensebot)/i.test(ua);
    };
    const isEdge = () => /Edg(e?)/i.test(getUserAgent());
    const getUserAgent = () => {
      return navigator.userAgent || navigator.vendor || window.opera;
    };
    const isDevEndpoint = () => {
      return versionService2.getTinypassVersion().indexOf("SNAPSHOT") >= 0;
    };
    const isApplePayAllowed = () => {
      var canApplePayMakePayments = false;
      try {
        canApplePayMakePayments = isSafari() && window.ApplePaySession && window.ApplePaySession.canMakePayments();
      } catch (e) {
        log3("ApplePay error", e);
      }
      if (isDevEndpoint()) {
        return canApplePayMakePayments;
      } else {
        return isHttpsProtocol() && canApplePayMakePayments;
      }
    };
    const isHttpsProtocol = () => {
      return document.location.protocol === "https:";
    };
    const splitOnce = (fragment, delimiter) => {
      var result = [];
      var index = fragment.indexOf(delimiter);
      if (index === -1) {
        result.push(fragment);
      } else {
        result.push(fragment.substr(0, index));
        result.push(fragment.substr(index + 1));
      }
      return result;
    };
    const splitUrl = (url) => {
      var queryStringDelimiterIndex = url.indexOf("?");
      var hashDelimiterIndex = url.indexOf("#");
      var hasHash = false;
      if (hashDelimiterIndex !== -1) {
        hasHash = true;
      }
      var hasQueryString = false;
      if (queryStringDelimiterIndex !== -1) {
        hasQueryString = true;
      }
      if (hasHash && hasQueryString && hashDelimiterIndex < queryStringDelimiterIndex) {
        hasQueryString = false;
      }
      var schemeDomainAndPath;
      var queryString = "";
      var hash = "";
      if (hasQueryString) {
        var splitPartsByQueryString = splitOnce(url, "?");
        schemeDomainAndPath = splitPartsByQueryString[0];
        if (hasHash) {
          var splitPartsByHash = splitOnce(splitPartsByQueryString[1], "#");
          queryString = splitPartsByHash[0];
          hash = splitPartsByHash[1];
        } else {
          queryString = splitPartsByQueryString[1];
        }
      } else {
        if (hasHash) {
          var splitPartsByHashWithoutQueryString = splitOnce(url, "#");
          schemeDomainAndPath = splitPartsByHashWithoutQueryString[0];
          hash = splitPartsByHashWithoutQueryString[1];
        } else {
          schemeDomainAndPath = url;
        }
      }
      return {
        schemeDomainAndPath,
        queryString,
        hash,
        hasQueryString,
        hasHash
      };
    };
    const prepareQueryStringParameter = (queryParameter) => {
      var splitPartsByQueryParameterValueDelimiter = splitOnce(queryParameter, "=");
      var queryParameterName;
      var queryParameterValue;
      if (typeof queryParameter !== "undefined") {
        queryParameterName = splitPartsByQueryParameterValueDelimiter[0];
        queryParameterValue = splitPartsByQueryParameterValueDelimiter[1];
      }
      var result = "";
      if (typeof queryParameterName !== "undefined") {
        result += encodeURIComponent(decodeURIComponent(queryParameterName));
      }
      if (typeof queryParameterValue !== "undefined") {
        result += "=" + encodeURIComponent(decodeURIComponent(queryParameterValue));
      }
      return result;
    };
    const prepareQueryString = (queryString) => {
      var preparedQueryString = "";
      if (typeof queryString !== "undefined") {
        var splitPartsByParameterDelimiter = queryString.split("&");
        for (var qpIndex = 0; qpIndex < splitPartsByParameterDelimiter.length; qpIndex++) {
          if (qpIndex > 0) {
            preparedQueryString += "&";
          }
          preparedQueryString += prepareQueryStringParameter(splitPartsByParameterDelimiter[qpIndex]);
        }
      }
      return preparedQueryString;
    };
    const prepareUrlParameter = (url) => {
      if (!url) {
        return "";
      }
      url = url.replace(/^((%20)|\s)+/, "");
      var splitResult = splitUrl(url);
      var resultUrl = encodeURI(decodeURI(splitResult.schemeDomainAndPath));
      if (splitResult.hasQueryString) {
        resultUrl += "?" + prepareQueryString(splitResult.queryString);
      }
      if (splitResult.hasHash) {
        resultUrl += "#" + encodeURIComponent(decodeURIComponent(splitResult.hash));
      }
      return resultUrl;
    };
    const ipPartIsValid = (part) => {
      var ipPart = parseInt(part, 10);
      return !(isNaN(parseFloat(ipPart)) || ipPart < 0 || ipPart > 255);
    };
    const isValidInet4Address = (hostname) => {
      var partsOfIp = hostname.split(".");
      var domainIsIp = true;
      if (partsOfIp.length === 4) {
        if (!ipPartIsValid(partsOfIp[0]) || !ipPartIsValid(partsOfIp[1]) || !ipPartIsValid(partsOfIp[2]) || !ipPartIsValid(partsOfIp[3])) {
          domainIsIp = false;
        }
      } else {
        domainIsIp = false;
      }
      return domainIsIp;
    };
    const getHostname = (origin) => {
      var linkElement = document.createElement("a");
      var pattern = /^https?:\/\//i;
      linkElement.href = pattern.test(origin) ? origin : "http://" + origin;
      var hostname = linkElement.hostname;
      if (hostname.indexOf("www.") === 0) {
        hostname = hostname.replace("www.", "");
      }
      return hostname;
    };
    function debounce(func, wait, immediate) {
      var timeout;
      return function() {
        var context = this;
        var args = Array.prototype.slice.call(arguments);
        var later = function() {
          timeout = null;
          if (!immediate) {
            func.apply(context, args);
          }
        };
        var callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow) {
          func.apply(context, args);
        }
      };
    }
    function throttle(func, ms2) {
      var isThrottled = false;
      let savedArgs;
      let savedThis;
      function wrapper() {
        if (isThrottled) {
          savedArgs = arguments;
          savedThis = this;
          return;
        }
        func.apply(this, arguments);
        isThrottled = true;
        setTimeout(function() {
          isThrottled = false;
          if (savedArgs) {
            wrapper.apply(savedThis, savedArgs);
            savedArgs = savedThis = null;
          }
        }, ms2);
      }
      return wrapper;
    }
    function profile(func) {
      Object.defineProperty(wrapper, "__invokeCount", {
        writable: true,
        value: 0
      });
      Object.defineProperty(wrapper, "invokeCount", {
        get: function() {
          return this.__invokeCount;
        }
      });
      function wrapper() {
        wrapper.__invokeCount++;
        return func.apply(this, arguments);
      }
      return wrapper;
    }
    function isSafari() {
      const userAgent = getUserAgent();
      const match = userAgent.match(/Version.+Safari/);
      return match !== null;
    }
    const isIE = () => {
      var oldIE = (navigator && navigator.appVersion || "").indexOf("MSIE") !== -1;
      var userAgent = navigator && navigator.userAgent || "";
      var IE11 = userAgent.indexOf("Trident/") > 0;
      return oldIE || IE11;
    };
    const isCriOS = () => {
      return (navigator && navigator.userAgent || "").indexOf("CriOS") !== -1;
    };
    const isRelativeUrl = (url) => {
      return /^\/(?:\w+|\.{1,2}\/\w+)/.test(url);
    };
    const removeParamFromUrl = (url, paramName) => {
      if (new RegExp("\\?" + paramName, "gi").test(url)) {
        if (url.split("&").length > 1) {
          return url.replace(new RegExp(paramName + "[^&]+&?", "gi"), "");
        } else {
          return url.replace(new RegExp("\\?" + paramName + "[^&]+&?", "gi"), "");
        }
      }
      if (new RegExp("\\&" + paramName, "gi").test(url)) {
        return url.replace(new RegExp("\\&" + paramName + "[^&]+", "gi"), "");
      }
      return url;
    };
    const extractCookieDomain = (href) => {
      if (href && href.length && href[0] === ".") {
        return href;
      }
      var url = href || window.location.href;
      var hostname = getHostname(url);
      if (isValidInet4Address(hostname)) {
        return hostname;
      }
      if (hostname === "localhost") {
        return null;
      }
      return "." + hostname;
    };
    const logImplicitLogout = (accessTokenList) => {
      try {
        const error2 = new Error();
        sendLog({
          trace: reduceStack(error2.stack, 6),
          desc: "clearing __tp cookie",
          accessTokenList
        });
      } catch (e) {
      }
      ;
    };
    const logRemoveTokens = (payload) => {
      var _a, _b;
      sendLog({
        uid: (_a = payload.uid) != null ? _a : "n",
        desc: "clearing __utp cookie",
        actions: (_b = payload.actions) != null ? _b : "n"
      });
    };
    const sendLog = (data) => {
      try {
        const userProvider = pn.user.getProvider();
        const log4 = JSON.stringify([__spreadValues({
          aid: pn.aid,
          up: userProvider.getName(),
          url: window.location.href,
          t: new Date().getTime(),
          v: versionService2.getTinypassVersion(),
          tags: ["sdk"]
        }, data)]);
        pn.api.callApi("/anon/error/log", { log_message: log4 });
      } catch (e) {
      }
    };
    function documentReady(fn) {
      var completed = function() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        fn();
      };
      if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
        window.setTimeout(fn);
      } else {
        document.addEventListener("DOMContentLoaded", completed);
        window.addEventListener("load", completed);
      }
    }
    const getAdjustedCookieExpiration = (preferableExpiration) => {
      if (!preferableExpiration) {
        preferableExpiration = 730;
      }
      var maxCookieExpirationInDays = pn.getMaxCookieExpirationInDays();
      if (maxCookieExpirationInDays !== null) {
        var expirationDate;
        if (typeof preferableExpiration === "number") {
          expirationDate = new Date();
          expirationDate.setDate(expirationDate.getDate() + preferableExpiration);
        } else {
          expirationDate = preferableExpiration;
        }
        var maxCookieExpirationDate = new Date();
        maxCookieExpirationDate.setDate(maxCookieExpirationDate.getDate() + maxCookieExpirationInDays);
        if (expirationDate > maxCookieExpirationDate) {
          return maxCookieExpirationInDays;
        }
      }
      return preferableExpiration;
    };
    const getCookie = (cookieName) => {
      return cookie3.get(cookieName);
    };
    const setCookieConsent = (consentProduct, cookieName, cookieValue, options) => {
      var _a;
      if (!consent4[consentProduct]) {
        debug("CONSENT ERROR: Consent module was not initiliazed");
      }
      setCookie(cookieName, cookieValue, options, ((_a = consent4[consentProduct]) == null ? void 0 : _a.cookie.set) || cookie3.set);
    };
    const setCookie = (cookieName, cookieValue, options, cookieSetFn = cookie3.set) => {
      options = options || {};
      if (pn.aid === "11C6aYHwtb") {
        options.samesite = "none";
        options.secure = true;
      } else {
        options.samesite = "lax";
      }
      if (options.expires) {
        options.expires = getAdjustedCookieExpiration(options.expires);
      }
      cookieSetFn(cookieName, cookieValue, options);
      if (typeof itp2.synchronizeCookie !== "undefined") {
        itp2.synchronizeCookie(cookieName, cookieValue, options.expires);
      }
    };
    const LOCAL_STORAGE_PREFIX = "__tp-";
    const getCurrentTimestamp = () => {
      return Math.floor(new Date().getTime() / 1e3);
    };
    const hasLocalStorage = () => {
      try {
        return typeof window.localStorage === "object" && typeof window.localStorage.getItem === "function";
      } catch (e) {
        return false;
      }
    };
    const randomStringCxCompatible2 = () => {
      var randomString2 = new Date().getTime().toString(36);
      while (randomString2.length < 16) {
        randomString2 += Math.round(Math.random() * 2147483647).toString(36);
      }
      return randomString2.substr(0, 16);
    };
    const LOCAL_STORAGE_EXPERATION_SUFFIX = "-expiration";
    const getLocalStorageItem = (key2) => {
      const keyName = LOCAL_STORAGE_PREFIX + key2;
      const value = dist_exports.localStorage.get(keyName);
      var expirationValue = dist_exports.localStorage.get(keyName + LOCAL_STORAGE_EXPERATION_SUFFIX);
      if (expirationValue && expirationValue < getCurrentTimestamp()) {
        dist_exports.localStorage.remove(keyName);
        dist_exports.localStorage.remove(keyName + LOCAL_STORAGE_EXPERATION_SUFFIX);
        return null;
      }
      return value;
    };
    const setLocalStorageItem = (consentProduct, key2, value, expires, usePrefix = true) => {
      const keyName = (usePrefix ? LOCAL_STORAGE_PREFIX : "") + key2;
      const product = consent4[consentProduct];
      if (product) {
        product.localStorage.set(keyName, value, { expires });
      } else {
        error("There is no such initiated consentProduct ->", consentProduct);
      }
    };
    const removeLocalStorageItem = (key2) => {
      const keyName = LOCAL_STORAGE_PREFIX + key2;
      dist_exports.localStorage.remove(keyName);
    };
    const cameFromFbSubscriptions = () => {
      var redirectUri = getQueryParamByName("redirect_uri");
      return redirectUri.indexOf("https://www.facebook.com/subscriptions/account-linking/confirm/") === 0;
    };
    const waitAllPromises = (promises) => {
      return Promise.all(promises);
    };
    const racePromise = (promises) => {
      return Promise.race(promises);
    };
    const isBot = () => {
      var documentDetectionKeys = [
        "__webdriver_evaluate",
        "__selenium_evaluate",
        "__webdriver_script_function",
        "__webdriver_script_func",
        "__webdriver_script_fn",
        "__fxdriver_evaluate",
        "__driver_unwrapped",
        "__webdriver_unwrapped",
        "__driver_evaluate",
        "__selenium_unwrapped",
        "__fxdriver_unwrapped"
      ];
      var windowDetectionKeys = [
        "_phantom",
        "__nightmare",
        "_selenium",
        "callPhantom",
        "callSelenium",
        "_Selenium_IDE_Recorder"
      ];
      for (var windowDetectionKey in windowDetectionKeys) {
        var windowDetectionKeyValue = windowDetectionKeys[windowDetectionKey];
        if (window[windowDetectionKeyValue]) {
          return true;
        }
      }
      for (var documentDetectionKey in documentDetectionKeys) {
        var documentDetectionKeyValue = documentDetectionKeys[documentDetectionKey];
        if (window.document[documentDetectionKeyValue]) {
          return true;
        }
      }
      for (var documentKey in window.document) {
        if (documentKey.match(/\$[a-z]dc_/) && window.document[documentKey]["cache_"]) {
          return true;
        }
      }
      if (window.external && window.external.toString && window.external.toString() && window.external.toString().indexOf("Sequentum") !== -1) {
        return true;
      }
      if (window.document.documentElement.getAttribute("selenium")) {
        return true;
      }
      if (window.document.documentElement.getAttribute("webdriver")) {
        return true;
      }
      if (window.document.documentElement.getAttribute("driver")) {
        return true;
      }
      return false;
    };
    const addScript = (src, onload) => {
      var _a;
      var a = document.createElement("script");
      var b = document.getElementsByTagName("script")[0];
      (_a = b.parentNode) == null ? void 0 : _a.insertBefore(a, b);
      a.type = "text/javascript";
      a.async = true;
      a.onload = onload;
      a.src = src;
    };
    const isScriptAdded = (src) => {
      const scripts = document.getElementsByTagName("script");
      for (let i = 0, k = scripts.length; i < k; i++) {
        if (scripts[i].src.indexOf(src) > -1) {
          return true;
        }
      }
      return false;
    };
    const fromUnderscoreToCamelCase = (string) => {
      return string.slice().replace(/_[a-z]/g, function(g) {
        return g.replace("_", "").toUpperCase();
      });
    };
    const removeVoucherCodeFromUrl = (url) => {
      return removeParamFromUrl(url, "voucher_code");
    };
    const removeSharedAccountCodeFromUrl = (url) => {
      return removeParamFromUrl(url, "shared_account_code");
    };
    const mapArrayIndex = (element, index) => {
      return index;
    };
    const getTacCookie = () => {
      return getCookie("__tac");
    };
    const getReferrer = () => {
      return document.referrer;
    };
    const getAffiliateToken = (name4) => {
      const hash = window.location.hash.slice(1);
      if (hash) {
        const [paramName, tokenValue] = hash.split("=");
        if (paramName && tokenValue && paramName === name4) {
          replaceUrl((url) => url.split("#")[0]);
          globalAffiliateToken = tokenValue;
        }
      }
      return globalAffiliateToken;
    };
    const removeAffiliateToken = () => {
      globalAffiliateToken = "";
    };
    const reduceStack = (stack, size) => {
      return stack && stack.split("\n").filter((item, index) => index > 1 && index < size + 1).map((i) => i.trim()).join("");
    };
    const setVxUsersToDataLayer = (users2) => {
      const dlUsers = dataLayer.get("users");
      let needUpdate = false;
      const filteredUsers = dlUsers ? Object.keys(dlUsers).reduce((res, key2) => {
        var _a;
        if (((_a = dlUsers[key2]) == null ? void 0 : _a.type) === "VX") {
          needUpdate = true;
          res[key2] = null;
        }
        return res;
      }, {}) : {};
      if (dlUsers && needUpdate || users2) {
        dataLayer.set("users", __spreadValues(__spreadValues({}, filteredUsers), users2));
      }
    };
    const tryFn2 = (resolve, reject) => {
      try {
        return resolve();
      } catch (e) {
        return reject ? tryFn2(reject) : null;
      }
    };
    const parseJSON2 = (data, useBase64 = false) => {
      return tryFn2(() => JSON.parse(data), () => useBase64 ? JSON.parse(window.atob(data)) : null) || null;
    };
    const toJSON2 = (data, useBase64 = false) => {
      const str = JSON.stringify(data);
      return tryFn2(() => useBase64 ? window.btoa(str) : str) || str;
    };
    const setUserSegments = (eventExecutionContext) => {
      const executeSegments = eventExecutionContext.userSegments || {};
      const validated = Object.keys(executeSegments).reduce((res, key2) => {
        const segments = executeSegments[key2].segments;
        if (Array.isArray(segments) && segments.length) {
          res[key2] = {
            segments: executeSegments[key2].segments
          };
        }
        return res;
      }, {});
      dataLayer.set("userSegments", Object.keys(validated).length ? validated : null);
    };
    const getPageViewContext = () => {
      const content2 = dataLayer.isReady && dataLayer.get("content") || {};
      let created = content2.createdAt ? new Date(content2.createdAt).getTime() : 0;
      if (!created || isNaN(created)) {
        created = void 0;
      }
      return {
        pageTitle: content2.title || window.document.title,
        referrerUrl: prepareUrlParameter(getReferrer() || window.document.referrer),
        url: prepareUrlParameter(window.location.href),
        pageViewId: dataLayer.isReady && dataLayer.get("pageViewId") || null,
        author: (content2.authors || []).join(","),
        created,
        section: content2.section,
        tags: content2.tags,
        contentType: content2.type || ""
      };
    };
    const getBrowserId = () => {
      return dataLayer.isReady ? dataLayer.get("browserId") : null;
    };
    const asUint8Array = (content2) => {
      let uint8Array = new Uint8Array(content2.length);
      let contentChars = content2.split("");
      for (let i = 0; i < content2.length; i++) {
        uint8Array[i] = contentChars[i].charCodeAt(0);
      }
      return uint8Array;
    };
    const getCookieConsents = () => {
      return dataLayer.utils.getConsent() || dataLayer.utils.notAcquiredConsent;
    };
    const getUserSegments = () => {
      return dataLayer.isReady ? dataLayer.get("userSegments") : null;
    };
    const getUserSegmentsString = () => {
      return JSON.stringify(getUserSegments());
    };
    const getUserState = () => {
      return dataLayer.isReady ? dataLayer.get("userStatus") : null;
    };
    const requireJsFile = (jsFileSrc) => {
      return new Promise((resolve, reject) => {
        const a = document.createElement("script");
        a.onload = resolve;
        a.onerror = resolve;
        a.type = "text/javascript";
        a.charset = "utf-8";
        a.async = true;
        a.src = jsFileSrc;
        document.getElementsByTagName("head")[0].appendChild(a);
      });
    };
    return {
      name: name3,
      __private__: {
        getAdjustedCookieExpiration
      },
      __protected__: {
        deleteTLDCookieForSpecificDomains,
        documentReady,
        getCookie,
        setCookieConsent,
        setCookie,
        getLocalStorageItem,
        hasLocalStorage,
        randomStringCxCompatible: randomStringCxCompatible2,
        setLocalStorageItem,
        removeLocalStorageItem,
        cameFromFbSubscriptions,
        logRemoveTokens,
        waitAllPromises,
        isInteger,
        racePromise,
        isCxenseBot,
        isHttpsProtocol,
        isApplePayAllowed,
        isDevEndpoint,
        setVxUsersToDataLayer
      },
      toJSON: toJSON2,
      parseJSON: parseJSON2,
      addScript,
      isScriptAdded,
      fromUnderscoreToCamelCase,
      randomString,
      log: log3,
      debug,
      error,
      findCookieByName,
      findCookiesByName,
      removeVoucherCodeFromUrl,
      removeSharedAccountCodeFromUrl,
      deleteCookie,
      mapArrayIndex,
      getScroll,
      getPageSize,
      getViewport,
      center,
      centerScreen,
      getQueryParamByName,
      hasQueryParamByName,
      removeQueryParamByName,
      setAccessTokenListCookie,
      setTpccCookies,
      getCampaigns,
      getCustomCookies,
      ADBLOCKER_STATUS,
      getAdblockStatus,
      getAdblockerStatusReason,
      getAdblockerHistoryCookieInfo,
      waitCall,
      startCall,
      doneCall,
      hasCall,
      debounce,
      throttle,
      profile,
      setTbcCookieFromResponse,
      setTacCookieFromResponse,
      setXbcCookieFromResponse,
      getTbcCookie,
      getPcidCookie,
      getTacCookie,
      getAidSpecifiedName,
      getUserTokenCookie,
      getPushListsCookie,
      setPushListsCookie,
      setAppTimezoneOffsetFromResponse,
      setAppTimezoneOffset,
      getAppTimezoneOffset,
      getBrowserTimezoneOffset,
      str2timestamp,
      getPossibleCookieDomains,
      isMobileTabletIOs,
      isIphone,
      getIphoneVersion,
      isIphone17OrHigher,
      isIOS,
      isIOsUiWebView,
      isSafariOrIOsUiWebView,
      isSafariOrUiWebView,
      isFBOrInstWebView,
      isChrome,
      isAndroid,
      isSafari,
      isIE,
      isCriOS,
      isEdge,
      isRelativeUrl,
      prepareUrlParameter,
      getReferrer,
      getHostname,
      extractCookieDomain,
      setCurrentDomainFromResponse,
      getCurrentDomainFromCookie,
      isBot,
      getAffiliateToken,
      removeAffiliateToken,
      asUint8Array,
      setUserSegments,
      getPageViewContext,
      getBrowserId,
      getCookieConsents,
      getUserSegments,
      getUserSegmentsString,
      getUserState,
      requireJsFile
    };
  };
  pn.container.register("util", {
    useValue: util()
  });
  pn.util = pn.container.resolve("util");

  // ../src/lib/frequency-capping/utils.ts
  var compatibleHash = (data) => {
    let hash = 0;
    for (let i = 0; i < data.length; i++) {
      const chr = data.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return hash;
  };
  var hashId = (str) => compatibleHash(str).toString(36);
  var checkSum = (data, salt) => {
    return (compatibleHash(data) ^ compatibleHash(salt)).toString(36);
  };
  var nowInMinutes = () => Math.floor(Date.now() / 6e4);

  // ../src/lib/frequency-capping/pcfe.constant.ts
  var COOKIE_NAME = "_pcfe";
  var COOKIE_EXPIRATION = 90;
  var DATA_PREFIX = "{kjfx}";
  var MAX_WINDOW_SIZE_IN_MINUTES = 129600;
  var MAX_EVENTS_PER_EVENT_TYPE = 30;
  var MAX_BUCKETS_PER_COOKIE = 12;
  var PCFE_VERSION = "1";
  var TOP_LEVEL_DOMAIN = dist_exports.cookie.getTopLevelDomain();

  // ../src/lib/frequency-capping/pcfe.utils.ts
  var PREFIX_REG_EXP = /{[a-z0-9-]{1,7}}/g;
  var encode = (data, aid) => {
    const encodedData = {
      os: "",
      e: {},
      v: PCFE_VERSION
    };
    const events = {};
    encodedData.os = data.originStamp.toString(36);
    for (const [hashId2, value] of Object.entries(data.events)) {
      const timeOffsetsByType = {};
      for (const [eventType, offsets] of Object.entries(value.timeOffsetsByType)) {
        Object.assign(timeOffsetsByType, { [eventType]: offsets.map((v) => v.toString(36)).join(",") });
      }
      events[hashId2] = { to: timeOffsetsByType };
    }
    encodedData.e = events;
    const encodedJson = JSON.stringify(encodedData);
    const uncompressedSize = encodedJson.length.toString(36);
    const compressedJson = dataLayer.utils.compressLz(encodedJson);
    return `${DATA_PREFIX}{${uncompressedSize}}{${checkSum(compressedJson, aid)}}${compressedJson}`;
  };
  var decode3 = (data, aid, debug) => {
    const prefixes = data.match(PREFIX_REG_EXP) || [];
    if (prefixes.length != 3 || prefixes[0] !== DATA_PREFIX) {
      throw new Error("Malformed input, invalid headers");
    }
    for (const prefix of prefixes) {
      data = data.replace(prefix, "");
    }
    const uncompressedSize = Number.parseInt(prefixes[1].replace(/[{}]/g, ""), 36);
    const actualCheckSum = checkSum(data, aid);
    const expectedChecmSum = prefixes[2].replace(/[{}]/g, "");
    debug(`${expectedChecmSum} : ${actualCheckSum}`);
    if (actualCheckSum != expectedChecmSum) {
      throw new Error("Malformed input, invalid checksum header");
    }
    const decodedData = {
      originStamp: 0,
      events: {},
      v: void 0
    };
    const events = {};
    const eventArrays = [];
    const decompressed = dataLayer.utils.decompressLz(data);
    let parsedData;
    if (!decompressed) {
      throw new Error("Malformed input, cann't be decoded");
    }
    if (decompressed.length != uncompressedSize) {
      throw new Error("Malformed input, invalid size header");
    }
    try {
      parsedData = JSON.parse(decompressed);
    } catch (e) {
      throw new Error("Malformed input, invalid format");
    }
    let originStamp = Number.parseInt(parsedData.os, 36);
    let gsOffset = 0;
    const now = nowInMinutes();
    const originRebaseRequired = now - originStamp > MAX_WINDOW_SIZE_IN_MINUTES;
    let hasEvents = false;
    debug(`origin stamps: ${originStamp}, now: ${now}, rebase required: ${originRebaseRequired}`);
    for (const [hashId2, value] of Object.entries(parsedData.e)) {
      const timeOffsetsByType = {};
      let hasOffsets = false;
      for (const [eventType, offsets] of Object.entries(value.to)) {
        let globalOffset = originStamp;
        const timeOffsets = new Int32Array(MAX_EVENTS_PER_EVENT_TYPE);
        let i = 0;
        let accumulatedOffset = 0;
        for (const offset of offsets.split(",")) {
          if (i >= MAX_EVENTS_PER_EVENT_TYPE) {
            break;
          }
          const offsetInt = Number.parseInt(offset, 36);
          globalOffset += offsetInt;
          const eventAge = now - globalOffset;
          if (eventAge > MAX_WINDOW_SIZE_IN_MINUTES || eventAge < 0) {
            debug(`${hashId2}:${eventType}:${offsetInt} event age is ${eventAge}, drop`);
            accumulatedOffset += offsetInt;
          } else {
            if (originRebaseRequired && i == 0 && (offsetInt < gsOffset || gsOffset == 0)) {
              gsOffset = offsetInt + accumulatedOffset;
            }
            debug(`${hashId2}:${eventType}:${offsetInt} event age is ${eventAge}, keep`);
            timeOffsets[i] = offsetInt + accumulatedOffset;
            accumulatedOffset = 0;
            i++;
          }
        }
        const arr = Array.from(timeOffsets.subarray(0, i));
        if (arr.length > 0) {
          hasOffsets = true;
          eventArrays.push(arr);
          Object.assign(timeOffsetsByType, { [eventType]: arr });
        }
      }
      if (hasOffsets) {
        hasEvents = true;
        events[hashId2] = { timeOffsetsByType };
      }
    }
    if (originRebaseRequired) {
      for (const arr of eventArrays) {
        arr[0] = arr[0] - gsOffset;
      }
      originStamp = originStamp + gsOffset;
      debug(`originStamp after rebase is ${originStamp}, used global smallest offset is ${gsOffset}`);
    }
    if (!hasEvents) {
      return null;
    }
    decodedData["originStamp"] = originStamp;
    decodedData["events"] = events;
    decodedData["v"] = parsedData.v;
    return decodedData;
  };
  var FrequencyEventTypeMap = {
    close_click: 1,
    visible_impression: 2
  };
  var validEventTypeValues = Object.values(FrequencyEventTypeMap);
  var stringToFrequencyEventType = (eventType) => {
    const typeNumber = parseInt(eventType, 10);
    if (!isNaN(typeNumber)) {
      return typeNumber;
    }
    return FrequencyEventTypeMap[eventType] || 0;
  };
  var isValidFrequencyEventType = (eventType) => validEventTypeValues.includes(eventType);
  var appendEvent = (data, experienceActionId, eventTypeRaw, aid, debug) => {
    var _a, _b;
    let eventType = eventTypeRaw;
    if (typeof eventTypeRaw !== "number") {
      eventType = stringToFrequencyEventType(eventTypeRaw);
    }
    if (!isValidFrequencyEventType(eventType)) {
      debug(`eventType: "${eventTypeRaw}" is unknown`);
      return "";
    }
    const hashId2 = hashId(experienceActionId);
    let runtimeData = null;
    try {
      runtimeData = data ? decode3(data, aid, debug) : null;
    } catch (e) {
      debug("Decode Error: " + e.message);
    }
    if (runtimeData === null) {
      return encode({
        originStamp: nowInMinutes(),
        events: {
          [hashId2]: {
            timeOffsetsByType: {
              [eventType]: [0]
            }
          }
        }
      }, aid);
    }
    const bucket = ((_a = runtimeData.events[hashId2]) == null ? void 0 : _a.timeOffsetsByType[eventType]) || null;
    if (bucket == null) {
      if (Object.keys(runtimeData.events).length >= MAX_BUCKETS_PER_COOKIE) {
        console.warn(`${MAX_BUCKETS_PER_COOKIE} is max frequency actions count, events from ${experienceActionId} won't be recorded`);
        return encode(runtimeData, aid);
      }
      runtimeData.events[hashId2] = __spreadProps(__spreadValues({}, runtimeData.events[hashId2]), {
        timeOffsetsByType: __spreadProps(__spreadValues({}, (_b = runtimeData.events[hashId2]) == null ? void 0 : _b.timeOffsetsByType), {
          [eventType]: [nowInMinutes() - runtimeData.originStamp]
        })
      });
      return encode(runtimeData, aid);
    }
    const offsetSum = bucket.reduce((acc, x) => acc + x, 0);
    if (bucket.length >= MAX_EVENTS_PER_EVENT_TYPE) {
      const shiftedOffset = bucket.shift() || 0;
      bucket[0] += shiftedOffset;
    }
    const offset = nowInMinutes() - runtimeData.originStamp - offsetSum;
    bucket.push(offset < 0 ? 0 : offset);
    return encode(runtimeData, aid);
  };

  // ../src/lib/frequency-capping/pcfe.migration.ts
  var getAid = () => pn.aid;
  var breakForEach = (arr, cb) => {
    for (let i = 0; i < arr.length; i++) {
      if (!cb(arr[i])) {
        return false;
      }
    }
    return true;
  };
  var readAllPcfeCookies = () => {
    const decode4 = (s) => {
      const res = s.replace(/\+/g, " ").replace(/^\s+|\s+$/g, "");
      try {
        return decodeURIComponent(res);
      } catch (e) {
        return res;
      }
    };
    return document.cookie.split(";").map((i) => {
      const [name3, value] = i.split("=");
      return decode4(name3) === COOKIE_NAME ? decode4(value) : null;
    }).filter((i) => !!i);
  };
  var getAllPossiblePaths = () => {
    return location.pathname.replace(/\/[^\/]+$/, "").split("/").map((i) => i.trim()).filter((i) => !!i).reduce((res, path, index) => {
      if (!index) {
        res.push(`/${path}`);
      } else {
        res.push(`${res[res.length - 1]}/${path}`);
      }
      return res;
    }, ["/"]).reverse();
  };
  var convertTimeOffsetList = (data, cb) => {
    const result = __spreadProps(__spreadValues({}, data), {
      events: __spreadValues({}, data.events)
    });
    Object.entries(data.events).forEach(([hashId2, events]) => {
      Object.entries(events.timeOffsetsByType).forEach(([eventTypeRaw, offsetList]) => {
        const eventType = eventTypeRaw;
        const newOffsetList = cb(offsetList.slice(), eventType, hashId2);
        if (newOffsetList) {
          result.events[hashId2] = {
            timeOffsetsByType: __spreadProps(__spreadValues({}, result.events[hashId2].timeOffsetsByType), {
              [eventType]: newOffsetList
            })
          };
        }
      });
    });
    return result;
  };
  var offsetToAbsoluteTime = (data) => {
    let accOffset = data.originStamp;
    const result = convertTimeOffsetList(data, (offsetList) => offsetList.map((offset) => {
      accOffset += offset;
      return accOffset;
    }));
    result.originStamp = 0;
    return result;
  };
  var absoluteToOffsetTime = (data) => {
    let originTimeStamp = Infinity;
    let currentOriginTimeStamp = 0;
    const sortedData = convertTimeOffsetList(data, (offsetList) => {
      const resultList = offsetList.sort((a, b) => a - b);
      if (resultList.length > MAX_EVENTS_PER_EVENT_TYPE) {
        const cutLength = resultList.length - MAX_EVENTS_PER_EVENT_TYPE;
        resultList.splice(0, cutLength);
      }
      originTimeStamp = Math.min(originTimeStamp, resultList[0]);
      return resultList;
    });
    currentOriginTimeStamp = originTimeStamp;
    const result = convertTimeOffsetList(sortedData, (offsetList) => {
      return offsetList.map((offset) => {
        const result2 = offset - currentOriginTimeStamp;
        currentOriginTimeStamp = offset;
        return result2;
      });
    });
    result.originStamp = originTimeStamp;
    return result;
  };
  var migration = (domains, debugFn) => {
    if (tp.cookieDomain && tp.cookiePath) {
      return null;
    }
    const expires = new Date();
    expires.setSeconds(expires.getSeconds() + 30);
    const options = {
      expires,
      domain: tp.cookieDomain || TOP_LEVEL_DOMAIN,
      path: tp.cookiePath || "/"
    };
    const allRawValues = readAllPcfeCookies();
    const cacheDecodedValues = /* @__PURE__ */ new Map();
    let possiblePaths = ["", ...getAllPossiblePaths()];
    let possibleDomains = ["", ...domains.slice(0, domains.length)];
    let priorityValue = null;
    if (tp.cookiePath) {
      possiblePaths = possiblePaths.filter((path) => !path || path.length - tp.cookiePath.length >= -1);
    }
    if (tp.cookieDomain) {
      possibleDomains = possibleDomains.filter((domain) => !domain || domain.length - tp.cookieDomain.length >= -1);
    }
    breakForEach(possibleDomains, (currentDomain) => breakForEach(possiblePaths, (currentPath) => {
      options.domain = currentDomain;
      options.path = currentPath;
      debugFn(`remove cookie: ${JSON.stringify(options)}`);
      dist_exports.cookie.remove(COOKIE_NAME, options);
      const currentValue = dist_exports.cookie.get(COOKIE_NAME);
      if (!currentValue) {
        return false;
      }
      if (currentValue) {
        let decoded = cacheDecodedValues.get(currentValue) || null;
        if (!cacheDecodedValues.has(currentValue)) {
          try {
            decoded = decode3(currentValue, getAid(), debugFn);
            cacheDecodedValues.set(currentValue, decoded);
          } catch (e) {
          }
        }
        if (decoded == null ? void 0 : decoded.v) {
          priorityValue = offsetToAbsoluteTime(decoded);
          return false;
        }
      }
      return true;
    }));
    const restValues = readAllPcfeCookies();
    const valuesToMerge = allRawValues.slice(0, allRawValues.length - restValues.length);
    const deprecatedValues = [];
    valuesToMerge.forEach((rawValue) => {
      if (cacheDecodedValues.has(rawValue)) {
        deprecatedValues.push(offsetToAbsoluteTime(cacheDecodedValues.get(rawValue)));
      }
      try {
        const decoded = decode3(rawValue, getAid(), debugFn);
        if (decoded) {
          deprecatedValues.push(offsetToAbsoluteTime(decoded));
        }
      } catch (e) {
      }
    });
    if (!deprecatedValues.length || deprecatedValues.length === 1 && !priorityValue) {
      return null;
    }
    deprecatedValues.forEach((currentData) => {
      if (!priorityValue) {
        priorityValue = currentData;
        return;
      }
      convertTimeOffsetList(currentData, (offsetList, eventType, hashId2) => {
        const priorityActionBucket = priorityValue.events[hashId2];
        if (!priorityActionBucket) {
          if (Object.keys(priorityValue.events).length >= MAX_BUCKETS_PER_COOKIE) {
            debugFn(`Frequency action with hashId "${hashId2}" was skipped when merging legacy values`);
            return;
          }
          priorityValue.events[hashId2] = currentData.events[hashId2];
          return;
        }
        const currentBucket = priorityActionBucket.timeOffsetsByType[eventType];
        if (!currentBucket) {
          priorityActionBucket.timeOffsetsByType[eventType] = offsetList;
        } else {
          debugFn(`Frequency action with hashId "${hashId2}" and eventType "${eventType}" was skipped when merging legacy values`);
          return;
        }
      });
    });
    return absoluteToOffsetTime(priorityValue);
  };

  // ../src/lib/frequency-capping/pcfe.ts
  var PianoFrequencyEvent = "piano_frequency_event";
  var onGlobalPianoFrequencyEvent = (onEvent) => {
    window.addEventListener("message", (msg) => {
      try {
        const data = JSON.parse(msg.data);
        if ((data == null ? void 0 : data.event_name) === PianoFrequencyEvent) {
          onEvent(data);
        }
      } catch (e) {
      }
    });
  };
  var registerFrequencyCb = (() => {
    let rootRegisterCBInted = false;
    let eventsList = {};
    const onEvent = (params) => {
      var _a;
      const { experience_Id, experience_action_Id } = params;
      const cb = (_a = eventsList[experience_Id]) == null ? void 0 : _a[experience_action_Id];
      if (cb) {
        cb(params);
      }
    };
    const rootRegister = (expId, moduleId, cb) => {
      if (!rootRegisterCBInted) {
        pn.offer.registerCallback(PianoFrequencyEvent, onEvent);
        pn.template.registerCallback(PianoFrequencyEvent, onEvent);
        onGlobalPianoFrequencyEvent(onEvent);
      }
      rootRegisterCBInted = true;
      if (!eventsList[expId]) {
        eventsList[expId] = {};
      }
      eventsList[expId][moduleId] = cb;
    };
    return {
      on: rootRegister,
      off: () => eventsList = {}
    };
  })();
  var frequencyEvent = (container = pn.container) => {
    const utils = container.resolve("util");
    const options = {
      expires: COOKIE_EXPIRATION,
      domain: TOP_LEVEL_DOMAIN,
      path: "/"
    };
    const debugFn = (msg) => {
      utils.debug(`PCFE: ` + msg);
    };
    const getAid2 = () => pn.aid;
    const getFromCookie = () => utils.__protected__.getCookie(COOKIE_NAME);
    const setToCookie = (value) => {
      if (!value) {
        return;
      }
      if (pn.cookieDomain) {
        options.domain = pn.cookieDomain;
      }
      if (pn.cookiePath) {
        options.path = pn.cookiePath;
      }
      utils.__protected__.setCookieConsent("composer", COOKIE_NAME, value, options);
    };
    const removeCookie = () => {
      if (pn.cookieDomain) {
        options.domain = pn.cookieDomain;
      }
      if (pn.cookiePath) {
        options.path = pn.cookiePath;
      }
      utils.deleteCookie(COOKIE_NAME, options.domain, options.path);
    };
    const get = () => {
      const rawCookieValue = getFromCookie();
      if (!rawCookieValue) {
        return null;
      }
      let decodedValue = null;
      try {
        decodedValue = decode3(rawCookieValue, getAid2(), debugFn);
        if (decodedValue && !decodedValue.v) {
          debugFn("migrate pcfe value");
          decodedValue = migration(utils.getPossibleCookieDomains(), debugFn) || decodedValue;
          decodedValue.v = PCFE_VERSION;
        }
      } catch (e) {
        debugFn("Decode Error: " + e.message);
        removeCookie();
        return null;
      }
      if (!decodedValue) {
        removeCookie();
        return null;
      }
      const encodedValue = encode(decodedValue, getAid2());
      setToCookie(encodedValue);
      return encodedValue;
    };
    const applyToParams = (params) => {
      const data = get();
      if (data) {
        params["frequency"] = data;
      }
      return params;
    };
    const registerEvent = (data) => {
      registerFrequencyCb.off();
      data.result.events.forEach((event) => {
        var _a, _b, _c, _d;
        if ((_b = (_a = event.eventExecutionContext) == null ? void 0 : _a.frequency) == null ? void 0 : _b.track) {
          const expId = ((_c = event.eventExecutionContext) == null ? void 0 : _c.experienceId) || "noId";
          const moduleId = ((_d = event.eventModuleParams) == null ? void 0 : _d.moduleId) || "noId";
          registerFrequencyCb.on(expId, moduleId, (params) => {
            const newAppendedValue = appendEvent(getFromCookie(), params.experience_action_Id, params.event_type, getAid2(), debugFn);
            setToCookie(newAppendedValue);
          });
        }
      });
    };
    return {
      __protected__: {
        applyToParams,
        registerEvent
      }
    };
  };
  pn.container.register("frequencyEvent", {
    useValue: frequencyEvent()
  });
  pn.frequencyEvent = pn.container.resolve("frequencyEvent");

  // ../src/lib/composerControlPolicy.ts
  var LS_KEY = "composer-control-policy";
  var HEADER_NAME = "composer-request-control-policy";
  var TTL = 15;
  var NameListPolicy = ["deny-fbia", "deny-web", "deny-all", "deny-template-interaction"];
  var generateTTl = (ttl = TTL) => {
    return Math.ceil(Date.now() / 1e3) + ttl * 60;
  };
  var isDeny = (ttl) => !ttl ? false : Math.ceil(Date.now() / 1e3) <= ttl;
  var anyToPolicy = (value) => {
    let result = {};
    let json = value;
    if (value) {
      if (typeof value !== "object") {
        try {
          json = JSON.parse(value);
        } catch (e) {
        }
      }
      result = NameListPolicy.reduce((res, prop) => {
        if (json[prop]) {
          res[prop] = json[prop];
        }
        return res;
      }, {});
    }
    return result;
  };
  var checkExpires = (value) => {
    let needToUpdate = false;
    const newValue = Object.keys(value).reduce((res, prop) => {
      if (isDeny(value[prop])) {
        res[prop] = value[prop];
      } else {
        needToUpdate = true;
      }
      return res;
    }, {});
    return {
      needToRemove: !Object.keys(newValue).length,
      needToUpdate,
      newValue
    };
  };
  var composerControlPolicy = (container = pn.container) => {
    const localStorage4 = container.resolve("localStorage");
    let cachedValue = anyToPolicy(localStorage4.get(LS_KEY));
    const checkLS = () => {
      cachedValue = anyToPolicy(localStorage4.get(LS_KEY));
    };
    const localStorageCheckTTl = (setValue) => {
      const { needToUpdate, needToRemove, newValue } = checkExpires(cachedValue);
      cachedValue = __spreadValues(__spreadValues({}, newValue), setValue);
      if (needToUpdate || setValue) {
        localStorage4.set(LS_KEY, JSON.stringify(cachedValue));
      }
      if (!setValue && needToRemove) {
        localStorage4.remove(LS_KEY);
      }
    };
    localStorageCheckTTl();
    const getFlag = (name3) => {
      localStorageCheckTTl();
      return !!cachedValue["deny-all"] || !!cachedValue[name3];
    };
    const setPolicyByRequest = (req) => {
      if (req.getAllResponseHeaders().includes(HEADER_NAME)) {
        const name3 = req.getResponseHeader(HEADER_NAME);
        if (name3) {
          localStorageCheckTTl({ [name3]: generateTTl() });
        }
      }
    };
    return {
      get denyFbia() {
        return getFlag("deny-fbia");
      },
      get denyWeb() {
        return getFlag("deny-web");
      },
      get denyAll() {
        return getFlag("deny-all");
      },
      get denyTI() {
        return getFlag("deny-template-interaction");
      },
      __private__: {
        setPolicyByRequest,
        checkLS
      }
    };
  };
  pn.container.register("composerControlPolicy", {
    useValue: composerControlPolicy()
  });
  pn.composerControlPolicy = pn.container.resolve("composerControlPolicy");

  // ../src/lib/api.ts
  var api = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const ajax3 = pn.container.resolve("ajax");
    const name3 = "api";
    let umc;
    const tpAccessTokenV2 = util2.findCookieByName(/__TP_*/);
    if (typeof window._tpm !== "undefined" && typeof window._tpm["paywallID"] !== "undefined") {
      const paywallID = window._tpm["paywallID"];
      umc = util2.__protected__.getCookie("umc_" + paywallID);
    }
    const getEndpoint = () => {
      return pn.getApiEndpoint();
    };
    const getCallParams = (params, userProvider) => {
      const tac = util2.__protected__.getCookie("__tac");
      if (typeof params === "undefined" || !params) {
        params = {};
      }
      params["aid"] = pn.aid;
      if (umc) {
        params["umc"] = umc;
      }
      if (tpAccessTokenV2) {
        params["tp_access_token_v2"] = tpAccessTokenV2;
      }
      if (tac) {
        params["tac"] = tac;
      }
      if (!params["user_provider"] && userProvider && !userProvider.isv) {
        params["user_provider"] = userProvider.getName();
      }
      if ((typeof params["user_token"] === "undefined" || !params["user_token"]) && userProvider && !userProvider.isv) {
        params["user_token"] = typeof userProvider.getToken() === "string" ? userProvider.getToken() : "";
      }
      const affiliateToken = util2.getAffiliateToken(pn.affiliateTokenName);
      if (affiliateToken) {
        params["affiliate_token"] = affiliateToken;
      }
    };
    const getAccessEndpointMockResponse = (method) => {
      var ACCESS_LIST_METHOD = "/access/list";
      var ACCESS_CHECK_METHOD = "/access/check";
      var USER_ACCESS_LIST_METHOD = "/user/access/list";
      var USER_ACCESS_CHECK_METHOD = "/user/access/check.jwt";
      var isAccessMethod = method === ACCESS_LIST_METHOD || method === ACCESS_CHECK_METHOD || method === USER_ACCESS_LIST_METHOD || method === USER_ACCESS_CHECK_METHOD;
      if (!isAccessMethod) {
        return null;
      }
      var currentTimestamp = Math.floor(new Date().getTime() / 1e3);
      var accessListMockResponse = {
        code: 0,
        count: 0,
        data: [],
        limit: 0,
        offset: 0,
        total: 0,
        ts: currentTimestamp
      };
      var accessCheckMockResponse = {
        "code": 0,
        "ts": 1548942314,
        "access": {
          "access_id": null,
          "parent_access_id": null,
          "granted": false,
          "resource": null,
          "user": null,
          "expire_date": currentTimestamp
        }
      };
      var accessUserkMockResponse = {
        "code": 403,
        "ts": currentTimestamp,
        "message": "User doesn't have permission to call this method"
      };
      if (method === ACCESS_LIST_METHOD) {
        return accessListMockResponse;
      }
      if (method === ACCESS_CHECK_METHOD) {
        return accessCheckMockResponse;
      }
      return accessUserkMockResponse;
    };
    const checkDoubleOptIn = (method) => {
      var ACCESS_CHECK_METHOD = "/access/check";
      if (!pn.isDoubleOptInCheckOnAccessCheckEnabled) {
        return;
      }
      if (method === ACCESS_CHECK_METHOD) {
        pn.doubleOptIn.check();
      }
    };
    function callApi(method, params, callback, endpoint, sync, httpMethod) {
      util2.debug("Calling API method: " + method);
      var url;
      if (typeof endpoint !== "undefined") {
        url = endpoint;
      } else {
        url = getEndpoint();
      }
      url = url + method;
      if (typeof params === "undefined" || !params) {
        params = {};
      }
      var tbc = util2.getTbcCookie();
      if (tbc) {
        params["tbc"] = tbc;
      }
      let userProvider;
      if (pn.user) {
        userProvider = pn.user.getProvider();
      }
      getCallParams(params, userProvider);
      var tpCallback;
      tpCallback = (json) => {
        util2.debug("API Response", json);
        if (json) {
          util2.setTbcCookieFromResponse(json);
          util2.setAppTimezoneOffsetFromResponse(json);
          util2.setCurrentDomainFromResponse(json);
        }
        if (typeof callback !== "undefined") {
          callback(json);
        }
      };
      var accessEndpointMockResponse = getAccessEndpointMockResponse(method);
      if (accessEndpointMockResponse !== null && !pn.user.getProvider().isUserValid()) {
        tpCallback(accessEndpointMockResponse);
        return;
      }
      checkDoubleOptIn(method);
      const aid = params.aid;
      const data = __spreadValues({}, params);
      delete data.aid;
      const requestParams = {
        type: httpMethod != null ? httpMethod : "POST",
        dataType: "json",
        data
      };
      url += "?aid=" + aid;
      requestParams.url = url;
      if (sync) {
        requestParams.async = false;
      }
      requestParams.success = (data2) => {
        tpCallback(data2);
      };
      requestParams.error = (err) => {
        var response = {
          code: 503,
          message: "Error: Received error when requesting API response from URL: " + url
        };
        util2.log(response.message);
        tpCallback(response);
      };
      ajax3.request(requestParams);
    }
    ;
    return {
      name: name3,
      callApi: function(method, params, callback, endpoint, sync, httpMethod) {
        return callApi(method, params, callback, endpoint, sync, httpMethod);
      },
      getEndpoint: function() {
        return getEndpoint();
      },
      getCallParams: function(params, userProvider) {
        return getCallParams(params, userProvider);
      }
    };
  })();
  pn.container.register("api", {
    useValue: api
  });
  pn.api = pn.container.resolve("api");

  // ../src/lib/postmessage.ts
  var postmessage = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const name3 = "postmessage";
    const iframesOptions = {};
    const iframes = {};
    let stackMessage = [];
    const subscribers = {};
    const postmessage2 = (($) => {
      var g, d, j = 1, a, b = window, f2 = false, h = "postMessage", e = "addEventListener", c;
      const i = b[h];
      $[h] = (k, l, m) => {
        if (!l) {
          return;
        }
        k = typeof k === "string" ? k : jqUtils2.param(k);
        m = m || parent;
        if (i) {
          m[h](k, l.replace(/([^:]+:\/\/[^\/]+).*/, "$1"));
        } else {
          if (l) {
            m.location = l.replace(/#.*$/, "") + "#" + +new Date() + j++ + "&" + k;
          }
        }
      };
      $.receiveMessage = c = (l, m, k) => {
        if (i) {
          if (l) {
            a && c();
            a = (n) => {
              if (typeof m === "string" && n.origin !== m || jqUtils2.isFunction(m) && m(n.origin) === f2) {
                return f2;
              }
              l(n);
            };
          }
          if (b[e]) {
            b[l ? e : "removeEventListener"]("message", a, f2);
          } else {
            b[l ? "attachEvent" : "detachEvent"]("onmessage", a);
          }
        } else {
          g && clearInterval(g);
          g = null;
          if (l) {
            k = typeof m === "number" ? m : typeof k === "number" ? k : 100;
            g = setInterval(() => {
              var o = document.location.hash, n = /^#?\d+&/;
              if (o !== d && n.test(o)) {
                d = o;
                l({ data: o.replace(n, "") });
              }
            }, k);
          }
        }
      };
      return $;
    })({});
    const deparam = (params, coerce) => {
      var obj = {}, coerce_types = { "true": true, "false": false, "null": null };
      params.replace(/\+/g, " ").split("&").forEach((j, v) => {
        var param2 = v.split("=");
        var key2 = "";
        try {
          key2 = decodeURIComponent(param2[0]);
        } catch (e) {
          return;
        }
        var val, cur = obj, i = 0, keys2 = key2.split("]["), keys_last = keys2.length - 1;
        if (/\[/.test(keys2[0]) && /\]$/.test(keys2[keys_last])) {
          keys2[keys_last] = keys2[keys_last].replace(/\]$/, "");
          keys2 = keys2.shift().split("[").concat(keys2);
          keys_last = keys2.length - 1;
        } else {
          keys_last = 0;
        }
        if (param2.length === 2) {
          val = decodeURIComponent(param2[1]);
          if (coerce) {
            val = val && !isNaN(val) ? +val : val === "undefined" ? void 0 : coerce_types[val] !== void 0 ? coerce_types[val] : val;
          }
          if (keys_last) {
            for (; i <= keys_last; i++) {
              key2 = keys2[i] === "" ? cur.length : keys2[i];
              cur = cur[key2] = i < keys_last ? cur[key2] || (keys2[i + 1] && isNaN(keys2[i + 1]) ? {} : []) : val;
            }
          } else {
            if (Array.isArray(obj[key2])) {
              obj[key2].push(val);
            } else if (obj[key2] !== void 0) {
              obj[key2] = [obj[key2], val];
            } else {
              obj[key2] = val;
            }
          }
        } else if (key2) {
          obj[key2] = coerce ? void 0 : "";
        }
      });
      return obj;
    };
    function _onLoad(recipient) {
      return () => {
        var recipentMessages = stackMessage.filter(function(message) {
          return message.recipient === recipient;
        });
        stackMessage = stackMessage.filter(function(message) {
          return message.recipient !== recipient;
        });
        for (var i = recipentMessages.length; i--; ) {
          var tempMessage = recipentMessages.pop();
          _postMessageSend(tempMessage.event, tempMessage.params, tempMessage.recipient);
        }
      };
    }
    ;
    const send = (event, params, recipient) => {
      if (recipient && _isParent(recipient) && !(recipient in iframes)) {
        util2.error("Cannot send message to unmanaged iframe: " + recipient);
        return;
      }
      if (recipient && iframes[recipient].element) {
        if (iframes[recipient].config.displayMode === "popup" || iframes[recipient].config.displayMode !== "popup" && iframes[recipient].element.contentWindow) {
          _postMessageSend(event, params, recipient);
        } else {
          stackMessage.push({
            event,
            params,
            recipient
          });
          jqUtils2.on(iframes[recipient].element, "load", _onLoad(recipient));
        }
      }
    };
    const isIframeManaged = (iframeId) => {
      var iframe = iframes[iframeId];
      return iframe && _isParent(iframe);
    };
    const _postMessageSend = (event, params, recipient) => {
      var contentWindow;
      var postMessageParams = {};
      var source = iframes[recipient].config.displayMode === "popup" ? "opener" : "parent";
      postMessageParams.sender = _isParent(recipient) ? source : recipient;
      postMessageParams.recipient = _isParent(recipient) ? recipient : source;
      postMessageParams.event = event;
      postMessageParams.params = params;
      var element = iframes[recipient].element;
      if (iframes[recipient].config.displayMode === "popup") {
        contentWindow = iframes[recipient].container;
      } else if (element && element.contentWindow) {
        contentWindow = element.contentWindow;
      } else if (element && element.toString() === "[object Window]") {
        contentWindow = iframes[recipient].element;
      } else {
        contentWindow = window[source];
      }
      postmessage2.postMessage(JSON.stringify(postMessageParams), iframesOptions[recipient].postMessageUrl, contentWindow);
    };
    const _handleKeystroke = (event) => {
      if (event.keyCode === 27 && _isIframe(event.data.iframeId) && _isIframeClosable(event.data.iframeId)) {
        send("close", null, event.data.iframeId);
      }
    };
    function init(config, initParams) {
      _addIframe(config.iframe);
      if (!config.postMessageUrl) {
        util2.error("Must specify postMessageUrl to send and receive postMessages");
        return;
      }
      if (config.iframe.iframeId) {
        if (!iframesOptions[config.iframe.iframeId].initializedKeystrokeHandler) {
          iframesOptions[config.iframe.iframeId].initializedKeystrokeHandler = true;
          jqUtils2.delegate(window, `#${config.iframe.iframeId}`, "keyup", (event) => _handleKeystroke(event));
        }
        iframesOptions[config.iframe.iframeId].postMessageUrl = config.postMessageUrl;
        if (!iframesOptions[config.iframe.iframeId].initializedListener) {
          iframesOptions[config.iframe.iframeId].initializedListener = true;
          iframesOptions[config.iframe.iframeId].receive = config.receive;
          postmessage2.receiveMessage(_processMessage);
        }
        iframesOptions[config.iframe.iframeId].iframeConfig = config;
        var params = initParams || {};
        params.height = document.documentElement.offsetHeight;
        params.width = config.iframeParams && config.iframeParams.width ? config.iframeParams.width : document.documentElement.offsetWidth;
        send("loaded", params, config.iframe.iframeId);
      }
    }
    ;
    const _addIframe = (iframe) => {
      iframesOptions[iframe.iframeId] = {
        iframeConfig: null,
        receive: null,
        postMessageUrl: null,
        initializedListener: false,
        initializedKeystrokeHandler: false
      };
      iframes[iframe.iframeId] = iframe;
    };
    const removeIframe = (iframeId) => {
      delete iframes[iframeId];
      delete iframesOptions[iframeId];
    };
    const _isIframe = (recipient) => {
      return iframesOptions[recipient] && iframesOptions[recipient].iframeConfig ? true : false;
    };
    const _isParent = (recipient) => {
      return iframesOptions[recipient] && iframesOptions[recipient].iframeConfig ? false : true;
    };
    const _isIframeClosable = (iframeId) => {
      const iframeConfig = _getIframeConfig(iframeId);
      return iframeConfig.showCloseButton && iframeConfig.displayMode !== "inline";
    };
    const _getIframeConfig = (iframeId) => {
      var iframeOption = iframesOptions[iframeId];
      var iframe = iframeOption && iframeOption.iframeConfig && iframeOption.iframeConfig.iframe;
      return iframe && iframe.config;
    };
    function _processMessage(event) {
      var postMessageParams;
      var usingCurtain = false;
      var iframe;
      try {
        postMessageParams = JSON.parse(event.data);
      } catch (err) {
        try {
          postMessageParams = deparam(event.data);
          if (postMessageParams) {
            usingCurtain = true;
          }
        } catch (err2) {
          util2.debug("Error parsing postMessage: " + event.data);
          return;
        }
      }
      notifySubscribers(postMessageParams);
      if (usingCurtain) {
        var found;
        for (var iframeId in iframes) {
          iframe = iframes[iframeId];
          if (!iframe.config.isCurtain) {
            continue;
          }
          found = true;
          if (iframe.config.parent && iframesOptions[iframe.config.parent].receive) {
            iframesOptions[iframe.config.parent].receive(postMessageParams);
          }
          if (iframesOptions[iframeId].receive) {
            iframesOptions[iframeId].receive(postMessageParams);
          }
        }
        if (!found) {
          util2.debug("Error parsing postMessage: " + event.data);
        }
        return;
      }
      if (_isParent(postMessageParams.sender) && (!postMessageParams.sender || !(postMessageParams.sender in iframes))) {
        util2.debug("Received message from unmanaged iframe: " + postMessageParams.sender);
        return;
      }
      util2.debug((_isIframe(postMessageParams.sender) ? "iframe(" + postMessageParams.recipient : "the parent") + ") received event '" + postMessageParams.event + "' from iframe(" + postMessageParams.sender + ")", postMessageParams);
      if (iframesOptions[postMessageParams.sender].receive) {
        iframesOptions[postMessageParams.sender].receive(postMessageParams);
      }
      if (iframes[postMessageParams.sender]) {
        iframe = iframes[postMessageParams.sender];
        if (iframe.config.parent && iframesOptions[iframe.config.parent].receive) {
          var evFromChildrenToParent = true;
          postMessageParams.sender = iframe.config.parent;
          iframesOptions[iframe.config.parent].receive(postMessageParams, evFromChildrenToParent);
        }
      }
    }
    ;
    const notifySubscribers = (postMessageParams) => {
      var callbacks = subscribers[postMessageParams.event] || [];
      callbacks.forEach(function(callback) {
        callback(postMessageParams);
      });
    };
    const broadcast = (event, params, exceptIframeId) => {
      for (var iframeId in iframes) {
        if (iframes.hasOwnProperty(iframeId) && iframeId === exceptIframeId) {
          continue;
        }
        send(event, params, iframeId);
      }
    };
    const subscribe = (eventName, callback) => {
      subscribers[eventName] = subscribers[eventName] || [];
      subscribers[eventName].push(callback);
    };
    const unsubscribe = (eventName, callback) => {
      if (!(subscribers[eventName] instanceof Array)) {
        return;
      }
      subscribers[eventName] = subscribers[eventName].filter(function(_callback) {
        return _callback !== callback;
      });
    };
    return {
      name: name3,
      init,
      __protected__: {
        isIframeManaged
      },
      send,
      removeIframe,
      broadcast,
      subscribe,
      unsubscribe
    };
  })();
  pn.container.register("postmessage", {
    useValue: postmessage
  });
  pn.postmessage = pn.container.resolve("postmessage");

  // ../src/lib/eventUtils.ts
  var eventUtils = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const postmessage2 = pn.container.resolve("postmessage");
    const name3 = "eventUtils";
    const createEventManager = (events) => {
      var callbacks = {};
      var i;
      for (i = 0; i < events.length; i++) {
        callbacks[events[i]] = [];
      }
      var me = {
        addEvent: function(event) {
          if (callbacks[event] === void 0) {
            callbacks[event] = [];
          }
        },
        hasIframeCallback: function(event, iframeId) {
          var result, callback, i2;
          if (callbacks[event] && callbacks[event].length > 0) {
            for (i2 = 0, result = null, callback = null; i2 < callbacks[event].length; ++i2) {
              callback = callbacks[event][i2];
              if (typeof callback === "object") {
                if (iframeId === callback.iframeId) {
                  return true;
                }
              }
            }
          }
          return false;
        },
        hasCallback: function(event) {
          return callbacks[event] && callbacks[event].length > 0;
        },
        registerCallback: (p1, p2) => {
          var event = typeof p1 === "string" ? p1 : null;
          var config = typeof p1 === "object" ? p1 : null;
          var callback, frameId, cb;
          if (event) {
            callback = typeof p2 === "function" ? p2 : null;
            if (callbacks[event] === void 0) {
              return;
            }
            callbacks[event].push(callback);
          }
          if (config) {
            frameId = typeof p2 === "string" ? p2 : null;
            for (cb in callbacks) {
              if (typeof config[cb] === "function") {
                util2.debug("Registering " + cb + " callback for iframe " + frameId);
                callbacks[cb].push({
                  iframeId: frameId,
                  callback: config[cb]
                });
              }
            }
          }
        },
        fireCallbacks: function(event, object, iframeId, invokeCallbacksOnFire) {
          return me.fire(iframeId, event, invokeCallbacksOnFire, object);
        },
        fire: (iframeId, event, invokeCallbacksOnFire, object, p1, p2) => {
          let result;
          let callback;
          let i2;
          let callbackFound = false;
          let params = [];
          object && params.push(object);
          p1 && params.push(p1);
          p2 && params.push(p2);
          var hasResultCallback = object && object.resultCallbackId;
          var fire = (obj) => {
            if (invokeCallbacksOnFire) {
              try {
                if (params.length > 1) {
                  return callback.apply(null, params);
                } else {
                  if (event === "loginRequired") {
                    var term = jqUtils2.deepExtend({}, obj.term);
                    delete obj.term;
                    return callback(obj, iframeId, term);
                  } else {
                    return callback(obj, iframeId);
                  }
                }
              } catch (e) {
                util2.debug(e);
              }
            }
          };
          if (typeof callbacks[event] === "undefined") {
            return;
          }
          for (i2 = 0, result = null, callback = null; i2 < callbacks[event].length; ++i2) {
            callback = callbacks[event][i2];
            if (typeof callback === "function") {
              util2.debug("firing callback for event '" + event + "' from iframe(" + iframeId + ")");
              result = fire(object);
              callbackFound = true;
            } else if (typeof callback === "object") {
              if (iframeId === callback.iframeId) {
                util2.debug("firing callback for event '" + event + "' from iframe(" + iframeId + ")");
                callback = callback.callback;
                result = fire(object);
                callbackFound = true;
              } else {
                continue;
              }
            }
            if (hasResultCallback) {
              object.result = result;
              object.event = event;
              postmessage2.send("resultCallback", object, iframeId);
            }
          }
          if (!callbackFound && hasResultCallback) {
            object.callbackNotFound = true;
            object.event = event;
            postmessage2.send("resultCallback", object, iframeId);
          }
          return result;
        },
        fireCallbacksAndStopOnFirstFalse: (event, eventCondition, p1, p2, ...args) => {
          if (typeof callbacks[event] === "undefined") {
            return true;
          }
          var result = true;
          for (var i2 = 0; i2 < callbacks[event].length; i2++) {
            var callback = callbacks[event][i2];
            if (typeof callback === "function") {
              util2.debug("firing callback for event '" + event + "'");
              try {
                let params = [];
                params.push(eventCondition);
                params.push(p1);
                params.push(p2);
                params = params.concat([].slice.call(args));
                if (callback.apply(null, params) === false) {
                  util2.debug("callback for event '" + event + "' returned false");
                  result = false;
                  break;
                }
              } catch (e) {
                util2.debug("firing callback for event '" + event + "' failed", e);
              }
            }
          }
          return result;
        }
      };
      return me;
    };
    return {
      name: name3,
      createEventManager
    };
  })();
  pn.container.register("eventUtils", {
    useValue: eventUtils
  });
  pn.eventUtils = pn.container.resolve("eventUtils");

  // ../src/lib/janrain.ts
  var janrain = (() => {
    const util2 = pn.container.resolve("util");
    const api2 = pn.container.resolve("api");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const localStorage4 = pn.container.resolve("localStorage");
    const eventManager = eventUtils2.createEventManager(["userChanged", "logout"]);
    let isv = false;
    const name3 = "janrain";
    const getName = () => {
      return name3;
    };
    const getToken = () => {
      return util2.getUserTokenCookie();
    };
    const isUserValid = () => {
      var userToken = getToken();
      return typeof userToken !== "undefined" && userToken && userToken.length >= 0 ? true : false;
    };
    const onLoginSuccess = (params) => {
      util2.setAccessTokenListCookie({
        value: params.token_list,
        cookie_domain: params.cookie_domain
      }, params.user_token);
    };
    let _isJanrainConfigured = false;
    let _isJanrainLoaded = false;
    const callbackEvents = {
      onCaptureSessionCreated: []
    };
    const _config = {
      loginRequiredScreen: "signIn",
      appName: null,
      appId: null,
      clientId: null,
      settings: null,
      disableLogout: false,
      startCapture: false
    };
    const janrainScreenMap = {
      register: "traditionalRegistration",
      login: "signIn"
    };
    function init(config) {
      if (_isJanrainConfigured) {
        return;
      }
      if (!config.appName || !config.appId || !config.clientId) {
        throw "Must specify appName, appId, and clientId to initialize janrain";
      }
      for (var item in _config) {
        if (typeof config[item] !== "undefined") {
          _config[item] = config[item];
        }
      }
      if (config.settings) {
        _config.settings = config.settings;
      }
      if (config.loginRequiredScreen) {
        _config.loginRequiredScreen = config.loginRequiredScreen;
      }
      if (_config.settings) {
        if (typeof window.janrain !== "object")
          window.janrain = {};
        if (typeof window.janrain.settings !== "object")
          window.janrain.settings = {};
        const janrain2 = window.janrain;
        janrain2.settings = _config.settings;
        if (typeof window.janrain.settings.capture !== "object")
          window.janrain.settings.capture = {};
        janrain2.settings.appUrl = "https://" + _config.appName + ".rpxnow.com";
        janrain2.settings.capture.captureServer = "https://" + _config.appName + ".janraincapture.com";
        janrain2.settings.capture.appId = _config.appId;
        janrain2.settings.capture.clientId = _config.clientId;
        var scriptName = _config.appName.replace(/\./g, "-");
        var httpLoadUrl = "http://widget-cdn.rpxnow.com/load/" + scriptName;
        var httpsLoadUrl = "https://rpxnow.com/load/" + scriptName;
        var scriptUrl;
        if (util2.__protected__.isHttpsProtocol()) {
          scriptUrl = httpsLoadUrl;
        } else {
          scriptUrl = httpLoadUrl;
        }
        pn.push(["addExternalLibrary", scriptUrl, () => {
          janrain2.ready = true;
        }]);
      }
      util2.log("JANRAIN:", "start refresh user token");
      util2.startCall("refreshUserToken", 3e4);
      util2.waitCall("refreshUserToken", () => {
        util2.log("JANRAIN:", "end refresh user token");
      });
      _checkForJanrain();
      _isJanrainConfigured = true;
      pn.zIndexes = {
        backdrop: 900,
        modal: 950,
        close: 990
      };
      var onLogin = function(result) {
        util2.log("JANRAIN: onLogin");
        const janrain2 = window.janrain;
        janrain2.capture.ui.modal.close();
        processUser();
      };
      addEventHandler("onCaptureLoginSuccess", onLogin);
      addEventHandler("onCaptureRegistrationSuccess", onLogin);
    }
    ;
    function _checkForJanrain() {
      var max_tries = 100;
      var attempt = 0;
      function checkForJanrain() {
        const janrain2 = window.janrain;
        if (window.janrain && window.janrain.ready && window.janrain.capture && window.janrain.capture.ui && window.janrain.capture.ui.hasActiveSession) {
          debugAllHandlers();
          addHandlers();
          if (_config.startCapture) {
            janrain2.capture.ui.start();
          }
          _isJanrainLoaded = true;
        } else {
          if (attempt > max_tries) {
            throw "Janrain is not initialized";
          }
          attempt++;
          window.setTimeout(checkForJanrain, 100);
        }
      }
      checkForJanrain();
    }
    ;
    const getLoginRequiredScreen = (params) => {
      return params && janrainScreenMap.hasOwnProperty(params.startScreen) ? janrainScreenMap[params.startScreen] : _config.loginRequiredScreen;
    };
    function _registerCallback(name4, callback) {
      callbackEvents[name4] = [];
      callbackEvents[name4].push(callback);
    }
    ;
    function _fireCallback(name4, params) {
      if (typeof callbackEvents[name4] === "undefined" || callbackEvents[name4].length === 0) {
        return;
      }
      for (var i = 0; i < callbackEvents[name4].length; ++i) {
        callbackEvents[name4][i].apply(null, arguments);
      }
    }
    ;
    function login(callback, params) {
      if (!_isJanrainConfigured) {
        throw "Janrain is not configured";
      }
      var max_tries = 100;
      var attempt = 0;
      const signIn = () => {
        if (_isJanrainLoaded) {
          try {
            const janrain2 = window.janrain;
            janrain2.capture.ui.renderScreen(getLoginRequiredScreen(params));
            if (typeof callback === "function") {
              _registerCallback("onCaptureSessionCreated", callback);
            }
          } catch (e) {
            attempt++;
            window.setTimeout(signIn, 100);
            return;
          }
        } else {
          if (attempt > max_tries) {
            throw "Janrain is not initialized";
          }
          attempt++;
          window.setTimeout(signIn, 100);
        }
      };
      signIn();
    }
    ;
    function logout(callback) {
      if (!_isJanrainConfigured) {
        throw "Janrain is not configured";
      }
      var max_tries = 100;
      var attempt = 0;
      var activeSessionAttempt = 0;
      function waitForActiveSession() {
        if (activeSessionAttempt > max_tries) {
          callback();
          return;
        }
        if (hasActiveSession()) {
          activeSessionAttempt++;
          window.setTimeout(waitForActiveSession, 100);
        } else {
          callback();
        }
      }
      function signOut() {
        if (_isJanrainLoaded) {
          const janrain2 = window.janrain;
          janrain2.capture.ui.modal.close();
          janrain2.capture.ui.endCaptureSession();
          eventManager.fireCallbacks("logout", null, void 0, true);
          if (callback) {
            waitForActiveSession();
          }
        } else {
          if (attempt > max_tries) {
            throw "Janrain is not initialized";
          }
          attempt++;
          window.setTimeout(signOut, 100);
        }
      }
      cleanCookies();
      signOut();
    }
    ;
    const isConfigured = () => {
      return _isJanrainConfigured;
    };
    const cleanCookies = () => {
      if (!_config.disableLogout) {
        util2.setAccessTokenListCookie(void 0, void 0, true);
      }
    };
    let firstRefresh = true;
    const hasActiveSession = () => {
      const janrain2 = window.janrain;
      return janrain2 && janrain2.capture && janrain2.capture.ui && janrain2.capture.ui.hasActiveSession();
    };
    function processUser() {
      util2.log("JANRAIN:", "Processing janrain user");
      if (firstRefresh) {
        firstRefresh = false;
      } else {
        util2.startCall("refreshUserToken");
      }
      util2.log("JANRAIN:", "hasActiveSession:" + hasActiveSession());
      var janrainCaptureToken = getJanrainToken();
      if (!hasActiveSession()) {
        util2.log("JANRAIN:", "No token found.  Done processing user");
        cleanCookies();
        util2.doneCall("refreshUserToken");
        return;
      }
      if (isUserValid()) {
        util2.log("JANRAIN:", "Using __ut.  Done processing user");
        util2.doneCall("refreshUserToken");
        return;
      }
      var params = {
        janrain_capture_token: janrainCaptureToken,
        url: util2.prepareUrlParameter(window.location.href)
      };
      api2.callApi("/anon/janrain/verifyAccountInfo", params, (response) => {
        if (response && response.access) {
          try {
            util2.log("JANRAIN:", "Verify success.  Done processing user");
            util2.setAccessTokenListCookie(response.access.access_token, response.access.user_token);
            var params2 = {
              access_token: response.access.access_token,
              user_token: response.access.user_token
            };
            if (response.access.user) {
              params2.user = {
                uid: response.access.user.uid,
                email: response.access.user.email,
                firstName: response.access.user.first_name,
                lastName: response.access.user.last_name,
                valid: response.access.user.valid
              };
            }
            _fireCallback("onCaptureSessionCreated", params2);
            eventManager.fireCallbacks("userChanged", params2, void 0, true);
          } finally {
            util2.doneCall("refreshUserToken");
          }
        } else {
          util2.log("JANRAIN:", "Verify failed");
        }
      });
    }
    const getJanrainToken = () => {
      return localStorage4.get("janrainCaptureToken");
    };
    const addHandlers = () => {
      const janrain2 = window.janrain;
      janrain2.events.onProviderLogoutComplete.addHandler(() => {
        cleanCookies();
      });
      janrain2.events.onCaptureSessionEnded.addHandler((e) => {
        util2.log("JANRAIN: Events received for logout", e);
        cleanCookies();
      });
      addProcessUserHandlers();
    };
    const addProcessUserHandlers = () => {
      if (hasActiveSession()) {
        util2.log("JANRAIN:", "Found early active session via function");
        processUser();
        return;
      }
      if (!hasActiveSession() && !isUserValid() && !getJanrainToken()) {
        util2.log("JANRAIN:", "not found __ut cookie and janrain token");
        processUser();
        return;
      }
      var isCaptureFederateNoLogin = false;
      const janrain2 = window.janrain;
      janrain2.events.onCaptureSessionFound.addHandler((e) => {
        if (isJanrainSSO()) {
          if (isCaptureFederateNoLogin) {
            util2.log("JANRAIN: Events received for logged in user", e);
            processUser();
          }
        } else {
          processUser();
        }
      });
      janrain2.events.onCaptureSessionNotFound.addHandler((e) => {
        if (isJanrainSSO()) {
          if (isCaptureFederateNoLogin) {
            util2.log("JANRAIN: Events received for logged out user", e);
            processUser();
          }
        } else {
          processUser();
        }
      });
      janrain2.events.onCaptureFederateNoLogin.addHandler((result) => {
        isCaptureFederateNoLogin = result;
      });
      janrain2.events.onCaptureFederateLogin.addHandler((e) => {
        util2.log("JANRAIN: Events received for SSO login", e);
        processUser();
      });
    };
    const isJanrainSSO = () => {
      const janrain2 = window.janrain;
      return janrain2 && janrain2.settings && janrain2.settings.capture && janrain2.settings.capture.federate;
    };
    function addEventHandler(event, callback) {
      if (!_isJanrainConfigured) {
        throw "Janrain is not configured";
      }
      var max_tries = 100;
      var attempt = 0;
      function _addEventHandler() {
        const janrain2 = window.janrain;
        if (_isJanrainLoaded) {
          janrain2.events[event].addHandler((data) => {
            callback(data);
          });
        } else {
          if (attempt > max_tries) {
            throw "Janrain is not initialized";
          }
          attempt++;
          window.setTimeout(_addEventHandler, 100);
        }
      }
      _addEventHandler();
    }
    function debugAllHandlers() {
      const janrain2 = window.janrain;
      const addLog = function(e) {
        janrain2.events[e].addHandler((...handlerArgs) => {
          util2.log("JANRAIN: ", e, handlerArgs);
        });
      };
      if (pn.debug) {
        janrain2.events.captureEvents.forEach(addLog);
      }
    }
    const registerCallback = (callbackName, callback) => {
      eventManager.addEvent(callbackName);
      eventManager.registerCallback(callbackName, (data) => {
        callback(data);
      });
    };
    return {
      name: name3,
      isv,
      init,
      isUserValid,
      getToken,
      getName,
      onLoginSuccess,
      login,
      logout,
      isConfigured,
      getLoginRequiredScreen,
      addEventHandler,
      registerCallback
    };
  })();
  pn.container.register("janrain", {
    useValue: janrain
  });
  pn.janrain = pn.container.resolve("janrain");

  // ../src/lib/sha1.ts
  var sha1 = (() => {
    function hash(msg, length) {
      length = length || 32;
      function rotate_left(n, s) {
        var t4 = n << s | n >>> 32 - s;
        return t4;
      }
      ;
      function lsb_hex(val) {
        var str = "";
        var i2;
        var vh;
        var vl;
        for (i2 = 0; i2 <= 6; i2 += 2) {
          vh = val >>> i2 * 4 + 4 & 15;
          vl = val >>> i2 * 4 & 15;
          str += vh.toString(16) + vl.toString(16);
        }
        return str;
      }
      ;
      function cvt_hex(val) {
        var str = "";
        var i2;
        var v;
        for (i2 = 7; i2 >= 0; i2--) {
          v = val >>> i2 * 4 & 15;
          str += v.toString(16);
        }
        return str;
      }
      ;
      function Utf8Encode(string) {
        string = string.replace(/\r\n/g, "\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
          var c = string.charCodeAt(n);
          if (c < 128) {
            utftext += String.fromCharCode(c);
          } else if (c > 127 && c < 2048) {
            utftext += String.fromCharCode(c >> 6 | 192);
            utftext += String.fromCharCode(c & 63 | 128);
          } else {
            utftext += String.fromCharCode(c >> 12 | 224);
            utftext += String.fromCharCode(c >> 6 & 63 | 128);
            utftext += String.fromCharCode(c & 63 | 128);
          }
        }
        return utftext;
      }
      ;
      var blockstart;
      var i, j;
      var W = new Array(80);
      var H0 = 1732584193;
      var H1 = 4023233417;
      var H2 = 2562383102;
      var H3 = 271733878;
      var H4 = 3285377520;
      var A, B, C, D, E;
      var temp;
      msg = Utf8Encode(msg);
      var msg_len = msg.length;
      var word_array = new Array();
      for (i = 0; i < msg_len - 3; i += 4) {
        j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 | msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);
        word_array.push(j);
      }
      switch (msg_len % 4) {
        case 0:
          i = 2147483648;
          break;
        case 1:
          i = msg.charCodeAt(msg_len - 1) << 24 | 8388608;
          break;
        case 2:
          i = msg.charCodeAt(msg_len - 2) << 24 | msg.charCodeAt(msg_len - 1) << 16 | 32768;
          break;
        case 3:
          i = msg.charCodeAt(msg_len - 3) << 24 | msg.charCodeAt(msg_len - 2) << 16 | msg.charCodeAt(msg_len - 1) << 8 | 128;
          break;
      }
      word_array.push(i);
      while (word_array.length % 16 != 14)
        word_array.push(0);
      word_array.push(msg_len >>> 29);
      word_array.push(msg_len << 3 & 4294967295);
      for (blockstart = 0; blockstart < word_array.length; blockstart += 16) {
        for (i = 0; i < 16; i++)
          W[i] = word_array[blockstart + i];
        for (i = 16; i <= 79; i++)
          W[i] = rotate_left(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        A = H0;
        B = H1;
        C = H2;
        D = H3;
        E = H4;
        for (i = 0; i <= 19; i++) {
          temp = rotate_left(A, 5) + (B & C | ~B & D) + E + W[i] + 1518500249 & 4294967295;
          E = D;
          D = C;
          C = rotate_left(B, 30);
          B = A;
          A = temp;
        }
        for (i = 20; i <= 39; i++) {
          temp = rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 1859775393 & 4294967295;
          E = D;
          D = C;
          C = rotate_left(B, 30);
          B = A;
          A = temp;
        }
        for (i = 40; i <= 59; i++) {
          temp = rotate_left(A, 5) + (B & C | B & D | C & D) + E + W[i] + 2400959708 & 4294967295;
          E = D;
          D = C;
          C = rotate_left(B, 30);
          B = A;
          A = temp;
        }
        for (i = 60; i <= 79; i++) {
          temp = rotate_left(A, 5) + (B ^ C ^ D) + E + W[i] + 3395469782 & 4294967295;
          E = D;
          D = C;
          C = rotate_left(B, 30);
          B = A;
          A = temp;
        }
        H0 = H0 + A & 4294967295;
        H1 = H1 + B & 4294967295;
        H2 = H2 + C & 4294967295;
        H3 = H3 + D & 4294967295;
        H4 = H4 + E & 4294967295;
      }
      temp = cvt_hex(H0) + cvt_hex(H1) + cvt_hex(H2) + cvt_hex(H3) + cvt_hex(H4);
      return temp.toLowerCase().slice(0, length);
    }
    return {
      name: "sha1",
      hash
    };
  })();
  pn.sha1 = sha1;
  pn.container.register("sha1", {
    useValue: sha1
  });

  // ../src/lib/observer.ts
  var AttrObserver = class {
    constructor(callback, util2) {
      this._isActive = false;
      this.targets = [];
      this.timeout = 200;
      this.util = util2;
      this.callback = callback;
    }
    _mutationSearch() {
      var that = this;
      this.targets.forEach(function(target) {
        var state = that._getState(target.element);
        if (!state === target.currentState) {
          target.currentState = state;
          that.callback([{
            target: target.element
          }]);
        }
      });
      if (this._isActive) {
        setTimeout(this._mutationSearch.bind(this), this.timeout);
      }
    }
    _getState(element) {
      var attributes = [].slice.call(element.attributes);
      var attributesMap = attributes.reduce(function(acc, attr) {
        acc[attr.name] = element.getAttribute(attr.name);
        return acc;
      }, {});
      return JSON.stringify(attributesMap);
    }
    observe(element) {
      this.targets.push({
        id: this.util.randomString(),
        element,
        currentState: this._getState(element)
      });
      if (!this._isActive) {
        this._isActive = true;
        this._mutationSearch();
      }
    }
    disconnect() {
      this._isActive = false;
      this.targets = [];
    }
  };
  var observer = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const mutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
    const attrsConfig = {
      attributes: true
    };
    const name3 = "observer";
    const create = ($element, callback) => {
      if (!$element) {
        util2.error("element must be NODE");
      }
      var Observer = !!mutationObserver ? mutationObserver : AttrObserver;
      var observer2 = new Observer((mutations) => {
        var elements = mutations.map((mutation) => {
          return mutation.target;
        });
        return typeof callback === "function" && callback(elements);
      }, util2);
      observer2.observe($element, attrsConfig);
      return observer2;
    };
    return {
      name: name3,
      create
    };
  })();
  pn.container.register("observer", {
    useValue: observer
  });
  pn.observer = pn.container.resolve("observer");

  // ../src/lib/containerUtils.ts
  var containerUtils = (() => {
    const BROWSER_ELEMENT_SIZE_ADMISSIBLE_ERROR = 0.1;
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const postmessage2 = pn.container.resolve("postmessage");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const sha12 = pn.container.resolve("sha1");
    const name3 = "containerUtils";
    const iframes = {};
    const popupContainersInterval = {};
    const eventManager = eventUtils2.createEventManager(["close"]);
    const fakeOfferId = "fakeOfferId";
    const containerInnerClass = "tp-container-inner";
    const localWaitPanelsMap = /* @__PURE__ */ new Map();
    const excludedQueryParams = {
      continuation: true
    };
    let waitPanelElement;
    let modalHeightObserver;
    let tpModal;
    const tpModalStack = [];
    const scrollPreventionClassNames = {
      tpModal: "tp-modal-overscroll-prevented",
      scrollPrevented: "tp-scroll-prevented",
      body: "tp-body-scroll-prevented"
    };
    const mobileModalFix = {
      _initialScrollPosition: {
        x: 0,
        y: 0
      },
      applyFix: function() {
        var maxTop = window.visualViewport ? Math.max(window.scrollY, document.documentElement.scrollTop, window.visualViewport.pageTop) : Math.max(window.scrollY, document.documentElement.scrollTop);
        this.saveInitialScroll(window.scrollX, maxTop);
        if (tpModal) {
          !util2.isIphone17OrHigher() && _scrollToTopAfterLoading();
          _preventContentElementScroll();
          _setClassToElement(tpModal, scrollPreventionClassNames.tpModal);
        }
      },
      removeFix: function() {
        if (document.querySelectorAll(".tp-iframe-wrapper.tp-active").length) {
          return;
        }
        this._scrollBack();
        if (modalHeightObserver) {
          modalHeightObserver.disconnect();
          modalHeightObserver = null;
        }
        _unPreventContentElementScroll();
      },
      _scrollBack: function() {
        if (this._initialScrollPosition.y || this._initialScrollPosition.x) {
          _scrollTo(this._initialScrollPosition.x, this._initialScrollPosition.y);
        }
      },
      saveInitialScroll: function(x, y) {
        this._initialScrollPosition.x = x;
        this._initialScrollPosition.y = y;
      },
      modalOpened: function() {
        this.applyFix();
      },
      modalClosed: function() {
        this.removeFix();
      }
    };
    const _setClassToElement = (element, className) => {
      element.classList.add(className);
    };
    const _preventContentElementScroll = () => {
      _setClassToElement(document.documentElement, scrollPreventionClassNames.scrollPrevented);
      _setClassToElement(document.body, scrollPreventionClassNames.body);
    };
    const removeClassesFromElements = (className) => {
      document.querySelectorAll(`.${className}`).forEach((element) => {
        element.classList.remove(className);
      });
    };
    const _unPreventContentElementScroll = () => {
      removeClassesFromElements(scrollPreventionClassNames.scrollPrevented);
      removeClassesFromElements(scrollPreventionClassNames.body);
    };
    const _scrollToTopAfterLoading = () => {
      const iframeWrapperEl = document.querySelectorAll(".tp-iframe-wrapper");
      const lastIframeWrapperEl = iframeWrapperEl[iframeWrapperEl.length - 1];
      const callbackFn = (mutationsList, observer2) => {
        for (let mutation of mutationsList) {
          if (mutation.type === "attributes" && mutation.attributeName === "style") {
            _scrollTo(0, 0);
          }
        }
      };
      modalHeightObserver = new MutationObserver(callbackFn);
      modalHeightObserver.observe(lastIframeWrapperEl, { attributes: true, childList: true, subtree: true });
    };
    const _scrollTo = (x, y) => {
      function isNative(fn) {
        return /\{\s*\[native code\]\s*\}/.test("" + fn);
      }
      try {
        if (isNative(window.scrollTo)) {
          window.scrollTo(x, y);
          return;
        }
        if (isNative(window.scroll)) {
          window.scroll(x, y);
          return;
        }
        if (document.body) {
          document.body.scrollTop = 0;
        }
      } catch (e) {
        console.warn("Can not perform scroll: " + e.message);
      }
    };
    jqUtils2.on(window, "resize", () => {
      var _a;
      _resizeAllContainers();
      if (util2.isAndroid()) {
        const modal = (_a = document.querySelector(".tp-iframe-wrapper.tp-active")) == null ? void 0 : _a.closest(".tp-modal");
        if (modal) {
          modal.scrollBy(0, 1);
        }
      }
    });
    if (util2.isIOS()) {
      jqUtils2.on(window, "orientationchange", () => {
        setTimeout(() => _resizeAllContainers(), 100);
      });
    }
    postmessage2.subscribe("close", () => {
      mobileModalFix.modalClosed();
    });
    postmessage2.subscribe("toggleIframeShadow", (data) => {
      toggleWrapperShadow(data.params.isEnabled);
    });
    postmessage2.subscribe("toggleLoadingContainer", (data) => {
      if (data.params.isEnabled) {
        return showWaitPanel();
      }
      hideWaitPanel();
    });
    const toggleWrapperShadow = (isEnabled) => {
      var wrapperElement = document.querySelector(".tp-iframe-wrapper");
      if (!wrapperElement) {
        return;
      }
      if (isEnabled) {
        return wrapperElement.classList.contains("no-shadow") && wrapperElement.classList.remove("no-shadow");
      }
      wrapperElement.classList.add("no-shadow");
    };
    const _removeIframe = (iframe) => {
      util2.debug("Removing iframe", iframe);
      if (iframe.element) {
        jqUtils2.hide(iframe.element);
        if (iframe.config.displayMode === "inline") {
          const parentEl = iframe.element.parentElement;
          if (parentEl) {
            jqUtils2.hide(parentEl);
          }
        }
      }
      if (iframe.resizeObserver) {
        iframe.resizeObserver.disconnect();
      }
      if (iframe.config.displayMode === "modal" || iframe.config.displayMode === "inline") {
        iframe.waitFinishProcesses = true;
      }
    };
    const purgeIframe = (iframeId, parentId) => {
      util2.debug("Purging iframe", iframeId);
      var iframe = iframes[iframeId];
      try {
        if (iframe.resizeObserver) {
          iframe.resizeObserver.disconnect();
        }
        postmessage2.removeIframe(iframe.iframeId);
        jqUtils2.remove(iframe.element);
        if (iframe.config.displayMode === "inline") {
          const innerContainer = jqUtils2.queryEl(".tp-container-inner", iframe.container);
          if (innerContainer) {
            jqUtils2.remove(innerContainer);
          }
        }
      } catch (e) {
      }
      delete iframes[iframeId];
    };
    const _checkInternalProcessesBeforeClose = (iframe) => {
      postmessage2.send("checkProccessesForClose", {}, iframe.iframeId);
    };
    const closeAndRemoveIframe = (iframe) => {
      _checkInternalProcessesBeforeClose(iframe);
      if (iframe.config.displayMode === "popup") {
        iframe.container.close();
      } else {
        _removeIframe(iframe);
        _hideTpModal();
        hideBackdrop();
      }
    };
    const hasModalIframe = () => {
      for (var iframeId in iframes) {
        var iframe = iframes[iframeId];
        if (iframe.config.displayMode === "modal" && !iframe.waitFinishProcesses && !iframe.config.isPreload) {
          return true;
        }
      }
      return false;
    };
    const getForm = (params) => {
      let form = document.createElement("form");
      const formAttrs = {
        id: "form_" + params.iframeId,
        method: "post",
        action: params.iframeSrc,
        target: params.iframeId
      };
      jqUtils2.setAttrs(formAttrs, form);
      const fields = [
        { name: "userToken", value: params.userToken }
      ];
      fields.forEach((field) => {
        const input = document.createElement("input");
        const inputAttrs = {
          type: "hidden",
          name: field.name
        };
        jqUtils2.setAttrs(inputAttrs, input);
        input.value = field.value;
        jqUtils2.append(form, input);
      });
      return form;
    };
    const getIframe = (iframeId) => {
      return iframes[iframeId];
    };
    class ModalContainer {
      constructor($, util3, _operationWithContainer) {
        this.$ = $;
        this._operationWithContainer = _operationWithContainer;
        this.util = util3;
        this._initModalContainer();
        this.iOSBottomToolbarHeight = 90;
      }
      _initModalContainer() {
        if (this.container) {
          return this.container;
        }
        this.container = document.createElement("div");
        this.element = this.container;
        this.$.addClass("tp-modal", this.container);
        this.close = document.createElement("button");
        this.$.setAttr("type", "button", this.close);
        this.$.setAttr("aria-label", "Close", this.close);
        this.$.addClass("tp-close", this.close);
        this.iframeWrapper = document.createElement("div");
        this.$.addClass("tp-iframe-wrapper", this.iframeWrapper);
        this.$.append(this.iframeWrapper, this.close);
        this.container.style.zIndex = pn.zIndexes.modal + "";
        this.close.style.zIndex = pn.zIndexes.close + "";
        this.$.on(this.close, "click", () => {
          if (typeof this.closeClick === "function") {
            this.closeClick();
          }
        });
        if (this.util.isIOS() && !this.util.isFBOrInstWebView()) {
          this.iframeWrapper.style.marginBottom = `${this.iOSBottomToolbarHeight}px`;
        }
        this.$.append(this.container, this.iframeWrapper);
        this._operationWithContainer("body", (containerBody) => {
          this.$.append(containerBody, this.container);
        });
        return this.container;
      }
      getContainer(withCloseButton, onClose) {
        this._initModalContainer();
        this.closeClick = onClose;
        if (typeof withCloseButton === "undefined") {
          withCloseButton = true;
        }
        if (withCloseButton) {
          this.showCloseButton();
        } else {
          this.hideCloseButton();
        }
        return this.iframeWrapper;
      }
      show(withCloseButton) {
        this._initModalContainer();
        if (typeof withCloseButton === "undefined") {
          withCloseButton = true;
        }
        if (withCloseButton) {
          this.showCloseButton();
        } else {
          this.hideCloseButton();
        }
        this.$.addClass("tp-active", this.container);
      }
      hide() {
        this._initModalContainer();
        this.$.removeClass("tp-active", this.container);
      }
      showCloseButton() {
        this._initModalContainer();
        this.$.addClass("tp-active", this.close);
      }
      hideCloseButton() {
        this._initModalContainer();
        this.$.removeClass("tp-active", this.close);
      }
    }
    const _applyInlineContainer = (iframe) => {
      jqUtils2.show(iframe.container);
      const innerContainer = jqUtils2.queryEl(`.${containerInnerClass}`, iframe.container);
      if (innerContainer) {
        jqUtils2.show(innerContainer);
      }
      resizeIframe(iframe, {
        width: jqUtils2.getWidth(iframe.container)
      });
    };
    const _applyModalContainer = (iframe) => {
      tpModal = iframe.container.closest(".tp-modal");
      if (tpModal) {
        tpModal = tpModal;
      } else {
        util2.error("there is no such modal container");
      }
      checkBackdropAndContainer(iframe, true, true);
    };
    const _handleKeystroke = (event) => {
    };
    const closeContainer = (sender, parent2, modalOnly) => {
      util2.debug("Search container to close", sender, parent2, modalOnly);
      for (var iframeId in iframes) {
        var iframe = iframes[iframeId];
        if (sender && iframeId !== sender) {
          continue;
        }
        if (modalOnly && iframe.config.displayMode === "inline") {
          continue;
        }
        if (modalOnly && iframe.config.isPreload) {
          continue;
        }
        if (iframe.config.displayMode === "modal") {
          closeModal(iframe);
        }
        closeAndRemoveIframe(iframe);
      }
      eventManager.fireCallbacks("close", null, sender, true);
    };
    const _closeInlineContainer = (iframeId) => {
      var iframe = getIframe(iframeId);
      if (iframe.config.child) {
        closeContainer(iframe.config.child);
      }
      closeContainer(iframeId);
    };
    const closeInlineContainers = (selector) => {
      var domIframes = Array.prototype.slice.call(document.querySelectorAll(selector + " > ." + containerInnerClass + " > iframe"));
      domIframes.forEach((domIframe) => {
        if (domIframe.id) {
          _closeInlineContainer(domIframe.id);
        }
      });
    };
    const closeModal = (iframe) => {
      var stackModal = tpModalStack.shift();
      if (backdrop && !stackModal) {
        jqUtils2.removeClass("tp-active", backdrop);
      }
      iframe.iframeParams.shown = false;
      jqUtils2.removeClass("tp-active", iframe.container);
      if (!stackModal) {
        _hideTpModal();
        hideBackdrop();
      } else {
        jqUtils2.hide(tpModal);
        tpModal = stackModal;
        jqUtils2.show(tpModal);
      }
    };
    let backdrop;
    let showBackdropTimeout;
    const showBackdropTimeoutMs = 50;
    const _createBackdrop = () => {
      if (backdrop) {
        return backdrop;
      }
      var elm = document.createElement("div");
      jqUtils2.addClass("tp-backdrop", elm);
      elm.style.zIndex = pn.zIndexes.backdrop + "";
      operationWithContainer("body", (containerBody) => {
        jqUtils2.append(containerBody, elm);
      });
      backdrop = elm;
      return elm;
    };
    const _showTpModal = (tpModalElement) => {
      if (jqUtils2.visible(tpModalElement)) {
        return;
      }
      operationWithContainer("body", (containerBody) => {
        jqUtils2.removeClass("tp-modal-close", containerBody);
        jqUtils2.addClass("tp-modal-open", containerBody);
      });
      jqUtils2.show(tpModalElement);
      if (util2.isIphone() || util2.isSafariOrIOsUiWebView() || util2.isAndroid()) {
        mobileModalFix.modalOpened();
      }
    };
    const _hideTpModal = () => {
      if (!tpModal) {
        return;
      }
      operationWithContainer("body", (containerBody) => {
        jqUtils2.addClass("tp-modal-close", containerBody);
        jqUtils2.removeClass("tp-modal-open", containerBody);
        if (containerBody.classList.contains("body-fixed")) {
          jqUtils2.removeClass("body-fixed", containerBody);
        }
      });
      jqUtils2.hide(tpModal);
    };
    const showBackdrop = (tpModalElement, useStack, putOnStack) => {
      _createBackdrop();
      if (jqUtils2.visible(backdrop)) {
        const modals = jqUtils2.qa(".tp-modal");
        const modal = modals.find((el) => jqUtils2.visible(el));
        if (useStack && !putOnStack) {
          if (modal) {
            jqUtils2.hide(modal);
            tpModalStack.unshift(modal);
          }
          if (tpModalElement) {
            jqUtils2.show(tpModalElement);
          }
        } else if (useStack) {
          if (modal) {
            if (tpModalElement) {
              tpModalStack.push(tpModalElement);
            }
            tpModal = modal;
          } else {
            if (tpModalElement) {
              jqUtils2.show(tpModalElement);
            }
          }
        }
        return;
      }
      jqUtils2.show(backdrop);
      if (tpModalElement) {
        _showTpModal(tpModalElement);
      }
      showBackdropTimeout = window.setTimeout(() => {
        jqUtils2.addClass("tp-active", backdrop);
      }, showBackdropTimeoutMs);
    };
    const hideBackdrop = () => {
      if (backdrop) {
        jqUtils2.removeClass("tp-active", backdrop);
        jqUtils2.hide(backdrop);
        clearTimeout(showBackdropTimeout);
      }
      mobileModalFix.modalClosed();
    };
    const centerBackdrop = (container) => {
      if (!backdrop) {
        return;
      }
      const winSize = jqUtils2.winSize();
      if (container.offsetHeight > winSize.height) {
        backdrop.style.height = winSize.height + "";
      } else {
        backdrop.style.height = "100%";
      }
    };
    const centerIt = (container) => {
      if (backdrop) {
        backdrop.style.height = "100%";
      }
      const tpClose = jqUtils2.queryEl(".tp-close", container);
      if (tpClose) {
        jqUtils2.removeClass("tp-square", tpClose);
      }
    };
    const resizeIframe = (iframe, params) => {
      if (!iframe) {
        return;
      }
      setElementSizes(iframe.element, params);
      var noAnimateParams = Object.assign({}, params, {
        animate: false
      });
      switch (iframe.config.displayMode) {
        case "modal":
          setElementSizes(iframe.container, noAnimateParams);
          operationWithContainer("body", (containerBody) => {
            jqUtils2.addClass("tp-modal-resizing", containerBody);
            setTimeout(() => {
              jqUtils2.removeClass("tp-modal-resizing", containerBody);
            }, 50);
          });
          break;
        case "inline":
          var _innerContainer = jqUtils2.queryEl("." + containerInnerClass, iframe.container);
          if (_innerContainer) {
            setElementSizes(_innerContainer, params);
          }
          break;
        default:
          break;
      }
    };
    const checkBackdropAndContainer = (iframe, useStack, putOnStack) => {
      var container = iframe.container;
      var tpModalElement = container.parentElement;
      if (!tpModalElement || !tpModalElement.classList.contains("tp-modal")) {
        tpModalElement = tpModal;
      } else {
        tpModal = tpModalElement;
      }
      iframe.iframeParams = iframe.iframeParams || {};
      if (!iframe.iframeParams.shown) {
        iframe.iframeParams.shown = true;
        showBackdrop(tpModalElement, useStack, putOnStack);
        if (!putOnStack) {
          if (!container.classList.contains("tp-active")) {
            jqUtils2.addClass("tp-active", container);
          }
          centerIt(container);
        }
      }
    };
    const hideCloseButton = (container) => {
      if (container) {
        var closeBtn = jqUtils2.queryEl(".tp-close", container);
        if (closeBtn && closeBtn.classList.contains("tp-active")) {
          jqUtils2.removeClass("tp-active", closeBtn);
        }
      }
    };
    const containersIterations = {};
    const operationWithContainer = function(containerSelector, operation) {
      var container = jqUtils2.queryEl(containerSelector);
      if (!containersIterations[containerSelector]) {
        containersIterations[containerSelector] = 0;
      }
      if (!container) {
        if (containersIterations[containerSelector] < 100) {
          containersIterations[containerSelector] += 1;
          setTimeout(() => {
            operationWithContainer(containerSelector, operation);
          }, 50);
        } else {
        }
      } else {
        delete containersIterations[containerSelector];
        operation(container);
      }
    };
    const getModalContainer = (c, onClose) => {
      if (typeof c.showCloseButton === "undefined") {
        c.showCloseButton = true;
      }
      if (c.container) {
        return c.container;
      } else {
        var container = new ModalContainer(jqUtils2, util2, operationWithContainer);
        if (!c.isPreload) {
          tpModal = container.element;
        }
        return container.getContainer(c.showCloseButton, onClose);
      }
    };
    const initInlineContainer = (config) => {
      var res = { container: null, containerReady: false };
      if (!config.iframeParams.containerSelector) {
        util2.log("Inline offer must have a valid containerSelector");
        return res;
      }
      res.container = config.singleContainer || jqUtils2.queryEl(config.iframeParams.containerSelector);
      if (!res.container) {
        util2.log("Invalid containerSelector");
        return res;
      } else {
        var innerConfig = config.config;
        var isInnerConfigExists = typeof innerConfig === "object" && innerConfig !== null;
        jqUtils2.empty(res.container);
        if (isInnerConfigExists) {
          var isPreview = !!innerConfig.preview === true;
          if (!isPreview) {
            config.iframeParams.width = jqUtils2.getWidth(res.container);
          }
        } else {
          config.iframeParams.width = config.iframeParams.width || jqUtils2.getWidth(res.container);
        }
        res.containerReady = true;
      }
      return res;
    };
    const getPopupPosition = (iframeParams) => {
      const winSize = jqUtils2.winSize();
      var w = iframeParams.width ? iframeParams.width : winSize.width;
      var h = iframeParams.height ? iframeParams.height : winSize.height;
      var center = util2.centerScreen(w, h);
      return {
        width: w,
        height: h,
        top: center.top,
        left: center.left
      };
    };
    const generatePopup = (iframeParams, src) => {
      var pos = getPopupPosition(iframeParams);
      var newWindow = window.open(src, util2.randomString(16), "scrollbars=yes,location=yes,status=0,toolbar=0,resizable=1, width=" + pos.width + ", height=" + pos.height + ", top=" + pos.top + ", left=" + pos.left);
      if (window.focus && newWindow) {
        newWindow.focus();
      }
      return newWindow;
    };
    let count = 1;
    const generateIframe = (c, iframeParams, src) => {
      var id = "iframe-" + count++ + "-" + util2.randomString();
      if (iframeParams.iframeId)
        id = iframeParams.iframeId;
      var iframe = document.createElement("iframe");
      const attrs = {
        id,
        name: id,
        scrolling: "no",
        allowtransparency: "true",
        allow: "payment",
        allowfullscreen: "true"
      };
      if (!pn.isSensitiveDataProtectionEnabled || c.isSensitiveDataProtectionDisabled) {
        attrs.src = src;
      }
      Object.keys(attrs).forEach((key2) => {
        jqUtils2.setAttr(key2, attrs[key2], iframe);
      });
      const css2 = {
        overflow: "hidden",
        backgroundColor: "transparent",
        border: "0",
        width: c.displayMode === "inline" ? iframeParams.width + "px" : "0px",
        height: "0px"
      };
      Object.keys(css2).forEach((key2) => {
        iframe.style[key2] = css2[key2];
      });
      try {
        jqUtils2.setAttr("frameBorder", "0", iframe);
      } catch (ex2) {
        util2.log(ex2);
      }
      return iframe;
    };
    const generateIframeWrapper = () => {
      const wrapper = document.createElement("div");
      const css2 = {
        overflow: "hidden",
        backgroundColor: "transparent",
        border: "0",
        width: "0px",
        height: "0px",
        position: "absolute",
        display: "block",
        top: "-1px",
        left: "-1px"
      };
      Object.keys(css2).forEach((key2) => {
        wrapper.style[key2] = css2[key2];
      });
      return wrapper;
    };
    const showPreloadedContainer = (iframe) => {
      if (iframe.config.displayMode === "modal") {
        if (hasModalIframe()) {
          util2.log("Modal is already shown; must be one modal per time");
          return;
        }
        _applyModalContainer(iframe);
      } else if (iframe.config.displayMode === "inline") {
        _applyInlineContainer(iframe);
      } else {
        util2.log("Unexpected displayMode of preloaded iframe\n");
      }
      iframe.config.isPreload = false;
      iframe.iframeParams.isPreload = false;
      util2.debug("show preloaded iframe: ", iframe.config);
      return iframe;
    };
    const getInnerContainerWidth = (iframe) => {
      var _innerContainer = jqUtils2.queryEl("." + containerInnerClass, iframe.container);
      if (!_innerContainer) {
        return 0;
      }
      return jqUtils2.getWidth(iframe.container);
    };
    const isBrowserElementSizeAdmissibleError = (iframe, iframeContainerWidth) => {
      const innerContainerWidth = getInnerContainerWidth(iframe);
      if (!innerContainerWidth || !iframeContainerWidth) {
        return false;
      }
      return Math.abs(innerContainerWidth - iframeContainerWidth) < BROWSER_ELEMENT_SIZE_ADMISSIBLE_ERROR;
    };
    const createContainer = (config) => {
      let params = {};
      let form = document.createElement("form");
      let src;
      var container;
      var containerReady = true;
      var iframeParams = config.iframeParams;
      if (iframeParams.displayMode !== "inline" && !iframeParams.width) {
        iframeParams.width = window.innerWidth;
      }
      var buildQueryStringFn;
      if (!config.config.buildQueryStringFn) {
        buildQueryStringFn = (iframeParams2) => {
          var queryString = jqUtils2.param(iframeParams2, excludedQueryParams);
          return queryString + "&_qh=" + sha12.hash(queryString, 10);
        };
      } else {
        buildQueryStringFn = (iframeParams2) => {
          return config.config.buildQueryStringFn(iframeParams2, jqUtils2);
        };
      }
      let element;
      if (iframeParams.displayMode === "popup") {
        if (!iframeParams.width) {
          iframeParams.width = window.innerWidth;
        }
        const _src = config.url + "?" + buildQueryStringFn(iframeParams);
        container = generatePopup(iframeParams, _src);
        try {
          element = container.document;
        } catch (eee) {
          try {
            element = container;
          } catch (e) {
            element = null;
            console.warn("Unable to get popup element");
          }
        }
        popupContainersInterval[iframeParams.iframeId] = {
          container,
          interval: setInterval(() => {
            if (popupContainersInterval[iframeParams.iframeId].container.closed) {
              clearInterval(popupContainersInterval[iframeParams.iframeId].interval);
              popupContainersInterval[iframeParams.iframeId].container.close();
              if (config.onCloseCallback) {
                config.onCloseCallback();
              }
            }
          }, 100)
        };
      } else {
        if (iframeParams.displayMode === "inline") {
          if (config.config.showCloseButton !== void 0) {
            delete config.config.showCloseButton;
          }
          var inlineContainer = initInlineContainer(config);
          container = inlineContainer.container;
          containerReady = !!inlineContainer.containerReady;
        } else {
          container = getModalContainer(config.config, () => {
            closeContainer(iframeParams.iframeId, config.parent);
          });
        }
        if (pn.isSensitiveDataProtectionEnabled) {
          params = {
            userToken: iframeParams.userToken,
            iframeId: iframeParams.iframeId
          };
          delete iframeParams.userToken;
        }
        src = config.url + "?" + buildQueryStringFn(iframeParams);
        element = generateIframe(config.config, iframeParams, src);
      }
      eventManager.registerCallback(config, iframeParams.iframeId);
      var iframe = iframes[iframeParams.iframeId] = {
        iframeId: iframeParams.iframeId,
        config: config.config,
        element,
        container,
        iframeParams,
        containerReady
      };
      postmessage2.init({
        postMessageUrl: config.postMessageUrl,
        parent: config.parent,
        receive: config.receive,
        iframe,
        iframeParams
      });
      jqUtils2.on(document, "keyup", (event) => _handleKeystroke(event));
      if (pn.isSensitiveDataProtectionEnabled) {
        params.iframeSrc = src;
        form = getForm(params);
      }
      if (iframeParams.displayMode === "modal") {
        jqUtils2.on(window, "resize", () => {
          centerIt(container);
        });
        if (pn.isSensitiveDataProtectionEnabled) {
          jqUtils2.append(container, element);
          jqUtils2.append(container, form);
          form == null ? void 0 : form.submit();
        } else {
          jqUtils2.append(container, element);
        }
      } else if (iframeParams.displayMode === "inline") {
        if (iframes[iframeParams.iframeId].containerReady) {
          const inner = document.createElement("div");
          jqUtils2.addClass(containerInnerClass, inner);
          jqUtils2.append(inner, element);
          if (config.config.isPreload) {
            jqUtils2.hide(inner);
          }
          if ((document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) && container) {
            jqUtils2.empty(container);
            jqUtils2.append(container, inner);
            if (pn.isSensitiveDataProtectionEnabled) {
              jqUtils2.append(inner, form);
              form == null ? void 0 : form.submit();
            }
          } else {
            _watchOnContainerForCleaning(container, inner, form);
          }
        } else {
          const tempContainer = document.createElement("div");
          jqUtils2.setAttr("id", "temp-inline-" + iframeParams.iframeId, tempContainer);
          jqUtils2.hide(tempContainer);
          operationWithContainer("body", (containerBody) => {
            jqUtils2.append(containerBody, tempContainer);
          });
          jqUtils2.append(tempContainer, element);
        }
        if (window.ResizeObserver) {
          const containerResize$ = new ResizeObserver((entries) => {
            const width = jqUtils2.getWidth(iframe.container);
            if (width > 0) {
              if (iframe.config.displayMode === "inline" && isBrowserElementSizeAdmissibleError(iframe, width)) {
                return;
              }
              resizeIframe(iframe, {
                width
              });
            }
          });
          containerResize$.observe(iframe.container);
          iframe.resizeObserver = containerResize$;
        }
      }
      util2.debug("creating iframe: ", config);
      return iframe;
    };
    const redirectContainer = (iframeId, config) => {
      var src = config.url + "?" + jqUtils2.param(config.iframeParams, excludedQueryParams);
      var iframe = iframes[iframeId];
      if (iframe.config.displayMode === "popup") {
        iframe.container.location = src;
      } else {
        var iframeEl = iframe.element;
        var win = iframeEl.contentWindow || iframeEl;
        win.location = src;
      }
      iframe.config = config.config;
      postmessage2.init({
        postMessageUrl: config.postMessageUrl,
        receive: config.receive,
        iframe: iframes[config.iframeParams.iframeId],
        iframeParams: config.iframeParams
      });
    };
    const _watchOnContainerForCleaning = (container, element, form) => {
      var interval = setInterval(() => {
        jqUtils2.empty(container);
      }, 150);
      jqUtils2.ready(() => {
        clearInterval(interval);
        jqUtils2.append(container, element);
        if (pn.isSensitiveDataProtectionEnabled) {
          jqUtils2.append(element, form);
          form.submit();
        }
      });
    };
    const _resizeAllContainers = () => {
      for (var id in iframes) {
        var iframe = iframes[id];
        if (!iframe.config.preview && iframe.config.displayMode === "inline" && iframe.container) {
          resizeIframe(iframe, {
            width: jqUtils2.getWidth(iframe.container)
          });
        }
        if (iframe.config.displayMode === "modal" && iframe.container) {
          var width = Math.max(document.documentElement["clientWidth"], document.body["offsetWidth"], document.documentElement["offsetWidth"]);
          postmessage2.send("RESIZE_MODAL_CHECKOUT", { iframe, width }, iframe.iframeId);
        }
      }
    };
    const setElementSizes = (elem, params) => {
      if (!elem) {
        return;
      }
      if (params.width !== void 0) {
        elem.style.width = params.width + "px";
        if (params.width === 0 && !elem.classList.contains("no-width") || params.width !== 0 && elem.classList.contains("no-width")) {
          jqUtils2.toggleClass("no-width", elem);
        }
      }
      if (params.height !== void 0) {
        if (!!params.animate) {
          elem.style.height = params.height + "px";
        } else {
          elem.style.height = params.height + "px";
        }
        if (params.height === 0 && !elem.classList.contains("no-height") || params.height !== 0 && elem.classList.contains("no-height")) {
          jqUtils2.toggleClass("no-height", elem);
        }
      }
    };
    const hideModalContainer = (sender) => {
      var hiddenIframes = [];
      for (var iframeId in iframes) {
        var iframe = iframes[iframeId];
        if (sender && iframeId !== sender) {
          continue;
        }
        if (iframe.config.displayMode === "inline") {
          continue;
        }
        if (iframe.config.displayMode === "modal") {
          closeModal(iframe);
          jqUtils2.hide(iframe.container);
          hiddenIframes.push(iframeId);
        }
      }
      return hiddenIframes;
    };
    const activateContainers = (iframeIds) => {
      if (!iframeIds || !iframeIds.length) {
        return;
      }
      for (var iframeId in iframes) {
        var iframe = iframes[iframeId];
        for (var i = 0; i < iframeIds.length; i++) {
          if (iframeId === iframeIds[i]) {
            const container = iframe.container;
            const parentEl = container.parentElement;
            if (parentEl) {
              showBackdrop(parentEl);
            }
            jqUtils2.addClass("tp-active", container);
            jqUtils2.show(container);
          }
        }
      }
    };
    const addChildToInlineIframe = (iframe, sender) => {
      if (iframe) {
        var parentIframe = getIframe(sender);
        if (parentIframe && parentIframe.config) {
          parentIframe.config.child = iframe.iframeId;
        }
      }
    };
    const createElementFromStringTemplate = (stringTemplate) => {
      var parentElement = document.createElement("div");
      parentElement.innerHTML = stringTemplate.trim();
      return parentElement.firstChild;
    };
    const getWaitPanelMarkdown = (containerCSSClasses = "") => `<div class="tp-please-wait tp-active tp-overlap ${containerCSSClasses}"><div class="tp-icon tp-centered"><div class="pn-spinner"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div></div></div>`;
    const showWaitPanel = () => {
      if (waitPanelElement) {
        return;
      }
      waitPanelElement = createElementFromStringTemplate(getWaitPanelMarkdown());
      if (waitPanelElement) {
        document.body.appendChild(waitPanelElement);
      }
    };
    const hideWaitPanel = () => {
      if (!waitPanelElement) {
        return;
      }
      document.body.removeChild(waitPanelElement);
      waitPanelElement = null;
    };
    const showLocalWaitPanel = (iframe) => {
      if (!iframe || !(iframe == null ? void 0 : iframe.container) || localWaitPanelsMap.has(iframe.iframeId)) {
        return;
      }
      const localWaitPanelElement = createElementFromStringTemplate(getWaitPanelMarkdown("tp-local-overlap"));
      if (localWaitPanelElement) {
        iframe.container.appendChild(localWaitPanelElement);
        localWaitPanelsMap.set(iframe.iframeId, localWaitPanelElement);
      }
    };
    const hideLocalWaitPanel = (iframe) => {
      if (!iframe || !(iframe == null ? void 0 : iframe.container) || !localWaitPanelsMap.has(iframe.iframeId)) {
        return;
      }
      const localWaitPanelElement = localWaitPanelsMap.get(iframe.iframeId);
      if (localWaitPanelElement) {
        iframe.container.removeChild(localWaitPanelElement);
        localWaitPanelsMap.delete(iframe.iframeId);
      }
    };
    const addClassToContainer = (iframe, className) => {
      jqUtils2.addClass(className, iframe.container);
    };
    const turnOnRTL = (iframe) => {
      iframe.container && iframe.container.setAttribute && iframe.container.setAttribute("dir", "rtl");
    };
    const turnOffRTL = (iframe) => {
      iframe.container && iframe.container.removeAttribute && iframe.container.removeAttribute("dir");
    };
    const closeModalContainer = (iframeId, parentId) => {
      closeContainer(iframeId, parentId, true);
    };
    function setLocalWaitPanel(iframe) {
      if (!iframe || !iframe.container) {
        return;
      }
      showLocalWaitPanel(iframe);
      const onIframeLoad = () => {
        hideLocalWaitPanel(iframe);
      };
      iframe.container.addEventListener("load", onIframeLoad, { once: true, capture: true });
    }
    function reloadIframe(iframe) {
      if (!iframe || !iframe.element) {
        return;
      }
      if (isIframeVisible(iframe)) {
        setLocalWaitPanel(iframe);
      }
      iframe.element.src = iframe.element.src;
    }
    function isIframeVisible(iframe) {
      var _a;
      if (!iframe) {
        return false;
      }
      return !!((_a = iframe == null ? void 0 : iframe.element.getBoundingClientRect()) == null ? void 0 : _a.width);
    }
    function setupPopstateHandler() {
      for (const key2 in iframes) {
        const iframe = iframes[key2];
        if (iframe) {
          reloadIframe(iframe);
        }
      }
    }
    function setIframesPopstateHandlers() {
      if (!util2.isIphone() && !util2.isSafariOrIOsUiWebView()) {
        return;
      }
      window.addEventListener("popstate", setupPopstateHandler);
    }
    return {
      name: name3,
      fakeOfferId,
      createContainer,
      showPreloadedContainer,
      redirectContainer,
      hasModalIframe,
      getForm,
      getIframe,
      generateIframe,
      generateIframeWrapper,
      getPopupPosition,
      generatePopup,
      initInlineContainer,
      getModalContainer,
      centerBackdrop,
      showBackdrop,
      hideBackdrop,
      checkBackdropAndContainer,
      resizeIframe,
      centerIt,
      operationWithContainer,
      closeContainer,
      closeModalContainer,
      purgeIframe,
      hideModalContainer,
      closeModal,
      hideCloseButton,
      activateContainers,
      showWaitPanel,
      hideWaitPanel,
      addClassToContainer,
      turnOnRTL,
      turnOffRTL,
      setIframesPopstateHandlers,
      __protected__: {
        setElementSizes,
        closeInlineContainers,
        addChildToInlineIframe,
        closeAndRemoveIframe
      },
      __private__: {
        mobileModalFix
      }
    };
  })();
  pn.container.register("containerUtils", {
    useValue: containerUtils
  });
  pn.containerUtils = pn.container.resolve("containerUtils");

  // ../src/lib/log.ts
  var EventType = /* @__PURE__ */ ((EventType2) => {
    EventType2["EXTERNAL_LINK"] = "EXTERNAL_LINK";
    EventType2["EXTERNAL_EVENT"] = "EXTERNAL_EVENT";
    return EventType2;
  })(EventType || {});
  var LOG_EVENT_TYPE = /* @__PURE__ */ ((LOG_EVENT_TYPE2) => {
    LOG_EVENT_TYPE2["LOG_MICRO_CONVERSION"] = "logMicroConversion";
    LOG_EVENT_TYPE2["LOG_AUTO_MICRO_CONVERSION"] = "logAutoMicroConversion";
    LOG_EVENT_TYPE2["LOG_TELEMETRY"] = "logTelemetry";
    LOG_EVENT_TYPE2["LOG_CONVERSION"] = "logConversion";
    LOG_EVENT_TYPE2["LOG_FUNNEL_STEP"] = "logFunnelStep";
    LOG_EVENT_TYPE2["LOG_ESP_MICRO_CONVERSION"] = "logEspMicroConversion";
    LOG_EVENT_TYPE2["LOG_BEACON_REQUEST"] = "logBeaconRequest";
    LOG_EVENT_TYPE2["LOG_CUSTOM_FORM_IMPRESSION"] = "logCustomFormImpression";
    LOG_EVENT_TYPE2["LOG_CUSTOM_FORM_SUBMISSION"] = "logCustomFormSubmission";
    return LOG_EVENT_TYPE2;
  })(LOG_EVENT_TYPE || {});
  var log2 = (container = pn.container) => {
    const ajax3 = container.resolve("ajax");
    const util2 = container.resolve("util");
    const postmessage2 = container.resolve("postmessage");
    const name3 = "log";
    postmessage2.subscribe("iframeLogRequest", (data) => {
      const logData = "browser_id" in data.queryParams ? data.queryParams : appendBrowserId(data.queryParams);
      doLog(data.url, logData);
    });
    const prepareQueryStringParams = (params) => {
      var queryParams = [];
      for (var key2 in params) {
        var value = params[key2];
        queryParams.push(encodeURIComponent(key2) + "=" + encodeURIComponent(typeof value === "object" ? JSON.stringify(value) : value));
      }
      return queryParams.join("&");
    };
    const isDoNotTrackEnabled = () => {
      const doNotTrackOption = window.doNotTrack || window.navigator.doNotTrack || window.navigator.msDoNotTrack;
      if (!doNotTrackOption) {
        return false;
      }
      if (doNotTrackOption.charAt(0) === "1" || doNotTrackOption === "yes") {
        return true;
      }
      return false;
    };
    const doLog = (url, params) => {
      var queryParams = prepareQueryStringParams(params);
      if (!util2.isRelativeUrl(url.trim())) {
        util2.log("Url parameter is incorrect");
        return;
      }
      if (queryParams.length > 6e3) {
        ajax3.request({
          type: "POST",
          url: pn.getTrackingEndpoint() + url,
          data: queryParams
        });
      } else {
        ajax3.request({
          url: pn.getTrackingEndpoint() + url + "?" + queryParams,
          dataType: "jsonp"
        });
      }
    };
    const appendBrowserId = (val, includePageViewContext = false) => {
      var _a, _b;
      const browserId2 = util2.getBrowserId();
      const result = __spreadValues({}, val);
      const append2 = (name4, val2) => {
        if (val2) {
          result[name4] = val2;
        }
      };
      append2("browser_id", browserId2);
      if (includePageViewContext) {
        const context = util2.getPageViewContext();
        append2("page_title", context.pageTitle);
        append2("url", context.url);
        append2("page_view_id", context.pageViewId);
        append2("referrer", context.referrerUrl);
        append2("content_author", context.author);
        append2("content_created", (_a = context.created) == null ? void 0 : _a.toString());
        append2("content_section", context.section);
        append2("tags", ((_b = context.tags) == null ? void 0 : _b.join(",")) || null);
        append2("content_type", context.contentType);
      }
      return result;
    };
    const appendPageViewContext = (val) => appendBrowserId(val, true);
    const logMicroConversion = (trackingId, eventGroupId, customParams) => {
      var logEventParams = appendPageViewContext({
        tracking_id: trackingId,
        event_group_id: eventGroupId,
        custom_params: customParams || "",
        cookie_consents: util2.getCookieConsents(),
        previous_user_segments: util2.getUserSegmentsString(),
        user_state: util2.getUserState()
      });
      if (!trackingId) {
        util2.log("Parameter trackingId is required to log micro conversion.");
        return;
      }
      if (!eventGroupId) {
        util2.log("Parameter eventGroupId is required to log micro conversion.");
        return;
      }
      doLog("/api/v3/conversion/logMicroConversion", logEventParams);
    };
    const logAutoMicroConversion = (trackingId, eventGroupId, eventType, customParams) => {
      var logEventParams = appendPageViewContext({
        tracking_id: trackingId,
        event_type: eventType,
        event_group_id: eventGroupId,
        custom_params: customParams || "",
        cookie_consents: util2.getCookieConsents(),
        previous_user_segments: util2.getUserSegmentsString(),
        user_state: util2.getUserState()
      });
      if (!trackingId) {
        util2.log("Parameter trackingId is required to log auto micro conversion.");
        return;
      }
      if (!eventGroupId) {
        util2.log("Parameter eventGroupId is required to log auto micro conversion.");
        return;
      }
      console.log(logEventParams);
      doLog("/api/v3/conversion/logAutoMicroConversion", logEventParams);
    };
    const logEspMicroConversion = (trackingId, espWidgetId, eventGroupId, eventType, customParams) => {
      var logEventParams = appendPageViewContext({
        tracking_id: trackingId,
        esp_widget_id: espWidgetId,
        event_type: eventType,
        event_group_id: eventGroupId,
        custom_params: customParams || "",
        cookie_consents: util2.getCookieConsents(),
        previous_user_segments: util2.getUserSegmentsString(),
        user_state: util2.getUserState()
      });
      if (!trackingId) {
        util2.log("Parameter trackingId is required to log esp micro conversion.");
        return;
      }
      if (!eventGroupId) {
        util2.log("Parameter eventGroupId is required to log esp micro conversion.");
        return;
      }
      if (!espWidgetId) {
        util2.log("Parameter espWidgetId is required to log esp micro conversion.");
        return;
      }
      doLog("/api/v3/conversion/logEspMicroConversion", logEventParams);
    };
    const _doLogConversion = (trackingId, termId, termName, stepNumber, amount, currency, customParams, conversionCategory) => {
      var logParams = appendPageViewContext({
        tracking_id: trackingId,
        term_id: termId,
        term_name: termName,
        cookie_consents: util2.getCookieConsents(),
        previous_user_segments: util2.getUserSegmentsString(),
        user_state: util2.getUserState()
      });
      if (!trackingId) {
        util2.log("Parameter trackingId is required to log conversion.");
        return;
      }
      if (!termId) {
        util2.log("Parameter termId is required to log conversion.");
        return;
      }
      if (!termName) {
        util2.log("Parameter termName is required to log conversion.");
        return;
      }
      if (typeof stepNumber !== "undefined") {
        logParams.step_number = stepNumber;
      }
      if (typeof amount !== "undefined") {
        logParams.amount = amount;
      }
      if (typeof currency !== "undefined") {
        logParams.currency = currency;
      }
      if (typeof customParams !== "undefined") {
        logParams.custom_params = customParams;
      }
      if (typeof conversionCategory !== "undefined") {
        logParams.conversion_category = conversionCategory;
      }
      doLog("/api/v3/conversion/log", logParams);
    };
    const logConversion = (trackingId, termId, termName, stepNumber, amount, currency, customParams, conversionCategory) => {
      if (typeof trackingId === "object") {
        const params = trackingId;
        _doLogConversion(params.tracking_id, params.term_id, params.term_name, params.step_number, params.amount, params.currency, params.custom_params, params.conversion_category);
      } else {
        _doLogConversion(trackingId, termId, termName, stepNumber, amount, currency, customParams, conversionCategory);
      }
    };
    const logFunnelStep = (trackingId, stepNumber, stepName, customParams) => {
      var logEventParams = appendPageViewContext({
        tracking_id: trackingId,
        step_number: stepNumber,
        step_name: stepName,
        custom_params: customParams || "",
        cookie_consents: util2.getCookieConsents(),
        previous_user_segments: util2.getUserSegmentsString(),
        user_state: util2.getUserState()
      });
      if (!trackingId) {
        util2.log("Parameter trackingId is required to log funnel step.");
        return;
      }
      if (!stepNumber) {
        util2.log("Parameter stepNumber is required to log funnel step.");
        return;
      }
      if (!stepName) {
        util2.log("Parameter stepName is required to log funnel step.");
        return;
      }
      doLog("/api/v3/conversion/logFunnelStep", logEventParams);
    };
    const logCustomFormImpression = (trackingId, formName, source) => {
      if (!formName) {
        util2.log("Parameter formName is required to log impression.");
      }
      if (!source) {
        util2.log("Parameter source is required to log impression.");
      }
      var data = {
        aid: pn.aid,
        pageview_id: pn.main.fetchPageViewId(),
        custom_form_name: formName,
        custom_form_source: source,
        cookie_consents: util2.getCookieConsents(),
        browser_id: util2.getBrowserId()
      };
      var token = pn.user.getProvider().getToken();
      if (token) {
        data.user_token = token;
      }
      if (trackingId) {
        data.tracking_id = trackingId;
      }
      return doLog("/api/v3/customform/log/impression", data);
    };
    const logCustomFormSubmission = (trackingId, formName, source) => {
      if (!formName) {
        util2.log("Parameter formName is required to log submission.");
      }
      if (!source) {
        util2.log("Parameter source is required to log submission.");
      }
      var data = {
        aid: pn.aid,
        pageview_id: pn.main.fetchPageViewId(),
        custom_form_name: formName,
        custom_form_source: source,
        cookie_consents: util2.getCookieConsents(),
        browser_id: util2.getBrowserId()
      };
      var token = pn.user.getProvider().getToken();
      if (token) {
        data.user_token = token;
      }
      if (trackingId) {
        data.tracking_id = trackingId;
      }
      return doLog("/api/v3/customform/log/submission", data);
    };
    const logTelemetryRequest = (url, queryParams) => {
      if (isDoNotTrackEnabled()) {
        return;
      }
      const queryString = url + "?" + prepareQueryStringParams(queryParams);
      if (navigator.sendBeacon) {
        navigator.sendBeacon(queryString);
      } else {
        ajax3.send(queryString, null, "POST", null, "application/json", true);
      }
    };
    const logBeaconRequest = (url, params) => {
      if (isDoNotTrackEnabled()) {
        return;
      }
      var preparedQueryStringParams = prepareQueryStringParams(params);
      var queryString = url + "?" + preparedQueryStringParams;
      if (navigator.sendBeacon) {
        if (queryString.length > 6e3) {
          var blob = new Blob([preparedQueryStringParams], { type: "application/x-www-form-urlencoded" });
          navigator.sendBeacon(url, blob);
        } else {
          navigator.sendBeacon(queryString);
        }
      } else {
        var ie9 = navigator.appVersion.indexOf("MSIE 9") !== -1;
        var ajaxSettings;
        if (ie9) {
          ajaxSettings = {
            dataType: "jsonp",
            url: queryString
          };
        } else {
          ajaxSettings = {
            type: "post",
            url: queryString,
            async: false,
            xhrFields: {
              withCredentials: true
            }
          };
        }
        ajaxSettings.error = function(...args) {
          util2.debug("Beacon request has been failed", ...args);
        };
        ajax3.request(ajaxSettings);
      }
    };
    const handleEvent = (handlingEventType, eventParams) => {
      const {
        trackingId,
        termId,
        termName,
        stepNumber,
        stepName,
        amount,
        currency,
        customParams,
        conversionCategory,
        eventGroupId,
        eventType,
        url,
        params,
        formName,
        source,
        espWidgetId,
        body
      } = eventParams;
      switch (handlingEventType) {
        case "logTelemetry" /* LOG_TELEMETRY */:
          logTelemetryRequest(url, params);
          return;
        case "logConversion" /* LOG_CONVERSION */:
          logConversion(trackingId, termId, termName, stepNumber, amount, currency, customParams, conversionCategory);
          return;
        case "logAutoMicroConversion" /* LOG_AUTO_MICRO_CONVERSION */:
          logAutoMicroConversion(trackingId, eventGroupId, eventType, customParams);
          return;
        case "logBeaconRequest" /* LOG_BEACON_REQUEST */:
          logBeaconRequest(url, params);
          return;
        case "logCustomFormImpression" /* LOG_CUSTOM_FORM_IMPRESSION */:
          logCustomFormImpression(trackingId, formName, source);
          return;
        case "logCustomFormSubmission" /* LOG_CUSTOM_FORM_SUBMISSION */:
          logCustomFormSubmission(trackingId, formName, source);
          return;
        case "logEspMicroConversion" /* LOG_ESP_MICRO_CONVERSION */:
          logEspMicroConversion(trackingId, espWidgetId, eventGroupId, eventType, customParams);
          return;
        case "logFunnelStep" /* LOG_FUNNEL_STEP */:
          logFunnelStep(trackingId, stepNumber, stepName, customParams);
          return;
        case "logMicroConversion" /* LOG_MICRO_CONVERSION */:
          logMicroConversion(trackingId, eventGroupId, customParams);
          return;
      }
    };
    return {
      name: name3,
      logMicroConversion,
      logConversion,
      logFunnelStep,
      logEspMicroConversion,
      logBeaconRequest,
      logAutoMicroConversion,
      __protected__: {
        handleEvent,
        logCustomFormImpression,
        logCustomFormSubmission,
        logEspMicroConversion,
        logAutoMicroConversion
      },
      __private__: {
        doLog,
        logBeaconRequest
      }
    };
  };
  pn.container.register("log", {
    useValue: log2()
  });
  pn.log = pn.container.resolve("log");

  // ../src/lib/fbpixel.ts
  var FB_PIXEL_EVENT_TYPE = /* @__PURE__ */ ((FB_PIXEL_EVENT_TYPE2) => {
    FB_PIXEL_EVENT_TYPE2["TRACK_EVENT"] = "track";
    FB_PIXEL_EVENT_TYPE2["TRACK_CUSTOM_EVENT"] = "trackCustom";
    return FB_PIXEL_EVENT_TYPE2;
  })(FB_PIXEL_EVENT_TYPE || {});
  var fbpixel = (() => {
    const util2 = pn.container.resolve("util");
    const name3 = "fbpixel";
    let _isInitialized = false;
    const init = () => {
      if (_isInitialized) {
        return;
      }
      var fbPixelId = pn.getFbPixelId();
      if (!fbPixelId) {
        util2.error("fbpixel: Facebook Pixel ID is not defined");
        return;
      }
      util2.log("fbpixel: Initialize Facebook Pixel tracking", fbPixelId);
      !function(f2, b, e, v, n, t, s) {
        if (f2.fbq)
          return;
        n = f2.fbq = function() {
          n.callMethod ? n.callMethod.apply(n, arguments) : n.queue.push(arguments);
        };
        if (!f2._fbq)
          f2._fbq = n;
        n.push = n;
        n.loaded = true;
        n.version = "2.0";
        n.queue = [];
        t = b.createElement(e);
        t.async = true;
        t.src = v;
        s = b.getElementsByTagName(e)[0];
        s.parentNode.insertBefore(t, s);
      }(window, document, "script", "https://connect.facebook.net/en_US/fbevents.js");
      window.fbq("set", "autoConfig", "false", fbPixelId);
      window.fbq("init", fbPixelId);
      _isInitialized = true;
    };
    const handleEvent = (eventType, { eventName, eventParams }) => {
      switch (eventType) {
        case "track" /* TRACK_EVENT */:
          _doTrackEvent("track" /* TRACK_EVENT */, eventName, eventParams);
          return;
        case "trackCustom" /* TRACK_CUSTOM_EVENT */:
          _doTrackEvent("trackCustom" /* TRACK_CUSTOM_EVENT */, eventName, eventParams);
          return;
      }
    };
    const _doTrackEvent = (trackMethod, eventName, customData) => {
      if (!_isInitialized) {
        util2.log("fbpixel: Skip tracking event - Facebook Pixel is not initalized", eventName, customData);
        return;
      }
      if (!customData) {
        customData = {};
      }
      util2.log("fbpixel: Track Facebook Pixel event", eventName, customData);
      window.fbq(trackMethod, eventName, customData);
    };
    const isInitialized = () => {
      return _isInitialized;
    };
    return {
      name: name3,
      isInitialized,
      __private__: {
        isInitialized
      },
      __protected__: {
        init,
        handleEvent
      }
    };
  })();
  pn.container.register("fbpixel", {
    useValue: fbpixel
  });
  pn.fbpixel = pn.container.resolve("fbpixel");

  // ../src/lib/clientConfiguration/clientConfiguration.ts
  var clientConfiguration = (container = pn.container) => {
    const ajax3 = container.resolve("ajax");
    let configuration;
    let configurationPromise;
    const getConfiguration = () => __async(void 0, null, function* () {
      if (configuration) {
        return configuration;
      }
      if (configurationPromise) {
        return configurationPromise;
      }
      configurationPromise = new Promise((resolve, reject) => {
        ajax3.request({
          url: pn.getApiEndpoint() + "/anon/assets/sdk-runtime-config.js?aid=" + pn.aid,
          type: "GET",
          success: (response) => {
            if ((response == null ? void 0 : response.code) === 0) {
              configuration = response.client_configurations_dto;
              resolve(response.client_configurations_dto);
              configurationPromise = void 0;
            } else {
              reject();
            }
          },
          error: () => reject()
        });
      });
      return configurationPromise;
    });
    return {
      configuration,
      getConfiguration
    };
  };
  pn.container.register("clientConfiguration", {
    useValue: clientConfiguration()
  });

  // ../src/lib/googleAnalytics/gaCollectingService.ts
  var gaCollectingService = (() => {
    let excludedEvents = {};
    let gaParams = {};
    const setParam = (paramName, paramValue) => {
      if (paramValue) {
        gaParams[paramName] = paramValue;
      }
    };
    const setParamMap = (paramsMap) => {
      gaParams = __spreadValues(__spreadValues({}, gaParams), paramsMap);
    };
    const getParams = () => {
      return __spreadValues({
        aid: pn.aid,
        tags: pn.tags,
        debug: pn.debug,
        url: window.location.href
      }, gaParams);
    };
    const isEventExcluded = (eventName) => excludedEvents[eventName];
    const setExcludedEvents = (events) => {
      excludedEvents = __spreadValues(__spreadValues({}, excludedEvents), events);
    };
    return {
      name: "gaCollectingService",
      setParam,
      getParams,
      setParamMap,
      isEventExcluded,
      setExcludedEvents
    };
  })();
  pn.container.register("gaCollectingService", {
    useValue: gaCollectingService
  });
  pn.gaCollectingService = pn.container.resolve("gaCollectingService");

  // ../src/lib/googleAnalytics/constants.ts
  var EVENT_NON_INTERACTION_VALUES = {
    experienceExecute: true,
    meterActive: true,
    meterExpired: true,
    beforeBrowserEvent: false,
    setResponseVariable: true,
    startCheckout: false,
    showOffer: true,
    showTemplate: true,
    termSelected: true,
    promoApplied: true,
    promoInvalid: true,
    submitPayment: false,
    checkoutCustomEvent: true,
    checkoutStateChange: false,
    receiptDisplayed: false,
    checkoutSuccess: true,
    checkoutRestarted: false,
    checkoutError: true,
    checkoutClose: false,
    publisherLoginRequired: false,
    loginRequired: false,
    loginDisplayed: false,
    registrationDisplayed: false,
    loginSuccess: true,
    registrationSuccess: true,
    logout: false
  };

  // ../src/lib/googleAnalytics/gaService.ts
  var gaService = (() => {
    const util2 = pn.container.resolve("util");
    const api2 = pn.container.resolve("api");
    const postmessage2 = pn.container.resolve("postmessage");
    const gaCollectingService2 = pn.container.resolve("gaCollectingService");
    const clientConfiguration2 = pn.container.resolve("clientConfiguration");
    const name3 = "gaService";
    const TRACKER_NAME = "pianoTracker";
    const METRICS_TRACKER_NAME = "performanceTracker";
    const GA_ACCOUNT_KEY = "gaAccount";
    const METRICS_GA_ACCOUNT_KEY = "metricsGAAccount";
    const TRACK_ONLY_AIDS_KEY = "trackOnlyAids";
    const DISABLED_VALUE = "disabled";
    const STORAGE_EXPIRATION = 1;
    const config = {
      gaAccount: void 0,
      trackerName: TRACKER_NAME,
      trackOnlyAids: [],
      metricsGAAccount: void 0,
      isGAEnabled: false,
      isGAAppended: false,
      isMetricsEnabled: false,
      isTrackerAppended: false,
      isMetricsTrackerAppended: false
    };
    const _batch = [];
    let _clientId;
    let _initialised = false;
    let _isFirstStart = true;
    let _isGAInitialising = false;
    let _isMetricsInitialising = false;
    const _metricsBatch = [];
    const emitEvent = (params) => {
      params.hitType = "event";
      params.nonInteraction = EVENT_NON_INTERACTION_VALUES[params.eventCategory];
      if (!config.isTrackerAppended) {
        batchPush("send", params);
        initGA();
        return;
      }
      if (!config.isGAEnabled) {
        return;
      }
      if (!window.ga || !config.isTrackerAppended) {
        batchPush("send", params);
        return;
      }
      if (_batch.length) {
        batchExecute();
      }
      gaWrapper("send", params);
    };
    const emitMetricsEvent = (params) => {
      params.hitType = "timing";
      if (!config.isMetricsTrackerAppended) {
        metricsBatchPush("send", params);
        initMetricsGA();
        return;
      }
      if (!config.isMetricsEnabled) {
        return;
      }
      if (!window.ga || !config.isMetricsTrackerAppended) {
        metricsBatchPush("send", params);
        return;
      }
      if (_metricsBatch.length) {
        metricsBatchExecute();
      }
      metricsGAWrapper("send", params);
    };
    const getGAAccount = () => {
      return config.gaAccount;
    };
    const getClientId = () => {
      return _clientId;
    };
    const setClientId = (clientId) => {
      _clientId = clientId;
    };
    const recreateWithClientId = (clientId) => {
      _clientId = clientId;
      initGA();
    };
    const setTrackerName = (name4) => {
      config.trackerName = name4;
    };
    const metricsTrackerAppended = () => {
      config.isMetricsTrackerAppended = true;
      _isMetricsInitialising = false;
      metricsBatchExecute();
    };
    const trackerAppended = () => {
      config.isTrackerAppended = true;
      postmessage2.broadcast("gaAppended", { clientId: _clientId, gaAccount: config.gaAccount });
      _isGAInitialising = false;
      batchExecute();
    };
    function initGA() {
      if (_isGAInitialising) {
        return;
      }
      _isGAInitialising = true;
      if (_isFirstStart) {
        setTimeout(function() {
          _isFirstStart = false;
          deferredInitGA();
        }, 3e3);
      } else {
        deferredInitGA();
      }
    }
    function deferredInitGA() {
      initConfig();
      if (!config.gaAccount) {
        _getGAAccount().then(() => {
          return injectTracker();
        }).catch(() => {
        });
        return;
      }
      injectTracker().catch(() => {
      });
    }
    function initMetricsGA() {
      if (_isMetricsInitialising) {
        return;
      }
      _isMetricsInitialising = true;
      initConfig();
      if (!config.metricsGAAccount) {
        getPerformanceMetrics().then(() => {
          return injectMetricsTracker();
        }).catch((err) => {
          util2.error(`PN catch: something vent wrong with GA injection: ${err}`);
        });
        return;
      }
      injectMetricsTracker().catch((err) => {
        util2.error(`PN catch: something vent wrong with GA injection: ${err}`);
      });
    }
    const batchPush = (action, params) => {
      _batch.push({ action, params });
    };
    const batchExecute = () => {
      if (!window.ga || !config.isTrackerAppended) {
        return;
      }
      while (_batch.length) {
        const args = _batch.pop();
        gaWrapper(args.action, args.params);
      }
    };
    const metricsBatchPush = (action, params) => {
      _metricsBatch.push({ action, params });
    };
    const metricsBatchExecute = () => {
      if (!window.ga || !config.isMetricsTrackerAppended) {
        return;
      }
      while (_metricsBatch.length) {
        const args = _metricsBatch.pop();
        metricsGAWrapper(args.action, args.params);
      }
    };
    const gaWrapper = (action, params) => {
      if (gaCollectingService2.isEventExcluded(params.eventCategory)) {
        return;
      }
      if (!window.ga || !config.isTrackerAppended) {
        batchPush(action, params);
        return;
      }
      window.ga(config.trackerName + "." + action, params);
    };
    const metricsGAWrapper = (action, params) => {
      if (!config.isMetricsEnabled) {
        return;
      }
      if (!window.ga || !config.isMetricsTrackerAppended) {
        metricsBatchPush(action, params);
        return;
      }
      window.ga(METRICS_TRACKER_NAME + "." + action, params);
    };
    const initConfig = () => {
      if (_initialised) {
        return;
      }
      if (!!tp.gaClientId) {
        _clientId = tp.gaClientId;
      }
      if (util2.__protected__.hasLocalStorage()) {
        const gaAccount = util2.__protected__.getLocalStorageItem(GA_ACCOUNT_KEY);
        const metricsGAAccount = util2.__protected__.getLocalStorageItem(METRICS_GA_ACCOUNT_KEY);
        const trackOnlyAids = util2.__protected__.getLocalStorageItem(TRACK_ONLY_AIDS_KEY);
        config.isGAEnabled = !!gaAccount && gaAccount !== DISABLED_VALUE;
        config.isMetricsEnabled = !!metricsGAAccount && metricsGAAccount !== DISABLED_VALUE;
        config.gaAccount = gaAccount;
        config.metricsGAAccount = metricsGAAccount;
        config.trackOnlyAids = trackOnlyAids ? trackOnlyAids : [];
      }
      _initialised = true;
    };
    function _getGAAccount() {
      return __async(this, null, function* () {
        const response = yield clientConfiguration2.getConfiguration();
        return setGA(response.ga_account);
      });
    }
    function getPerformanceMetrics() {
      return __async(this, null, function* () {
        const response = yield clientConfiguration2.getConfiguration();
        return setMetrics({
          is_enabled: response.is_performance_metrics_enabled,
          ga_account: response.performance_metrics_ga_account,
          track_only_aids: response.performance_metrics_track_only_aids
        });
      });
    }
    const setGA = (gaAccount) => {
      config.isGAEnabled = !!gaAccount;
      config.gaAccount = !!gaAccount ? gaAccount : DISABLED_VALUE;
      util2.__protected__.setLocalStorageItem("vx", GA_ACCOUNT_KEY, config.gaAccount, STORAGE_EXPIRATION);
    };
    const setMetrics = (performanceMetrics2) => {
      config.isMetricsEnabled = JSON.parse(performanceMetrics2.is_enabled);
      config.metricsGAAccount = config.isMetricsEnabled ? performanceMetrics2.ga_account : DISABLED_VALUE;
      config.trackOnlyAids = config.isMetricsEnabled ? JSON.parse(performanceMetrics2.track_only_aids) : [];
      util2.__protected__.setLocalStorageItem("vx", TRACK_ONLY_AIDS_KEY, config.trackOnlyAids, STORAGE_EXPIRATION);
      util2.__protected__.setLocalStorageItem("vx", METRICS_GA_ACCOUNT_KEY, config.metricsGAAccount, STORAGE_EXPIRATION);
    };
    function injectTracker() {
      return new Promise((resolve, reject) => {
        if (!config.isGAEnabled) {
          reject();
        } else {
          injectGA().then(() => {
            if (config.isGAAppended) {
              if (!config.isTrackerAppended) {
                try {
                  const script = document.createElement("script");
                  script.innerHTML = gaAppendingScript();
                  document.head.appendChild(script);
                  config.isTrackerAppended = true;
                  resolve(null);
                } catch (e) {
                  reject();
                }
              } else {
                resolve(null);
              }
            } else {
              reject();
            }
          }).catch((err) => {
          });
        }
      });
    }
    function injectMetricsTracker() {
      return new Promise((resolve, reject) => {
        if (!config.isMetricsEnabled) {
          resolve("isMetricsEnabled !== true");
          return;
        } else {
          injectGA().then(() => {
            if (config.isGAAppended) {
              if (!config.isMetricsTrackerAppended) {
                try {
                  const shouldBeTracked = !config.trackOnlyAids.length || config.trackOnlyAids.contains(tp.aid);
                  const script = document.createElement("script");
                  const gaAccountMatched = new RegExp("^UA-[0-9a-zA-Z]*-[0-9a-zA-Z]*$").test(config.metricsGAAccount);
                  if (!gaAccountMatched) {
                    reject();
                    return;
                  }
                  script.innerHTML = `
                  ga(function() {
                    if (${shouldBeTracked}) {
                      ga('create', '${config.metricsGAAccount}', 'auto', '${METRICS_TRACKER_NAME}', { storage: 'none' });
                      tp.gaService.metricsTrackerAppended();
                    }
                  });
                  `;
                  document.head.appendChild(script);
                  config.isMetricsTrackerAppended = true;
                  resolve(null);
                } catch (e) {
                  reject();
                }
              } else {
                resolve(null);
              }
            } else {
              reject();
            }
          });
        }
      });
    }
    function injectGA() {
      return new Promise((resolve, reject) => {
        if (config.isGAAppended) {
          resolve(null);
        } else {
          try {
            const script = document.createElement("script");
            script.innerHTML = `
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
          `;
            document.head.appendChild(script);
            config.isGAAppended = true;
            resolve(null);
          } catch (e) {
            reject();
          }
        }
      });
    }
    function gaAppendingScript() {
      const gaAccountMatched = new RegExp("^UA-[0-9a-zA-Z]*-[0-9a-zA-Z]*$").test(config.gaAccount);
      const gaClientIdMatched = new RegExp("([{]?[0-9a-fA-F]{8}-([0-9a-fA-F]{4}-){3}[0-9a-fA-F]{12}[}]?)|([0-9]*\\.[0-9]*)").test(_clientId || "");
      if (!gaAccountMatched) {
        return "";
      }
      let script = `ga(function() {
        ga('create', '${config.gaAccount}', 'auto', '${TRACKER_NAME}'`;
      if (!!_clientId && gaClientIdMatched) {
        script += `, { clientId: '${_clientId}' });`;
      } else {
        script += `);
        tp.gaService.setClientId(ga.getByName('${TRACKER_NAME}').get('clientId'));`;
      }
      script += "tp.gaService.trackerAppended(); });";
      return script;
    }
    const handleEvent = (eventType, eventParams) => {
      switch (eventType) {
        case "emitGAEvent" /* EMIT_GA_EVENT */:
          emitEvent(eventParams);
          return;
        case "emitMetricsEvent" /* EMIT_METRICS_EVENT */:
          emitMetricsEvent(eventParams);
          return;
      }
    };
    return {
      name: name3,
      getClientId,
      getGAAccount,
      metricsTrackerAppended,
      recreateWithClientId,
      setClientId,
      setTrackerName,
      trackerAppended,
      __protected__: {
        handleEvent
      }
    };
  })();
  pn.container.register("gaService", {
    useValue: gaService
  });
  pn.gaService = pn.container.resolve("gaService");

  // ../src/lib/googleAnalytics/ga4Service.ts
  var ga4Service = ((container = pn.container) => {
    const gaCollectingService2 = container.resolve("gaCollectingService");
    const pianoPrefix = "piano_";
    const googleRestrictedParams = ["trackingId"];
    let config = {
      measurementId: ""
    };
    let pendingEvents = [];
    const isTagLoaded = () => typeof window.gtag === "function";
    const loadGoogleTagManager = () => {
      if (isTagLoaded()) {
        return;
      }
      const tagScriptElement = document.createElement("script");
      tagScriptElement.async = true;
      tagScriptElement.src = `https://www.googletagmanager.com/gtag/js?id=${config.measurementId}`;
      document.head.appendChild(tagScriptElement);
    };
    const stringifyEventParameters = (eventParams) => {
      if (!eventParams) {
        eventParams = {};
      }
      return JSON.stringify(eventParams);
    };
    const getGtagInitScript = () => {
      if (!isTagLoaded()) {
        return "window.dataLayer = window.dataLayer || [];\nfunction gtag(){dataLayer.push(arguments);}\ngtag('js', new Date());";
      }
      return "";
    };
    const getConfigScript = (config2) => {
      if (config2.eventParameters) {
        return `gtag('config', '${config2.measurementId}', ${stringifyEventParameters(config2.eventParameters)});`;
      }
      return `gtag('config', '${config2.measurementId}');`;
    };
    const getGoogleTag = (config2) => {
      const generateTagScript = document.createElement("script");
      generateTagScript.innerHTML = `${getGtagInitScript()}
function setGoogleTagConfig() {
  if (${!config2.measurementId}) { return; }
  ${getConfigScript(config2)}
}
setGoogleTagConfig();`;
      return generateTagScript;
    };
    const postponeEventSending = (eventParams) => {
      pendingEvents.push(eventParams);
    };
    const sendPendingEvents = () => {
      pendingEvents.forEach((event) => {
        if (!event.sendTo) {
          event.sendTo = config.measurementId;
        }
        sendCustomEvent(event);
      });
      pendingEvents = [];
    };
    const getEventParams = (eventType, params) => {
      return {
        name: params.eventCategory,
        sendTo: config.measurementId,
        params: buildEventParams(params, gaCollectingService2.getParams())
      };
    };
    const toSnakeCase = (camelCaseString) => {
      return camelCaseString.replace(/[A-Z]+(?![a-z])|[A-Z]/g, (matchingPart, index) => index ? "_" + matchingPart : matchingPart).toLowerCase();
    };
    const isParamInvalid = (paramKey, paramValue) => {
      return paramKey.includes("user") || paramKey === "nonInteraction" || typeof paramValue === "object" || typeof paramValue === "function";
    };
    const formatParamKey = (key2) => {
      if (googleRestrictedParams.includes(key2)) {
        key2 = pianoPrefix + key2;
      }
      return toSnakeCase(key2);
    };
    const buildAdditionalInfo = (eventParamValue = "", placeholder, delimiter, collectedParams) => {
      const additionalKeys = ["offerId", "aid", "templateId", "templateVariantId"];
      if (eventParamValue && eventParamValue.includes(delimiter)) {
        return eventParamValue;
      }
      return additionalKeys.reduce((additionalInfo, key2) => {
        if (!collectedParams[key2]) {
          return additionalInfo;
        }
        if (additionalInfo.length) {
          additionalInfo += placeholder;
        }
        additionalInfo += `${key2}${delimiter}${collectedParams[key2]}`;
        return additionalInfo;
      }, eventParamValue);
    };
    const buildEventParams = (eventParams, collectedParams) => {
      const paramMap = __spreadProps(__spreadValues(__spreadValues({}, collectedParams), eventParams), {
        "non_interaction": EVENT_NON_INTERACTION_VALUES[eventParams.eventCategory],
        "event_action": buildAdditionalInfo(eventParams.eventAction, "____", "_", collectedParams),
        "event_label": buildAdditionalInfo(eventParams.eventLabel, " ", ":", collectedParams)
      });
      return Object.keys(paramMap).reduce((params, paramKey) => {
        const paramValue = paramMap[paramKey];
        if (isParamInvalid(paramKey, paramValue)) {
          return params;
        }
        params[formatParamKey(paramKey)] = paramValue;
        return params;
      }, {});
    };
    const setGa4Config = (gaConfig) => {
      config = gaConfig;
      appendGoogleTag();
    };
    const getMeasurementId = () => config.measurementId;
    const appendGoogleTag = () => {
      if (!config.measurementId) {
        return;
      }
      loadGoogleTagManager();
      document.head.appendChild(getGoogleTag(config));
    };
    const sendCustomEvent = (eventParams) => {
      if (gaCollectingService2.isEventExcluded(eventParams.name)) {
        return;
      }
      window.gtag("event", eventParams.name, __spreadValues({
        "send_to": eventParams.sendTo
      }, eventParams.params));
    };
    const handleEvent = (eventType, eventParams) => {
      if (eventType !== "emitGAEvent" /* EMIT_GA_EVENT */) {
        return;
      }
      const googleEventParams = getEventParams(eventType, eventParams);
      if (isTagLoaded() && googleEventParams.sendTo) {
        sendCustomEvent(googleEventParams);
        sendPendingEvents();
        return;
      }
      postponeEventSending(googleEventParams);
    };
    return {
      name: "ga4Service",
      getMeasurementId,
      appendGoogleTag,
      sendCustomEvent,
      setGa4Config,
      __protected__: {
        handleEvent
      }
    };
  })();
  pn.container.register("ga4Service", {
    useValue: ga4Service
  });
  pn.ga4Service = pn.container.resolve("ga4Service");

  // ../src/lib/acp.ts
  var ACP_CHECKOUT_EVENTS = /* @__PURE__ */ ((ACP_CHECKOUT_EVENTS2) => {
    ACP_CHECKOUT_EVENTS2["purge"] = "purge";
    ACP_CHECKOUT_EVENTS2["dismissTemplate"] = "acp-close";
    ACP_CHECKOUT_EVENTS2["retainSubscription"] = "acp-retain-subscription";
    ACP_CHECKOUT_EVENTS2["cancelSubscription"] = "acp-cancel-subscription";
    return ACP_CHECKOUT_EVENTS2;
  })(ACP_CHECKOUT_EVENTS || {});
  var ACP_MYACCOUNT_EVENTS = /* @__PURE__ */ ((ACP_MYACCOUNT_EVENTS2) => {
    ACP_MYACCOUNT_EVENTS2["autoRenewalDisabled"] = "acp-auto-renewal-disabled";
    ACP_MYACCOUNT_EVENTS2["subscriptionCancellation"] = "acp-subscription-cancellation";
    return ACP_MYACCOUNT_EVENTS2;
  })(ACP_MYACCOUNT_EVENTS || {});
  var ACP_COMPOSER_EVENTS = /* @__PURE__ */ ((ACP_COMPOSER_EVENTS2) => {
    ACP_COMPOSER_EVENTS2["dismissTemplate"] = "dismissTemplate";
    ACP_COMPOSER_EVENTS2["finalConfirmation"] = "finalConfirmation";
    ACP_COMPOSER_EVENTS2["autoRenewalDisabled"] = "autoRenewalDisabled";
    ACP_COMPOSER_EVENTS2["subscriptionCancellation"] = "subscriptionCancellation";
    return ACP_COMPOSER_EVENTS2;
  })(ACP_COMPOSER_EVENTS || {});
  var acp = ((container = pn.container) => {
    const postmessage2 = container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const templateInteractionInitialConfig = {
      autoRenewalDisabled: false,
      subscriptionCancellation: false
    };
    const currentUserInitialConfig = {
      token: "",
      isFlowInProgress: false,
      templateInteractionConfig: __spreadValues({}, templateInteractionInitialConfig)
    };
    let currentUserConfig = __spreadValues({}, currentUserInitialConfig);
    const getContinuationCallbackParams = (eventParams, templateInteractionParam) => {
      if (typeof (eventParams == null ? void 0 : eventParams.autoRenew) !== "boolean" && typeof (eventParams == null ? void 0 : eventParams.cancellationType) !== "string") {
        return templateInteractionParam instanceof Error;
      }
      return {
        isFlowError: templateInteractionParam instanceof Error,
        autoRenew: eventParams == null ? void 0 : eventParams.autoRenew,
        cancellationType: eventParams == null ? void 0 : eventParams.cancellationType,
        pageViewId: dataLayer.get("pageViewId"),
        tbc: util2.getTbcCookie(),
        subscriptionId: eventParams == null ? void 0 : eventParams.subscriptionId,
        trackingId: typeof templateInteractionParam === "string" ? templateInteractionParam : void 0
      };
    };
    const continuationCallback = (eventName, eventParams, templateInteractionParams) => {
      postmessage2.broadcast(eventName, getContinuationCallbackParams(eventParams, templateInteractionParams));
      setAcpFlowInProgress(false);
      if (templateInteractionParams instanceof Error && templateInteractionParams.message === "Subscription was upgraded") {
        window.location.reload();
      }
    };
    const sendTemplateInteractionEvent = (templateInteractionConfig) => {
      postmessage2.broadcast("setTemplateInteractionConfig", templateInteractionConfig);
    };
    const setAcpFlowInProgress = (isInProgress) => {
      currentUserConfig.isFlowInProgress = isInProgress;
    };
    const setCurrentUserConfig = (config) => {
      currentUserConfig = __spreadValues(__spreadValues({}, currentUserConfig), config);
    };
    const handleAcpEvent = (fireCallbacks, eventParams, iframeConfig, invokeCallbacksOnFire) => {
      var _a, _b;
      const eventName = ((_a = eventParams.params) == null ? void 0 : _a.eventName) || eventParams.event;
      const { experienceActionId, continuation, containerSelector, displayMode, trackingId } = iframeConfig;
      const selector = displayMode === "inline" ? containerSelector : null;
      const subscriptionId = (_b = eventParams.params) == null ? void 0 : _b.subscriptionId;
      const fireCustomEvent = () => {
        fireCallbacks("customEvent", __spreadValues({
          experienceActionId,
          continuation,
          trackingId,
          customEventName: eventName,
          containerSelector: selector
        }, eventParams.params), eventParams.sender, invokeCallbacksOnFire);
      };
      switch (eventName) {
        case "purge" /* purge */:
          fireCallbacks("dismissTemplate" /* dismissTemplate */, __spreadValues({
            experienceActionId,
            continuation,
            trackingId,
            offerType: iframeConfig.offerType || null
          }, eventParams.params), eventParams.sender, invokeCallbacksOnFire);
          break;
        case "acp-retain-subscription" /* retainSubscription */:
        case "acp-cancel-subscription" /* cancelSubscription */:
          fireCallbacks("finalConfirmation" /* finalConfirmation */, __spreadValues({
            experienceActionId,
            continuation,
            confirm: eventName === "acp-cancel-subscription" /* cancelSubscription */,
            trackingId
          }, eventParams.params), eventParams.sender, invokeCallbacksOnFire);
          fireCustomEvent();
          break;
        case "acp-auto-renewal-disabled" /* autoRenewalDisabled */:
          fireCallbacks("autoRenewalDisabled" /* autoRenewalDisabled */, {
            templateType: 1,
            continuation: continuationCallback.bind(void 0, `${"acp-auto-renewal-disabled" /* autoRenewalDisabled */}-result`, __spreadProps(__spreadValues({}, eventParams.params), { trackingId })),
            subscriptionId
          }, eventParams.sender);
          setAcpFlowInProgress(true);
          break;
        case "acp-subscription-cancellation" /* subscriptionCancellation */:
          fireCallbacks("subscriptionCancellation" /* subscriptionCancellation */, {
            templateType: 1,
            continuation: continuationCallback.bind(void 0, `${"acp-subscription-cancellation" /* subscriptionCancellation */}-result`, __spreadProps(__spreadValues({}, eventParams.params), { trackingId })),
            subscriptionId
          }, eventParams.sender);
          setAcpFlowInProgress(true);
          break;
        default:
          fireCustomEvent();
          break;
      }
    };
    const extendByAcpParams = (eventName, eventParams, iframeConfig) => {
      const { experienceActionId, continuation } = iframeConfig;
      return __spreadProps(__spreadValues({}, eventParams), {
        experienceActionId,
        continuation,
        customEventName: eventName
      });
    };
    const getComposerAcpEvents = () => {
      return Object.values(ACP_COMPOSER_EVENTS);
    };
    const sendTemplateInteractionActive = (iframeConfig) => {
      if (!iframeConfig.activateTemplateInteraction || !pn.user.isUserValid()) {
        sendTemplateInteractionEvent(templateInteractionInitialConfig);
        return;
      }
      const userToken = pn.user.getProvider().getToken();
      if (userToken === currentUserConfig.token || currentUserConfig.isFlowInProgress) {
        sendTemplateInteractionEvent(currentUserConfig.templateInteractionConfig);
        return;
      }
      const expectedEvents = [
        "subscriptionCancellation" /* subscriptionCancellation */,
        "autoRenewalDisabled" /* autoRenewalDisabled */
      ];
      pn.experience.executeTemplateInteraction({ templateType: 1 }).then(({ registeredEvents }) => {
        const composerEvents = registeredEvents;
        return expectedEvents.reduce((config, expectedEvent) => {
          if (composerEvents.includes(expectedEvent)) {
            return __spreadProps(__spreadValues({}, config), {
              [expectedEvent]: true
            });
          }
          return config;
        }, __spreadValues({}, templateInteractionInitialConfig));
      }).then((config) => {
        sendTemplateInteractionEvent(config);
        setCurrentUserConfig({
          templateInteractionConfig: config,
          token: userToken
        });
      }).catch(() => {
        sendTemplateInteractionEvent(templateInteractionInitialConfig);
        setCurrentUserConfig(currentUserInitialConfig);
      });
    };
    return {
      handleAcpEvent,
      extendByAcpParams,
      sendTemplateInteractionActive,
      getComposerAcpEvents
    };
  })();
  pn.container.register("acp", {
    useValue: acp
  });
  pn.acp = pn.container.resolve("acp");

  // ../src/lib/analytics.ts
  var analytics = (container = pn.container) => {
    const gaService2 = container.resolve("gaService");
    const ga4Service2 = container.resolve("ga4Service");
    const fbpixelService = container.resolve("fbpixel");
    const logService = container.resolve("log");
    const name3 = "analytics";
    const getInitMethod = (initMethod) => {
      return initMethod || function() {
      };
    };
    const createAnalyticDefaultMethods = (analyticService) => {
      return {
        initialize: getInitMethod(analyticService.__protected__.init),
        event: ({ eventType, payload }) => analyticService.__protected__.handleEvent(eventType, payload)
      };
    };
    const createGADefaultMethods = (gaService3, ga4Service3) => ({
      initialize: () => {
      },
      event: ({ eventType, payload }) => {
        gaService3.__protected__.handleEvent(eventType, payload);
        ga4Service3.__protected__.handleEvent(eventType, payload);
      }
    });
    const ga = createGADefaultMethods(gaService2, ga4Service2);
    const fbpixel2 = createAnalyticDefaultMethods(fbpixelService);
    const log3 = createAnalyticDefaultMethods(logService);
    return {
      name: name3,
      ga,
      fbpixel: fbpixel2,
      log: log3
    };
  };
  pn.container.register("analytics", {
    useValue: analytics()
  });
  pn.analytics = pn.container.resolve("analytics");

  // ../src/lib/logging.ts
  var logging = (() => {
    const api2 = pn.container.resolve("api");
    const analytics2 = pn.container.resolve("analytics");
    const name3 = "logging";
    const times = [];
    const ANON_LOG_ENDPOINT = "/telemetry/ux/timings";
    setTimeout(() => {
      sendTimeLog();
    }, 1e4);
    const getApiEndpoint = () => {
      return api2.getEndpoint() + ANON_LOG_ENDPOINT;
    };
    const sendTimeLog = (type2) => {
      if (Math.floor(Math.random() * 500) + 1 !== 255) {
        return;
      }
      const t = type2 || (pn.fullTPVersion ? "ts_c" : "ts_s");
      const params = {
        aid: pn.aid,
        type: t,
        actions: times
      };
      analytics2.log.event({
        eventType: "logTelemetry" /* LOG_TELEMETRY */,
        payload: {
          url: getApiEndpoint(),
          params
        }
      });
    };
    const setTime = (actionType, time, additionalTags) => {
      times.push({
        name: actionType,
        time,
        tags: additionalTags
      });
    };
    return {
      name: name3,
      setTime
    };
  })();
  pn.container.register("logging", {
    useValue: logging
  });
  pn.logging = pn.container.resolve("logging");

  // ../src/lib/credit.ts
  var CREDIT_COMMON_PATH = "/execution/credit";
  var REDEEM_COMMON_PATH = `${CREDIT_COMMON_PATH}/redeem`;
  var CHECK_COMMON_PATH = `${CREDIT_COMMON_PATH}/check`;
  var MANUAL_CREDIT_REDEEM = "manualCreditRedeemed";
  var CREDIT_CHECK = "creditChecked";
  var credit = (() => {
    const util2 = pn.container.resolve("util");
    const ajax3 = pn.container.resolve("ajax");
    const jqUtils2 = pn.container.resolve("jqUtils");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const consent4 = pn.container.resolve("consent");
    const prepareParams = (params) => {
      return Object.entries(params).reduce((res, [key2, value]) => {
        if (value || value === 0) {
          res[key2] = value;
        }
        return res;
      }, {});
    };
    const name3 = "credit";
    const XB_COOKIE = "xbc";
    const eventManager = eventUtils2.createEventManager([]);
    const getXbc = () => {
      return util2.__protected__.getCookie(XB_COOKIE) || void 0;
    };
    const getTbc = () => {
      return util2.getTbcCookie() || void 0;
    };
    const getEndpoint = () => {
      const domain = pn.getExperienceEndpoint(false);
      return `${domain}/${pn.aid}`;
    };
    const getDefaultParams = () => {
      return prepareParams({
        xbc: getXbc(),
        tbc: getTbc()
      });
    };
    const request = (url, data, queries) => {
      return new Promise((resolve, reject) => {
        const queryString = queries ? "?" + jqUtils2.param(queries) : "";
        const path = getEndpoint() + url + queryString;
        const param2 = getDefaultParams();
        const body = prepareParams(__spreadValues(__spreadValues({}, param2), data));
        if (!(body.cid && body.itemId && body.xbc)) {
          const errMsg = "credit: Error: Required params are absent";
          util2.debug(errMsg);
          reject({
            code: 0,
            message: errMsg
          });
        }
        ajax3.request({
          type: "post",
          url: path,
          data: __spreadValues(__spreadValues({}, param2), data),
          xhrFields: {
            withCredentials: true
          },
          error: (err) => {
            const errMsg = `credit: Error: Received error:${err.status} ${err.responseText}`;
            util2.debug(errMsg);
            reject({
              code: err.status,
              message: err.responseText
            });
          },
          success: (data2) => {
            resolve(data2);
          }
        });
      });
    };
    const requestFireCb = (events, url, data, queries) => {
      const createFaireCb = (event) => (data2) => {
        eventManager.fire(void 0, event, true, data2);
        return data2;
      };
      const successFairCb = createFaireCb(typeof events === "string" ? events : events.success);
      const failureFairCb = createFaireCb(typeof events === "string" ? events : events.failure);
      return request(url, data, queries).then(successFairCb).catch(failureFairCb);
    };
    const registerCallback = (callbackName, callback) => {
      eventManager.addEvent(callbackName);
      eventManager.registerCallback(callbackName, callback);
    };
    const redeem = (data) => {
      const { consent_modes: consentModes2, consent_purposes: consentPurposes } = consent4.__protected__.addConsentsToParams({});
      return requestFireCb(MANUAL_CREDIT_REDEEM, REDEEM_COMMON_PATH, __spreadProps(__spreadValues({}, data), {
        previousUserSegments: dataLayer.get("userSegments"),
        consentModes: consentModes2,
        consentPurposes
      })).then(({ xbc }) => {
        if (xbc && xbc !== getXbc()) {
          util2.setXbcCookieFromResponse({ xbc });
        }
      });
    };
    const check = (data) => {
      return requestFireCb(CREDIT_CHECK, CHECK_COMMON_PATH, data);
    };
    return {
      redeem,
      check,
      registerCallback
    };
  })();
  pn.container.register("credit", {
    useValue: credit
  });
  pn.credit = pn.container.resolve("credit");

  // ../src/lib/tinypassLogin.ts
  var tinypassLogin = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const containerUtils2 = pn.container.resolve("containerUtils");
    const util2 = pn.container.resolve("util");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const logging2 = pn.container.resolve("logging");
    const name3 = "tinypassLogin";
    let iframeLoadStatus;
    let postMessageIsWorking = false;
    const eventManager = eventUtils2.createEventManager(["resize", "loginSuccess", "logout"]);
    const _getBaseUrl = () => {
      return pn.getEndpointRoot(true) + "/checkout/user/loginShow";
    };
    const _getCheckUrl = () => {
      return pn.getEndpointRoot(true) + "/checkout/user/check";
    };
    function _receive(params) {
      util2.debug("Login event received", params.event, params.params, params);
      var iframe = containerUtils2.getIframe(params.sender);
      var invokeCallbacksOnFire = !iframe.config.parent;
      switch (params.event) {
        case "loaded":
          iframeLoadStatus = false;
          postMessageIsWorking = true;
          break;
        case "close":
          containerUtils2.closeModalContainer();
          eventManager.fireCallbacks(params.event, params.params, params.sender, invokeCallbacksOnFire);
          break;
        case "cancel":
        case "error":
        case "customEvent":
          eventManager.fireCallbacks(params.event, params.params, params.sender, invokeCallbacksOnFire);
          break;
        case "loginSuccess":
          _loginSuccess(params.event, params.params, params.sender, invokeCallbacksOnFire);
          break;
        case "logoutSuccess":
          _logoutSuccess(params.event, params.params, params.sender, invokeCallbacksOnFire);
          break;
        case "readyToSubmitStats":
          let stats = {
            pageViewId: pn.main.fetchPageViewId(),
            tbc: util2.getTbcCookie()
          };
          postmessage2.send("submitStats", stats, params.sender);
          break;
        default:
          util2.debug("Received invalid event type: " + params.event);
          return;
      }
    }
    ;
    function _logoutSuccess(event, params, sender, callback) {
      eventManager.fireCallbacks("logout", null, void 0, true);
      util2.setAccessTokenListCookie({ value: params.token_list, cookie_domain: params.cookie_domain }, params.user_token, true);
    }
    ;
    function _loginSuccess(event, params, sender, invokeCallbacksOnFire) {
      var iframe = containerUtils2.getIframe(sender);
      util2.setAccessTokenListCookie({ value: params.token_list, cookie_domain: params.cookie_domain }, params.user_token);
      iframe.config.userToken = params.user_token;
      if (iframe && iframe.config && iframe.config.loginSuccess) {
        iframe.config.loginSuccess(params.event, params.params, params.sender);
      }
      eventManager.fireCallbacks(event, params, sender, invokeCallbacksOnFire);
      if (iframe && iframe.config && iframe.config.closeAfterSuccess) {
        containerUtils2.closeModalContainer(sender);
      }
      var config = {
        reloadAfterLogin: true,
        userToken: params.user_token,
        user: params.user
      };
      _reload(config);
    }
    ;
    const _reload = (config) => {
      postmessage2.broadcast("reloadOffer", config);
    };
    function _loginSuccessNoPostMessage(tokenList, cookieDomain, userToken, iframeParams) {
      var iframe = containerUtils2.getIframe(iframeParams.iframeId);
      var invokeCallbacksOnFire = !iframe.config.parent;
      util2.setAccessTokenListCookie({ value: tokenList, cookie_domain: cookieDomain }, userToken);
      iframe.config.userToken = userToken;
      if (iframe && iframe.config && iframe.config.loginSuccess) {
        iframe.config.loginSuccess("loginSuccess", {}, {});
      }
      eventManager.fireCallbacks("loginSuccess", {}, void 0, invokeCallbacksOnFire);
    }
    ;
    const _getTpConfigurationParameters = (iframeParams) => {
      var propsToCopy = [
        "aid",
        "gaClientId",
        "tags",
        "contentSection",
        "contentAuthor"
      ];
      propsToCopy.forEach((value) => {
        if (pn[value]) {
          iframeParams[value] = pn[value];
        }
      });
      if (pn.contentCreated) {
        iframeParams.contentCreated = pn.contentCreated;
      }
      return iframeParams;
    };
    const _getConfigurationParameters = (c) => {
      var iframeParams = {};
      var propsToCopy = [
        "displayMode",
        "aid",
        "width",
        "height",
        "state"
      ];
      propsToCopy.forEach((value) => {
        if (c[value]) {
          iframeParams[value] = c[value];
        }
      });
      return iframeParams;
    };
    let openedIframeId;
    function _open(config) {
      const initTime = performance.now();
      if (openedIframeId) {
        containerUtils2.closeModalContainer(openedIframeId);
      }
      var defaultConfig = {
        closeAfterSuccess: true
      };
      var c = {};
      Object.assign(c, defaultConfig, config);
      c.displayMode = "popup";
      c.width = 360;
      c.height = 660;
      c.state = c.state ? c.state : "login";
      var iframeParams = _getConfigurationParameters(c);
      iframeParams.iframeId = util2.randomString(16);
      iframeParams.url = window.location.href;
      iframeParams.host_url = window.location.href;
      iframeParams.initTime = initTime;
      openedIframeId = iframeParams.iframeId;
      _getTpConfigurationParameters(iframeParams);
      iframeParams.user_provider = "tinypass_accounts";
      if (config.userToken) {
        iframeParams.user_token = config.userToken;
      }
      util2.getCampaigns(iframeParams);
      var iframe;
      const params = {
        url: _getBaseUrl(),
        config: c,
        postMessageUrl: _getBaseUrl(),
        receive: _receive,
        iframeParams
      };
      if (c.iframeId) {
        params.iframeParams.iframeId = c.iframeId;
        iframe = containerUtils2.redirectContainer(c.iframeId, params);
      } else {
        iframe = containerUtils2.createContainer(params);
      }
      eventManager.registerCallback(c, iframeParams.iframeId);
      return iframe;
    }
    ;
    const show = (config) => {
      if (iframeLoadStatus) {
        return false;
      } else {
        iframeLoadStatus = true;
        setTimeout(() => {
          iframeLoadStatus = false;
        }, 1e4);
      }
      if (!_open(config)) {
        util2.error("Could not initialize login; check configuration");
      }
    };
    function _listenLogin(config) {
      eventManager.registerCallback(config, config.iframeId);
      var iframe = {
        iframeId: config.iframeId,
        config,
        iframeParams: config
      };
      postmessage2.init({
        postMessageUrl: _getBaseUrl(),
        receive: _receive,
        iframe,
        iframeParams: {}
      });
    }
    ;
    const close = () => {
      containerUtils2.closeModalContainer();
    };
    const showBackdrop = () => {
      containerUtils2.showBackdrop();
    };
    const hideBackdrop = () => {
      containerUtils2.hideBackdrop();
    };
    const centerBackdrop = (container) => {
      containerUtils2.centerBackdrop(container);
    };
    const registerCallback = (callbackName, callback) => {
      eventManager.registerCallback(callbackName, callback);
    };
    const listenLogin = (config) => {
      _listenLogin(config);
    };
    return {
      name: name3,
      show,
      close,
      showBackdrop,
      hideBackdrop,
      centerBackdrop,
      registerCallback,
      listenLogin
    };
  })();
  pn.container.register("tinypassLogin", {
    useValue: tinypassLogin
  });
  pn.tinypassLogin = pn.container.resolve("tinypassLogin");

  // ../src/lib/tinypassAccounts.ts
  var tinypassAccounts = (() => {
    const ajax3 = pn.container.resolve("ajax");
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const tinypassLogin2 = pn.container.resolve("tinypassLogin");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const isv = false;
    const name3 = "tinypassAccounts";
    const eventManager = eventUtils2.createEventManager(["logout"]);
    const getName = () => {
      return "tinypass_accounts";
    };
    const getToken = () => {
      return util2.getUserTokenCookie() || null;
    };
    const isUserValid = () => {
      return !!util2.getUserTokenCookie();
    };
    const onLoginSuccess = (params) => {
      util2.setAccessTokenListCookie({ value: params.token_list, cookie_domain: params.cookie_domain }, params.user_token);
    };
    const isConfigured = () => {
      return pn.useTinypassAccounts === true || typeof pn.useTinypassAccounts === "string" && pn.useTinypassAccounts === "true";
    };
    const login = (config) => {
      config = config || {};
      config.userToken = getToken();
      return tinypassLogin2.show(config);
    };
    const logout = (callback) => {
      var params = {
        aid: pn.aid,
        url: document.location.href
      };
      var url = pn.getEndpointRoot(true) + "/checkout/user/logout?" + jqUtils2.param(params);
      util2.setAccessTokenListCookie({ value: null }, void 0, true);
      ajax3.request({
        url,
        dataType: "jsonp",
        success: (rspData) => {
          util2.setAccessTokenListCookie({
            value: "",
            cookie_domain: rspData.models.cookie_domain
          }, rspData.models.user_token, true);
          eventManager.fireCallbacks("logout", null, void 0, true);
          if (callback) {
            callback(rspData);
          }
        },
        error: (rspData) => {
          util2.setAccessTokenListCookie(null, void 0, true);
          eventManager.fireCallbacks("logout", null, void 0, true);
          if (callback) {
            callback(rspData);
          }
        }
      });
    };
    const registerCallback = (callbackName, callback) => {
      eventManager.addEvent(callbackName);
      eventManager.registerCallback(callbackName, callback);
    };
    return {
      name: name3,
      isv,
      isUserValid,
      getToken,
      getName,
      onLoginSuccess,
      isConfigured,
      login,
      logout,
      registerCallback
    };
  })();
  pn.container.register("tinypassAccounts", {
    useValue: tinypassAccounts
  });
  pn.tinypassAccounts = pn.container.resolve("tinypassAccounts");

  // ../src/lib/condeUserProvider.ts
  var condeUserProvider = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const cookie3 = pn.container.resolve("cookie");
    const util2 = pn.container.resolve("util");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const isv = false;
    const name3 = "condeUserProvider";
    const eventManager = eventUtils2.createEventManager(["logout"]);
    const getName = () => {
      return "conde";
    };
    const getToken = () => {
      var cnid = util2.findCookieByName("amg_user_partner");
      if (typeof cnid !== "undefined" && cnid && cnid.length >= 0) {
        return cnid;
      }
      return null;
    };
    const isUserValid = () => {
      return !!util2.getUserTokenCookie();
    };
    const logout = (callback) => {
      util2.setAccessTokenListCookie({ value: null }, void 0, true);
      var domains = util2.getPossibleCookieDomains();
      for (var i in domains) {
        util2.deleteCookie("amg_user", domains[i]);
        util2.deleteCookie("amg_user_partner", domains[i]);
        util2.deleteCookie("amg_user_info", domains[i]);
        util2.deleteCookie("amg_user_ext", domains[i]);
        util2.deleteCookie("amg_user_update", domains[i]);
      }
      util2.deleteCookie("amg_user");
      util2.deleteCookie("amg_user_partner");
      util2.deleteCookie("amg_user_info");
      util2.deleteCookie("amg_user_ext");
      util2.deleteCookie("amg_user_update");
      eventManager.fireCallbacks("logout", null, void 0, true);
      if (callback) {
        callback();
      }
    };
    const onLoginSuccess = (params) => {
      util2.setAccessTokenListCookie({ value: params.token_list, cookie_domain: params.cookie_domain }, params.user_token);
      var options = {
        path: "/",
        expires: 730
      };
      if (params.cookie_domain && params.cookie_domain !== "localhost" && jqUtils2.inArray(params.cookie_domain, util2.getPossibleCookieDomains()) >= 0) {
        options.domain = params.cookie_domain;
      }
      cookie3.raw = true;
      util2.__protected__.setCookie(params.params.cookieName, params.params.cookieValue, options);
      util2.__protected__.setCookie("amg_user_partner", params.params.externalId, options);
      util2.__protected__.setCookie("amg_user_info", params.params.userName, options);
      util2.__protected__.setCookie("amg_user_ext", params.params.siteUserId, options);
      if (params.params.updateToken) {
        util2.__protected__.setCookie("amg_user_update", params.params.updateToken, options);
      }
      cookie3.raw = false;
    };
    const isConfigured = () => {
      return pn.useCondeUserProvider === true || typeof pn.useCondeUserProvider === "string" && pn.useCondeUserProvider === "true";
    };
    const registerCallback = (callbackName, callback) => {
      eventManager.addEvent(callbackName);
      eventManager.registerCallback(callbackName, callback);
    };
    return {
      isv,
      name: name3,
      getName,
      isUserValid,
      getToken,
      onLoginSuccess,
      logout,
      isConfigured,
      registerCallback
    };
  })();
  pn.container.register("condeUserProvider", {
    useValue: condeUserProvider
  });
  pn.condeUserProvider = pn.container.resolve("condeUserProvider");

  // ../src/lib/gigya.ts
  var gigya = (() => {
    const util2 = pn.container.resolve("util");
    const api2 = pn.container.resolve("api");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const jqUtils2 = pn.container.resolve("jqUtils");
    let isv = false;
    const name3 = "gigya";
    let _isGigyaInitialized = false;
    function _isGigyaLoaded() {
      return window.gigya && window.gigya.__initialized;
    }
    ;
    const eventManager = eventUtils2.createEventManager(["userChanged", "onHide", "logout"]);
    const _config = {
      apiKey: null,
      screenSet: "Default-RegistrationLogin",
      startScreen: null,
      enabledProviders: null,
      lang: null
    };
    const getName = () => {
      return "gigya";
    };
    function getToken() {
      var ut = util2.getUserTokenCookie();
      if (ut) {
        var gigyaCookie = util2.findCookieByName("glt_" + _config.apiKey);
        var userTokenGigyaCookie = util2.findCookieByName("__utg_" + _config.apiKey);
        if (gigyaCookie === userTokenGigyaCookie) {
          return ut;
        }
      }
      return null;
    }
    ;
    function isUserValid() {
      var userToken = getToken();
      return !!(typeof userToken !== "undefined" && userToken && userToken.length >= 0);
    }
    ;
    function onLoginSuccess(params) {
      util2.setAccessTokenListCookie({
        value: params.token_list,
        cookie_domain: params.cookie_domain
      }, params.user_token);
    }
    function init(config) {
      if (_isGigyaInitialized) {
        return;
      }
      for (var item in config) {
        if (typeof config[item] !== "undefined") {
          _config[item] = config[item];
        }
      }
      if (!_config.screenSet) {
        throw "Gigya is not configured: screenSet parameter required";
      }
      if (!_config.apiKey) {
        throw "Gigya is not configured: apiKey parameter required";
      }
      _addEventHandlers();
      _isGigyaInitialized = true;
      _refreshUserToken();
    }
    ;
    let refreshUserTokenCallbacks = [];
    function _refreshUserToken(force, callback) {
      if (!_isGigyaInitialized) {
        throw "Gigya is not configured";
      }
      checkGigyaLoaded();
      var gigyaCookie = util2.findCookieByName("glt_" + _config.apiKey);
      var userTokenGigyaCookie = util2.findCookieByName("__utg_" + _config.apiKey);
      var getAccountInfoResponse = (response) => {
        if (response.errorCode === 0) {
          var params = {
            uid: response.UID,
            signature: response.UIDSignature,
            signature_timestamp: response.signatureTimestamp,
            url: util2.prepareUrlParameter(window.location.href)
          };
          util2.startCall("refreshUserToken");
          api2.callApi("/anon/gigya/verifyAccountInfo", params, (response2) => {
            if (response2 && response2.result) {
              util2.setAccessTokenListCookie(response2.result.access_token, response2.result.user_token);
              var options = {
                path: "/",
                expires: 730
              };
              if (response2.result.access_token) {
                var cookie_domain = response2.result.access_token.cookie_domain;
                if (cookie_domain && cookie_domain !== "localhost" && jqUtils2.inArray(cookie_domain, util2.getPossibleCookieDomains()) >= 0) {
                  options["domain"] = cookie_domain;
                }
              }
              var value = util2.findCookieByName("glt_" + _config.apiKey);
              util2.__protected__.setCookieConsent("vx", "__utg_" + _config.apiKey, value, options);
              for (var i = 0; i < refreshUserTokenCallbacks.length; i++) {
                var c = refreshUserTokenCallbacks[i];
                if (c) {
                  c(response2.result);
                }
              }
              if (response2.result.user) {
                response2.result.user = {
                  uid: response2.result.user.uid,
                  email: response2.result.user.email,
                  firstName: response2.result.user.first_name,
                  lastName: response2.result.user.last_name,
                  valid: response2.result.user.valid
                };
              }
              eventManager.fireCallbacks("userChanged", response2.result, void 0, true);
            } else {
              util2.log("Can't verify gigya user: may be the configuration of gigya user provider is invalid");
              util2.setAccessTokenListCookie();
            }
            refreshUserTokenCallbacks = [];
            util2.doneCall("refreshUserToken");
          });
        } else {
          util2.setAccessTokenListCookie();
          refreshUserTokenCallbacks = [];
        }
      };
      if (gigyaCookie !== userTokenGigyaCookie || !!gigyaCookie && gigyaCookie === userTokenGigyaCookie && !isUserValid() || force) {
        refreshUserTokenCallbacks.push(callback);
        if (refreshUserTokenCallbacks.length === 1) {
          window.gigya.accounts.getAccountInfo({ callback: getAccountInfoResponse });
        }
      } else {
      }
    }
    ;
    function login(callback) {
      if (!_isGigyaInitialized) {
        throw "Gigya is not configured";
      }
      checkGigyaLoaded();
      if (callback) {
        window.gigya.accounts.addEventHandlers({
          onLogin: () => {
            _refreshUserToken(true, callback);
          }
        });
      }
      var params = {
        screenSet: _config.screenSet,
        onHide: () => {
          eventManager.fireCallbacks("onHide", { afterLogin }, void 0, true);
        }
      };
      var internalPianoParams = ["apiKey", "screenSet"];
      for (var property2 in _config) {
        var isPianoInternalProperty = property2 in internalPianoParams;
        if (!isPianoInternalProperty) {
          params[property2] = _config[property2];
        }
      }
      afterLogin = false;
      window.gigya.accounts.showScreenSet(params);
    }
    ;
    let afterLogin = false;
    function _addEventHandlers() {
      checkGigyaLoaded();
      window.gigya.accounts.addEventHandlers({
        onLogin: () => {
          afterLogin = true;
          _refreshUserToken();
        },
        onLogout: () => {
          util2.setAccessTokenListCookie({ value: null }, void 0, true);
          eventManager.fireCallbacks("logout", null, void 0, true);
        }
      });
    }
    ;
    function loginByPasswordless(sessionInfo) {
      if (!sessionInfo) {
        throw "Session info is empty";
      }
      var cookieName = sessionInfo.accessTokenName, value = sessionInfo.accessToken;
      util2.__protected__.setCookie(cookieName, value);
      var dublicateGigyaCookieName = "glt_" + _config.apiKey;
      util2.__protected__.setCookieConsent("vx", dublicateGigyaCookieName, value);
      _refreshUserToken(true);
    }
    ;
    function logout(callback) {
      if (!_isGigyaInitialized) {
        throw "Gigya is not configured";
      }
      checkGigyaLoaded();
      window.gigya.accounts.logout({
        callback: () => {
          eventManager.fireCallbacks("logout", null, void 0, true);
          if (callback) {
            callback();
          }
          util2.setAccessTokenListCookie({ value: null }, void 0, true);
        }
      });
      util2.setAccessTokenListCookie({ value: null }, void 0, true);
    }
    ;
    function isConfigured() {
      return pn.useGigyaUserProvider === true || typeof pn.useGigyaUserProvider === "string" && pn.useGigyaUserProvider === "true";
    }
    ;
    function checkGigyaLoaded() {
      if (!_isGigyaLoaded()) {
        throw "Gigya is not initialized";
      }
    }
    function registerCallback(callbackName, callback) {
      eventManager.addEvent(callbackName);
      eventManager.registerCallback(callbackName, (data) => callback(data));
    }
    return {
      isv,
      name: name3,
      init,
      isUserValid,
      getToken,
      getName,
      onLoginSuccess,
      login,
      logout,
      isConfigured,
      registerCallback,
      loginByPasswordless
    };
  })();
  pn.container.register("gigya", {
    useValue: gigya
  });
  pn.gigya = pn.container.resolve("gigya");

  // ../src/lib/jwtDecode.ts
  var jwtDecode = (() => {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    class InvalidCharacterError extends Error {
      construct(message) {
        this.message = message;
        this.name = "InvalidCharacterError";
      }
    }
    function polyfill(input) {
      var str = String(input).replace(/=+$/, "");
      if (str.length % 4 === 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (var bc = 0, bs, buffer, idx = 0, output = ""; buffer = str.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
        buffer = chars.indexOf(buffer);
      }
      return output;
    }
    try {
      var atob = window.atob && window.atob.bind(window) || polyfill;
    } catch (e) {
      atob = polyfill;
    }
    function b64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).replace(/(.)/g, function(m, p) {
        var code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = "0" + code;
        }
        return "%" + code;
      }));
    }
    var base64_url_decode = function(str) {
      var output = str.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
        case 0:
          break;
        case 2:
          output += "==";
          break;
        case 3:
          output += "=";
          break;
        default:
          throw "Illegal base64url string!";
      }
      try {
        return b64DecodeUnicode(output);
      } catch (err) {
        return atob(output);
      }
    };
    return function(token, options) {
      if (typeof token !== "string") {
        throw new Error("Invalid token specified");
      }
      options = options || {};
      var pos = options.header === true ? 0 : 1;
      return JSON.parse(base64_url_decode(token.split(".")[pos]));
    };
  })();
  pn.jwtDecode = jwtDecode;
  pn.container.register("jwtDecode", {
    useValue: jwtDecode
  });

  // ../src/lib/pianoId/features/url-manager.ts
  var urlManager = (container = pn.container) => {
    let iframeUrlFromGlobalConfig;
    const DEFAULT_PIANOID_ORIGIN = "https://id.tinypass.com";
    const getPianoIdDomain = () => {
      const isSandbox = pn.sandbox || pn.isNonProdEndpoint();
      let domain = iframeUrlFromGlobalConfig || pn.pianoIdUrl || !isSandbox && DEFAULT_PIANOID_ORIGIN || "/";
      if (domain === "/") {
        domain = pn.getEndpointRoot(true);
      }
      return domain.replace(/\/$/, "");
    };
    const getPianoIdUrl = () => `${getPianoIdDomain()}/id/`;
    const getIdentifyUrl = () => `${getPianoIdUrl()}api/v1/identity`;
    return {
      getPianoIdDomain,
      getPianoIdUrl,
      getIdentifyUrl,
      iframeUrlFromGlobalConfig,
      setIframeUrlFromGlobalConfig: (value) => iframeUrlFromGlobalConfig = value
    };
  };
  pn.container.register("urlManager", {
    useValue: urlManager()
  });

  // ../src/lib/pianoId/features/lang-manager.ts
  var langManager = (container = pn.container) => {
    const LANG_COOKIE_NAME = "__pil";
    const util2 = container.resolve("util");
    return {
      getLang: () => pn.locale || util2.__protected__.getCookie(LANG_COOKIE_NAME) || ""
    };
  };
  pn.container.register("langManager", {
    useValue: langManager()
  });

  // ../src/lib/pianoId/features/utils.ts
  var PianoIdUtils;
  ((PianoIdUtils2) => {
    function isPianoIdLiteConfigured() {
      return pn.usePianoIdLiteUserProvider === true || typeof pn.usePianoIdLiteUserProvider === "string" && pn.usePianoIdLiteUserProvider === "true";
    }
    PianoIdUtils2.isPianoIdLiteConfigured = isPianoIdLiteConfigured;
    function isCustomForm2(config, base) {
      const isNotRegistration = !config.isRegistration;
      const isNotOtherHtml = !/\.html$/.test(base);
      return !!config.formName && isNotOtherHtml && isNotRegistration;
    }
    PianoIdUtils2.isCustomForm = isCustomForm2;
  })(PianoIdUtils || (PianoIdUtils = {}));

  // ../src/lib/pianoId/features/iframe-builder.ts
  var isCustomForm = PianoIdUtils.isCustomForm;
  var iFrameBuilder = (container = pn.container) => {
    const util2 = container.resolve("util");
    const langManager2 = container.resolve("langManager");
    const gaService2 = container.resolve("gaService");
    const jqUtils2 = container.resolve("jqUtils");
    const buildIframeUrl = (base, config, params, origin) => {
      var _a;
      const { contentType } = util2.getPageViewContext();
      const { pageTitle, pageViewId: pageViewId2 } = util2.getPageViewContext();
      const userState2 = util2.getUserState();
      const query2 = {
        client_id: config.aid,
        sender: params == null ? void 0 : params.iframeId,
        origin: origin || window.location.origin || window.location.href,
        site: window.location.href,
        display_mode: config.displayMode,
        page_view_id: pageViewId2 != null ? pageViewId2 : void 0,
        browser_id: (_a = util2.getBrowserId()) != null ? _a : void 0,
        page_title: pageTitle,
        tbc: util2.getTbcCookie()
      };
      if (contentType) {
        query2.content_type = contentType;
      }
      if (pn.staticDomain) {
        query2.static_domain = pn.staticDomain;
      }
      const lang = langManager2.getLang();
      if (lang) {
        query2.lang = lang;
      }
      if (!!gaService2.getClientId()) {
        query2.ga_client_id = gaService2.getClientId();
      }
      if (!!gaService2.getGAAccount()) {
        query2.ga = gaService2.getGAAccount();
      }
      if (config.disableSignUp) {
        query2.disable_sign_up = true;
      }
      if (config.screen) {
        query2.screen = config.screen;
      }
      if (config.resetPasswordToken) {
        query2.reset = config.resetPasswordToken;
      }
      if (config.verification_code) {
        query2.verification_code = config.verification_code;
      }
      if (config.stage) {
        query2.stage = config.stage;
      }
      if (config.resetPasswordLandingUrl) {
        query2.reset_uri = config.resetPasswordLandingUrl;
      }
      if (config.width && config.displayMode === "modal" /* Modal */) {
        query2.width = config.width;
      }
      if (config.formName) {
        query2.form_name = config.formName;
      }
      if (userState2) {
        query2.user_state = userState2;
      }
      if (config.preview) {
        switch (config.template) {
          case "custom_form":
            base += "form";
            break;
          case "profile":
            base += "profile";
            break;
          case "newsletters":
            base += "newsletters";
            break;
          case "layout_gm_sso":
          case "sso_confirm":
          case "sso_confirm_before":
            base += "gm-sso";
            break;
        }
      } else {
        if (isCustomForm(config, base)) {
          base += "form";
        }
        if (config.isGmSsoEnabled) {
          base += "gm-sso";
        }
      }
      if (config.confirmation) {
        query2.gm_sso_confirm = config.confirmation;
      }
      if (config.hideIfComplete) {
        query2.hide_if_complete = config.hideIfComplete;
      }
      if (config.preview) {
        query2.preview = config.preview;
      }
      if (config.templateVersion) {
        query2.templateVersion = config.templateVersion;
      }
      if (config.template) {
        query2.template = config.template;
      }
      if (config.accessToken) {
        query2.access_token = config.accessToken;
      }
      if (config.email) {
        query2.email = config.email;
      }
      if (config.singleStep) {
        query2.single_step = true;
      }
      if (config.createPasswordlessUser) {
        query2.create_passwordless_user = true;
      }
      if (config.customParams) {
        query2.custom_params = JSON.stringify(config.customParams);
      }
      if (config.customEvents) {
        const ce = Object.keys(config.customEvents);
        if (ce.length) {
          query2.custom_events = JSON.stringify(ce);
        }
      }
      if (config.jsonpError) {
        query2.jsonp_error = JSON.stringify(config.jsonpError);
      }
      if (config.passwordlessSuccess) {
        query2.passwordless_success = true;
      }
      if (config.passwordlessToken) {
        query2.passwordless_token = config.passwordlessToken;
      }
      if (config.redirectUri) {
        query2.redirect_uri = config.redirectUri;
      }
      if (params == null ? void 0 : params.iframeUrl) {
        query2.url = params.iframeUrl;
      }
      if (config.returnBack) {
        query2.return_back = config.returnBack;
      }
      if (params == null ? void 0 : params.pos) {
        query2.width = params.pos.width;
        query2.height = params.pos.height;
        query2.top = params.pos.top;
        query2.left = params.pos.left;
      }
      if (config.templateId) {
        query2.template_id = config.templateId;
      }
      if (config.variantId) {
        query2.variant_id = config.variantId;
      }
      if (config.sss) {
        query2.sss_mode = config.sss.sss_mode;
        query2.sss_callback_url = config.sss.sss_callback_url;
        query2.sss_origin_url = config.sss.sss_origin_url;
      }
      if (config.trackingId) {
        query2.tracking_id = config.trackingId;
      }
      if (config.response_id) {
        query2.response_id = config.response_id;
      }
      if (config.transparentMode) {
        query2.transparent_mode = true;
      }
      return [base, jqUtils2.param(query2)].join("?");
    };
    return {
      buildIframeUrl
    };
  };
  pn.container.register("iframeBuilder", {
    useValue: iFrameBuilder()
  });

  // ../src/lib/pianoId/features/msqa/msqa.error.ts
  var MSQAError = class extends Error {
  };

  // ../src/lib/pianoId/features/msqa/msqa.ts
  var microsoftQuickAuth = (container = pn.container) => {
    const SCRIPT = "https://edge-auth.microsoft.com/js/ms_auth_client.min.js";
    const LINKING_STATE_TTL = 10 * 60 * 1e3;
    const LINKING_STATE_LS_KEY = "msqaLinkingState";
    const util2 = container.resolve("util");
    const ajax3 = container.resolve("ajax");
    const localStorage4 = container.resolve("localStorage");
    const gaService2 = container.resolve("gaService");
    let linkingStateUrl = "";
    let linkingRedirectUri = "";
    let configuration;
    const init = (clientId, redirectUri, callback = () => {
    }) => __async(void 0, null, function* () {
      if (!clientId || !redirectUri) {
        throw new MSQAError("[Piano ID] Microsoft Quick Auth configuration failed. Client ID or redirectUri are missed.");
      }
      yield util2.requireJsFile(SCRIPT);
      util2.debug("[Piano ID][Microsoft Quick Auth] Script loaded.");
      if (!ms) {
        throw new MSQAError("[Piano ID] Microsoft Quick Auth configuration failed. MSQA is not loaded.");
      }
      const result = ms.auth.initialize({
        client_id: clientId,
        callback,
        redirect_uri: redirectUri,
        ux_mode: "redirect",
        auto_prompt: false,
        auto_sign_in: configuration == null ? void 0 : configuration.autoSignIn,
        context: configuration == null ? void 0 : configuration.context,
        cancel_on_tap_outside: configuration == null ? void 0 : configuration.cancelOnTapOutside,
        locale: configuration == null ? void 0 : configuration.locale
      });
      const existingState = localStorage4.get(LINKING_STATE_LS_KEY);
      if (existingState) {
        ms.auth.setRedirectState(existingState);
      }
      if (result.result === "failure") {
        throw new MSQAError(`[Piano ID] Microsoft Quick Auth configuration failed due to ${result.reason}`);
      }
      util2.debug("[Piano ID][Microsoft Quick Auth] Initialized.");
    });
    const showPrompt = () => {
      return new Promise((resolve) => {
        var _a;
        const position = (_a = configuration == null ? void 0 : configuration.promptPosition) != null ? _a : "left";
        ms.auth.prompt(position, function(notification) {
          if (notification.displayed) {
            util2.debug("[Piano ID][Microsoft Quick Auth] Prompt displayed.");
            localStorage4.remove(LINKING_STATE_LS_KEY);
          }
          resolve(notification);
        });
      });
    };
    const fetchLinkingState = () => {
      const url = new URL(linkingStateUrl);
      const browserId2 = util2.getBrowserId();
      if (browserId2) {
        url.searchParams.append("browser_id", browserId2);
      }
      const pageViewId2 = pn.main.fetchPageViewId();
      if (pageViewId2) {
        url.searchParams.append("page_view_id", pageViewId2);
      }
      const { contentType } = util2.getPageViewContext();
      if (contentType) {
        url.searchParams.append("content_type", contentType);
      }
      return new Promise((resolve, reject) => ajax3.request({
        url: url.toString(),
        type: "POST",
        contentType: "application/json",
        dataType: "text",
        data: JSON.stringify({
          state: localStorage4.get(LINKING_STATE_LS_KEY),
          back_url: window.location.href,
          social_type: "MSQA",
          response_type: "token",
          prompt: true,
          redirect_uri: linkingRedirectUri
        }),
        success: (data) => {
          localStorage4.set(LINKING_STATE_LS_KEY, data);
          if ("ms" in window) {
            ms.auth.setRedirectState(data);
          }
          resolve(data);
        },
        error: (xhr) => {
          reject(xhr);
        }
      }));
    };
    const runLinkingStateAndPromptObserver = () => {
      util2.debug("[Piano ID][Microsoft Quick Auth] Running linking state and prompt observer.");
      setInterval(() => fetchLinkingState().then(() => showPrompt()), LINKING_STATE_TTL);
    };
    const setLinkingRedirectUri = (pianoIdUrl, aid, pianoIdDomain, lang) => {
      const url = new URL(pianoIdUrl);
      url.searchParams.append("client_id", aid);
      url.searchParams.append("origin", pianoIdDomain);
      url.searchParams.append("site", window.location.href);
      url.searchParams.append("display_mode", "modal");
      const pageViewId2 = pn.main.fetchPageViewId();
      if (pageViewId2) {
        url.searchParams.append("page_view_id", pageViewId2);
      }
      const browserId2 = util2.getBrowserId();
      if (browserId2) {
        url.searchParams.append("browser_id", browserId2);
      }
      const tbc = util2.getTbcCookie();
      if (tbc) {
        url.searchParams.append("tbc", tbc);
      }
      const ga = gaService2.getGAAccount();
      if (ga) {
        url.searchParams.append("ga", gaService2.getGAAccount());
      }
      const pageViewContext = util2.getPageViewContext();
      if (pageViewContext == null ? void 0 : pageViewContext.contentType) {
        url.searchParams.append("content_type", pageViewContext == null ? void 0 : pageViewContext.contentType);
      }
      url.searchParams.append("lang", lang);
      url.searchParams.append("width", "400");
      linkingRedirectUri = url.toString();
    };
    return {
      init,
      showPrompt,
      fetchLinkingState,
      setLinkingStateUrl: (url) => linkingStateUrl = url,
      setLinkingRedirectUri,
      runLinkingStateAndPromptObserver,
      clearConfirmationParameters: () => {
        const internalRedirectQueryParamName = "internal_redirect_uri";
        const responseQueryParamName = "response_id";
        if (util2.hasQueryParamByName(internalRedirectQueryParamName)) {
          util2.removeQueryParamByName(internalRedirectQueryParamName);
        }
        if (util2.hasQueryParamByName(responseQueryParamName)) {
          util2.removeQueryParamByName(responseQueryParamName);
        }
      },
      setConfiguration: (config) => configuration = config
    };
  };
  pn.container.register("microsoftQuickAuth", {
    useValue: microsoftQuickAuth()
  });

  // ../src/lib/pianoId/features/self-serve-sessions.ts
  var selfServeSessions = (container = pn.container) => {
    const langManager2 = container.resolve("langManager");
    const urlManager2 = container.resolve("urlManager");
    const getAccessToken = () => pn.sssAccessToken;
    const isSssEnabled = () => {
      const { sss_mode, sss_callback_url } = getSssParams();
      return !!sss_mode && !!sss_callback_url;
    };
    const getSssParams = () => {
      const originUrl = pn.sssOriginUrl || window.location.href || window.location.origin;
      return {
        sss_mode: pn.sssMode,
        sss_callback_url: pn.sssCallbackUrl,
        sss_origin_url: originUrl
      };
    };
    const setSssAccessToken = (accessToken, onlyClientSide = false) => {
      pn.setSssAccessToken(accessToken);
      if (onlyClientSide) {
        return;
      }
      let query2 = "";
      query2 += "callback_url=" + getSssParams().sss_callback_url;
      query2 += "&origin_url=" + getSssParams().sss_origin_url;
      query2 += "&aid=" + pn.aid;
      query2 += "&lang=" + langManager2.getLang();
      query2 += "&token=" + accessToken;
      window.location.href = urlManager2.getPianoIdDomain() + "/id/api/v1/sss?" + query2;
    };
    const isRedirect = (showConfig) => {
      var _a;
      return ((_a = showConfig.sss) == null ? void 0 : _a.sss_mode) === "redirect";
    };
    const logout = () => {
      if (isSssEnabled() && pn.sssAccessToken) {
        pn.setSssAccessToken(void 0);
      }
    };
    return {
      getAccessToken,
      isSssEnabled,
      getSssParams,
      setSssAccessToken,
      isRedirect,
      logout
    };
  };
  pn.container.register("selfServeSessions", {
    useValue: selfServeSessions()
  });

  // ../src/lib/pianoId/features/token-manager.ts
  var tokenManager = (container = pn.container) => {
    const util2 = container.resolve("util");
    const sss = container.resolve("selfServeSessions");
    const TOKEN_COOKIE_NAME = util2.getAidSpecifiedName("__utp");
    const loadToken = () => {
      var _a;
      if (sss.isSssEnabled() && !!sss.getAccessToken()) {
        return (_a = sss.getAccessToken()) != null ? _a : null;
      }
      const token = util2.findCookieByName(TOKEN_COOKIE_NAME);
      return token ? token : null;
    };
    const getToken = () => {
      if (pn.externalJWT && PianoIdUtils.isPianoIdLiteConfigured()) {
        return pn.externalJWT;
      }
      return loadToken();
    };
    return {
      getToken,
      loadToken
    };
  };
  pn.container.register("tokenManager", {
    useValue: tokenManager()
  });

  // ../src/lib/pianoId/features/config-manager.ts
  var configManager = (container = pn.container) => {
    const tokenManager2 = container.resolve("tokenManager");
    const prepareConfig = (config, modifier) => {
      if (!config.aid) {
        config.aid = pn.aid;
      }
      if (!config.displayMode) {
        config.displayMode = "modal" /* Modal */;
      }
      if (config.displayMode === "popup" /* Popup */) {
        config.width = parseInt(String(config.width)) || getDefaultWidth();
        config.height = parseInt(String(config.height)) || 460;
      } else if (config.displayMode === "modal" /* Modal */) {
        config.width = parseInt(String(config.width)) || getDefaultWidth();
      }
      modifier == null ? void 0 : modifier(config);
      config.accessToken = tokenManager2.loadToken();
    };
    const getDefaultWidth = () => {
      const screenWidth = window.innerWidth || document.documentElement.clientWidth || window.screen.width;
      return Math.min(screenWidth, 400);
    };
    return {
      prepareConfig,
      getDefaultWidth
    };
  };
  pn.container.register("configManager", {
    useValue: configManager()
  });

  // ../src/lib/pianoId/features/request.manager.ts
  var requestManager = (container = pn.container) => {
    const util2 = container.resolve("util");
    const ajax3 = container.resolve("ajax");
    const oldRequest = (options) => {
      const url = new URL(options.url);
      const { pageTitle, pageViewId: pageViewId2 } = util2.getPageViewContext();
      const browserId2 = getBrowserId();
      const userState2 = util2.getUserState();
      if (browserId2) {
        url.searchParams.append("browser_id", browserId2);
      }
      if (pageViewId2) {
        url.searchParams.append("page_view_id", pageViewId2);
      }
      const { contentType } = util2.getPageViewContext();
      if (contentType) {
        url.searchParams.append("content_type", contentType);
      }
      url.searchParams.append("page_title", pageTitle);
      if (userState2) {
        if (options.dataType === "jsonp") {
          options.data = __spreadProps(__spreadValues({}, options.data), { user_state: userState2 });
        } else {
          options.headers = __spreadProps(__spreadValues({}, options.headers), { "User-State": userState2 });
        }
      }
      options.url = url.toString();
      ajax3.request(options);
    };
    const request = (options) => new Promise((resolve, reject) => oldRequest(__spreadProps(__spreadValues({}, options), {
      success: (args) => resolve(args),
      error: (xhr) => reject(xhr)
    })));
    const getBrowserId = () => {
      var _a;
      return (_a = util2.getBrowserId()) != null ? _a : void 0;
    };
    return {
      oldRequest,
      request
    };
  };
  pn.container.register("pianoIdRequestManager", {
    useValue: requestManager()
  });

  // ../src/lib/pianoId/pianoId.ts
  var pianoId = (container = pn.container) => {
    const cookie3 = container.resolve("cookie");
    const jqUtils2 = container.resolve("jqUtils");
    const requestManager2 = container.resolve("pianoIdRequestManager");
    const jwtDecode2 = container.resolve("jwtDecode");
    const util2 = container.resolve("util");
    const containerUtils2 = container.resolve("containerUtils");
    const postmessage2 = container.resolve("postmessage");
    const observer2 = container.resolve("observer");
    const gaService2 = container.resolve("gaService");
    const api2 = container.resolve("api");
    const logging2 = container.resolve("logging");
    const localStorage4 = container.resolve("localStorage");
    const consent4 = container.resolve("consent");
    const analytics2 = container.resolve("analytics");
    const clientConfiguration2 = container.resolve("clientConfiguration");
    const msqa = container.resolve("microsoftQuickAuth");
    let isMsqaInitiated = false;
    let msqaInitializationPromise;
    const sss = container.resolve("selfServeSessions");
    const iframeBuilder = container.resolve("iframeBuilder");
    const configManager2 = container.resolve("configManager");
    const urlManager2 = container.resolve("urlManager");
    const tokenManager2 = container.resolve("tokenManager");
    const isv = false;
    const name3 = "pianoId";
    const GM_SSO_REDIRECT_QUERY = "gm_sso_redirect";
    const GM_SSO_REDIRECT_TOKEN = "token";
    const GM_SSO_TERM_ID = "term_id";
    const GM_SSO_OFFER_ID = "offer_id";
    const GM_SSO_CHECKOUT_FLOW_ID = "checkout_flow_id";
    const GM_SSO_EXPERIENCE_ID = "experience_id";
    const GM_SSO_FORM_NAME = "form_name";
    const GM_SSO_FORM_NAME_BY_TERM_ID = "form_name_by_term_id";
    const GM_SSO_REDIRECT_REMEMBER = "remember";
    const GM_SSO_REGISTRATION = "registration";
    const RESET_TOKEN_QUERY = "reset_token";
    const PASSWORDLESS_TOKEN_QUERY = "passwordless_token";
    const VERIFICATION_CODE_QUERY = "verification_code";
    const TRACKING_ID_QUERY = "_ptid";
    const ACCESS_TOKEN = "piano_social_token";
    const COOKIE_NAME2 = util2.getAidSpecifiedName("__utp");
    const LANG_COOKIE_NAME = "__pil";
    const DOMAIN_COOKIE_NAME = "__pid";
    const REMEMBER_ME_COOKIE_NAME = "__idr";
    const EXTEND_EXPIRED_ACCESS_COOKIE_NAME = "__eea";
    const containerInner = "piano-id-container";
    const PIANO_ID_SOURCE = "PIANOID";
    const DEFAULT_PIANOID_ORIGIN = "https://id.tinypass.com";
    const SOURCE_CUSTOM_FORM = "show_form";
    const SOURCE_REGISTRATION = "registration";
    const SOURCE_CHECKOUT = "checkout";
    let REQUEST_TIMEOUT = 3e3;
    const FORCE_CLOSE_IFRAME_TIMEOUT = 600;
    const TC_STRING_LOCAL_STORAGE_KEY = "pnid-tc-string";
    const RTL_LOCALES = ["he_IL", "ar_EG"];
    let globalConfig = {};
    let iframes = [];
    let iframeModal;
    const langChangeFromIframe = {};
    const localCallbacks = {
      loggedIn: [],
      loggedOut: [],
      loginSuccess: [],
      registrationSuccess: [],
      profileUpdate: [],
      langChange: [],
      fire_loginSuccess: [],
      loginDisplayed: [],
      registerDisplayed: [],
      loginFailed: [],
      registrationFailed: [],
      onShow: [],
      layoutReady: []
    };
    let customEvents = {};
    const globalCallbacks = {};
    let initPromise;
    let configPromise;
    let isNewUser;
    let loginSuccessInProgress;
    const postMessagesBatch = [];
    let isGmSsoEnabled = false;
    let gmSsoParamsAfterRedirect = {};
    jqUtils2.on(window, "resize", () => {
      checkInlineWidgetResize();
      checkModalWidgetResize();
    });
    const setDefaultGmSsoConfirmationType = (config) => {
      var _a;
      if (isGmSsoEnabled) {
        config.confirmation = (_a = config.confirmation) != null ? _a : "after" /* After */;
      }
    };
    const checkInlineWidgetResize = (elements) => {
      iframes.filter((iframe) => iframe.config.displayMode === "inline").filter((iframe) => !elements || elements.some((element) => iframe.container === element)).forEach((iframe) => {
        const containerWidth = jqUtils2.getWidth(iframe.container);
        containerUtils2.resizeIframe(iframe, {
          width: containerWidth
        });
      });
    };
    const checkModalWidgetResize = () => {
      iframes.filter((iframe) => iframe.config.displayMode === "modal" && !iframe.closed).forEach((iframe) => {
        const config = iframe.config;
        containerUtils2.resizeIframe(iframe, { width: getDefaultWidth(config.width) });
      });
    };
    const setAccessToken = (accessToken, remember) => {
      const user2 = jwtDecode2(accessToken);
      user2.rememberMe = remember;
      storeToken({
        user: user2,
        token: accessToken
      });
    };
    const setAccessTokenAfterGmSsoRedirect = () => __async(void 0, null, function* () {
      const token = util2.getQueryParamByName(GM_SSO_REDIRECT_TOKEN);
      const remember = !!util2.getQueryParamByName(GM_SSO_REDIRECT_REMEMBER);
      const isRegistration = util2.getQueryParamByName(GM_SSO_REGISTRATION) === "true";
      util2.removeQueryParamByName([
        GM_SSO_REDIRECT_QUERY,
        GM_SSO_REDIRECT_TOKEN,
        GM_SSO_REDIRECT_REMEMBER,
        GM_SSO_TERM_ID,
        GM_SSO_OFFER_ID,
        GM_SSO_EXPERIENCE_ID,
        GM_SSO_CHECKOUT_FLOW_ID,
        GM_SSO_FORM_NAME,
        GM_SSO_FORM_NAME_BY_TERM_ID,
        GM_SSO_REGISTRATION
      ]);
      if (token) {
        yield setToken({
          source: PIANO_ID_SOURCE,
          user: jwtDecode2(token),
          remember,
          token
        }, true);
        const result = getLoginSuccessPayload(PIANO_ID_SOURCE);
        if (result) {
          fireGlobalCallbacks("loginSuccess", result.params);
        }
        if (isRegistration) {
          fireCallbacks("registrationSuccess", getRegistrationSuccessPayload(PIANO_ID_SOURCE));
        }
      }
    });
    const setGmSsoEmailAndPhoneConfirmationFromToken = () => {
      const token = tokenManager2.getToken();
      const user2 = jwtDecode2(token);
      if (!!token) {
        gmSsoParamsAfterRedirect.emailConfirmationRequired = user2.email_confirmation_required;
      }
    };
    const parseConfig = (initConfig) => {
      if (configPromise && !initConfig) {
        return configPromise;
      }
      globalConfig = Object.assign(globalConfig, initConfig);
      urlManager2.setIframeUrlFromGlobalConfig(globalConfig.iframeUrl);
      if (initConfig) {
        setCallbacks(initConfig);
      }
      Object.keys(localCallbacks).forEach((eventName) => {
        const containsEventCallback = !!globalConfig[eventName];
        if (containsEventCallback) {
          delete globalConfig[eventName];
        }
      });
      let res;
      configPromise = new Promise((resolve) => {
        res = resolve;
      });
      if (!PianoIdUtils.isPianoIdLiteConfigured()) {
        pn.setUsePianoIdUserProvider(true);
      }
      const resetToken = util2.getQueryParamByName(RESET_TOKEN_QUERY);
      if (globalConfig.resetPasswordToken === void 0 && resetToken) {
        globalConfig.resetPasswordToken = resetToken;
      }
      if (util2.getQueryParamByName(GM_SSO_REDIRECT_QUERY)) {
        const termId = util2.getQueryParamByName(GM_SSO_TERM_ID);
        const offerId = util2.getQueryParamByName(GM_SSO_OFFER_ID);
        const experienceId = util2.getQueryParamByName(GM_SSO_EXPERIENCE_ID);
        const checkoutFlowId = util2.getQueryParamByName(GM_SSO_CHECKOUT_FLOW_ID);
        const formName = util2.getQueryParamByName(GM_SSO_FORM_NAME);
        const formNameByTermId = util2.getQueryParamByName(GM_SSO_FORM_NAME_BY_TERM_ID);
        if (termId && offerId) {
          gmSsoParamsAfterRedirect.termId = termId;
          gmSsoParamsAfterRedirect.offerId = offerId;
        }
        if (experienceId) {
          gmSsoParamsAfterRedirect.experienceId = experienceId;
        }
        if (checkoutFlowId) {
          gmSsoParamsAfterRedirect.checkoutFlowId = checkoutFlowId;
        }
        if (formName) {
          gmSsoParamsAfterRedirect.formName = formName;
        }
        if (formNameByTermId) {
          gmSsoParamsAfterRedirect.formNameByTermId = formNameByTermId;
        }
        setAccessTokenAfterGmSsoRedirect();
        setGmSsoEmailAndPhoneConfirmationFromToken();
      }
      const passwordlessToken = util2.getQueryParamByName(PASSWORDLESS_TOKEN_QUERY);
      if (globalConfig.passwordlessToken === void 0 && passwordlessToken) {
        globalConfig.passwordlessToken = passwordlessToken;
      }
      const verificationCode = util2.getQueryParamByName(VERIFICATION_CODE_QUERY);
      if (globalConfig.verification_code === void 0 && verificationCode) {
        globalConfig.verification_code = verificationCode;
      }
      const access_token = util2.getQueryParamByName(ACCESS_TOKEN);
      if (access_token) {
        util2.removeQueryParamByName(ACCESS_TOKEN);
        if (!isUserValid()) {
          pn.inappBrowserReturn = true;
          setAccessToken(access_token, true);
        }
      }
      setTimeout(() => res(), 50);
      return configPromise;
    };
    const init = (config, withoutAuthByCookie) => {
      if (initPromise && !config) {
        return initPromise;
      }
      let res;
      initPromise = new Promise((resolve) => {
        res = resolve;
      });
      const doneAndResolve = () => {
        util2.doneCall("refreshUserToken");
        initPromise = null;
        res();
      };
      const isUserWasInvalidBeforeTokenVerify = !isUserValid();
      const handleAuthByCookieSuccess = () => {
        const result = getLoginSuccessPayload(PIANO_ID_SOURCE);
        if (isUserWasInvalidBeforeTokenVerify && result) {
          fireGlobalCallbacks("loginSuccess", result.params);
        }
        doneAndResolve();
      };
      const handleAuthByCookieFail = (rejectReason) => {
        var _a, _b;
        if (rejectReason === "token_not_valid") {
          doneAndResolve();
          if (isMsqaInitiated) {
            return;
          }
          if (util2.isEdge()) {
            const pianoIdUrlString = util2.getQueryParamByName("internal_redirect_uri");
            const responseId = util2.getQueryParamByName("response_id");
            const isMsqaAuthConfirmationFlow = pianoIdUrlString && responseId;
            if (isMsqaAuthConfirmationFlow) {
              msqa.clearConfirmationParameters();
              const params = Array.from(new URL(pianoIdUrlString).searchParams.entries());
              show(__spreadProps(__spreadValues(__spreadValues({}, globalConfig), params.reduce((acc, [key2, value]) => __spreadProps(__spreadValues({}, acc), {
                [key2]: value
              }), {})), {
                response_id: responseId,
                transparentMode: true
              }));
              isMsqaInitiated = true;
              return;
            }
            msqa.setLinkingStateUrl(`${urlManager2.getIdentifyUrl()}/social/${globalConfig.aid || pn.aid}/state`);
            msqa.setLinkingRedirectUri(urlManager2.getPianoIdUrl(), globalConfig.aid || pn.aid, urlManager2.getPianoIdUrl(), "en-US");
            msqa.setConfiguration(__spreadProps(__spreadValues({}, config == null ? void 0 : config.msqaPromptConfiguration), {
              locale: (_b = (_a = config == null ? void 0 : config.msqaPromptConfiguration) == null ? void 0 : _a.locale) != null ? _b : getLang().replace("_", "-")
            }));
            msqaInitializationPromise = clientConfiguration2.getConfiguration().then((config2) => __async(void 0, null, function* () {
              if (config2.msqa_client_id) {
                yield msqa.fetchLinkingState();
                return config2;
              } else {
                return Promise.reject();
              }
            })).then((config2) => msqa.init(config2.msqa_client_id, `${urlManager2.getIdentifyUrl()}/login/social/callback/MSQA`)).then(() => msqa.runLinkingStateAndPromptObserver()).then(() => {
              var _a2, _b2;
              if ((_b2 = (_a2 = config == null ? void 0 : config.msqaPromptConfiguration) == null ? void 0 : _a2.autoPrompt) != null ? _b2 : true) {
                return msqa.showPrompt();
              }
            }).then(() => isMsqaInitiated = true).catch((e) => {
              if (e instanceof MSQAError) {
                console.error(e);
              }
            });
          }
        } else if (rejectReason === "request_failed") {
          console.error("Opening the ID screen is prohibited because authentication via cookie failed.");
        }
      };
      if (config && config.preview) {
        setTimeout(() => res(), 10);
        return initPromise;
      }
      util2.startCall("refreshUserToken");
      parseConfig(config).then(() => {
        if (globalConfig.passwordlessToken) {
          return authByPasswordless().then(doneAndResolve, doneAndResolve);
        } else if (!withoutAuthByCookie) {
          return authByCookie().then(handleAuthByCookieSuccess, handleAuthByCookieFail);
        } else {
          return Promise.resolve().then(doneAndResolve, doneAndResolve);
        }
      });
      return initPromise;
    };
    const prepare = () => {
      return parseConfig();
    };
    const show = (showConfig) => {
      const initTime = performance.now();
      init().then(() => {
        var _a;
        const config = __spreadProps(__spreadValues(__spreadValues({}, globalConfig), showConfig), {
          isRegistration: true,
          initTime,
          isSensitiveDataProtectionDisabled: true
        });
        if (isUserValid()) {
          (_a = config.loggedIn) == null ? void 0 : _a.call(config, {
            token: tokenManager2.loadToken(),
            user: getUser()
          });
        }
        if (sss.isSssEnabled()) {
          config.sss = sss.getSssParams();
        }
        if (isGmSsoEnabled) {
          if (isGmSsoRedirectEnabled(config)) {
            authByGmSsoRedirect(config);
          } else {
            authByGmSsoModalOrPopup(config);
          }
          return;
        }
        if (sss.isSssEnabled() && sss.isRedirect(config)) {
          authBySssRedirect(config, (config2) => {
            setDefaultGmSsoConfirmationType(config2);
          });
          return;
        }
        if (isUserValid()) {
          return;
        } else if (iframeModal) {
          util2.log("Modal login window already shown");
        } else {
          configManager2.prepareConfig(config, (config2) => {
            setDefaultGmSsoConfirmationType(config2);
          });
          createIframe(config);
        }
      });
    };
    const checkAndShowEmailIsNotConfirmed = () => {
      const EMAIL_IS_NOT_CONFIRMED = "email_is_not_confirmed";
      const user2 = getUser();
      if (!user2) {
        return;
      }
      const emailIsNotConfirmedType = util2.getQueryParamByName(EMAIL_IS_NOT_CONFIRMED);
      if (!emailIsNotConfirmedType)
        return;
      util2.removeQueryParamByName(EMAIL_IS_NOT_CONFIRMED);
      const screen2 = emailIsNotConfirmedType === "registration" ? "email_is_not_confirmed" : "email_confirmation_required";
      _showCustom({ screen: screen2, email: user2 == null ? void 0 : user2.email });
    };
    const showEmailConfirmationRequired = (config) => {
      if (iframeModal) {
        util2.log("Modal window already shown");
        return;
      }
      init().then(() => {
        const showConfig = Object.assign({ screen: "email_confirmation_required" }, globalConfig, config);
        configManager2.prepareConfig(showConfig, (config2) => {
          setDefaultGmSsoConfirmationType(config2);
        });
        createIframe(showConfig);
      });
    };
    const showEmailConfirmation = (config) => {
      if (iframeModal) {
        util2.log("Modal window already shown");
        return;
      }
      init().then(() => {
        const showConfig = Object.assign({ screen: "email_confirmation" }, globalConfig, config);
        if (isGmSsoRedirectEnabled(showConfig)) {
          showConfig.displayMode = "modal" /* Modal */;
        }
        if (util2.getQueryParamByName(VERIFICATION_CODE_QUERY)) {
          util2.removeQueryParamByName(VERIFICATION_CODE_QUERY);
        }
        configManager2.prepareConfig(showConfig, (config2) => {
          setDefaultGmSsoConfirmationType(config2);
        });
        createIframe(showConfig);
      });
    };
    const _showCustom = (config) => {
      if (iframeModal) {
        util2.log("Modal window already shown");
        return;
      }
      if (!config) {
        config = {};
      }
      const showConfig = __spreadValues(__spreadValues({}, globalConfig), config);
      if (config.customEvents && typeof config.customEvents === "object") {
        customEvents = config.customEvents;
      }
      configManager2.prepareConfig(showConfig, (config2) => {
        setDefaultGmSsoConfirmationType(config2);
      });
      createIframe(showConfig);
    };
    const showForm = (config) => {
      const initTime = performance.now();
      init().then(() => {
        const showConfig = Object.assign({}, globalConfig, config, {
          initTime,
          isRegistration: false
        });
        const formName = showConfig.formName;
        if (!formName) {
          throw new Error('Form name should be specified, like\ntp.pianosId.showForm({formName: "..."});');
        }
        const startShowForm = () => {
          if (iframeModal) {
            util2.log("Modal login window already shown");
          } else {
            configManager2.prepareConfig(showConfig, (config2) => {
              setDefaultGmSsoConfirmationType(config2);
            });
            if (!showConfig.preview && isNewUser) {
              util2.log("Skip show form, register new user");
              return;
            }
            if (!showConfig.hideIfComplete) {
              createIframe(__spreadProps(__spreadValues({}, showConfig), {
                entityType: "customForm",
                readyCallback: (iframe) => {
                  postmessage2.send("setToken", tokenManager2.getToken(), iframe.iframeId);
                }
              }));
              return;
            }
            getUserInfo(showConfig).then((data) => {
              if ((data == null ? void 0 : data.has_all_custom_field_values_filled) && showConfig.hideIfComplete) {
                util2.log("Skip show form, all fields are completed");
                return;
              }
              createIframe(__spreadProps(__spreadValues({}, showConfig), {
                entityType: "customForm",
                readyCallback: (iframe) => {
                  postmessage2.send("setToken", tokenManager2.getToken(), iframe.iframeId);
                  postmessage2.send("userData", data, iframe.iframeId);
                }
              }));
            });
          }
        };
        if (!config.preview && !isUserValid()) {
          const authConfig = Object.assign({}, config, {
            closedCallback: () => {
              if (isUserValid()) {
                startShowForm();
              }
            }
          });
          show(authConfig);
        } else {
          startShowForm();
        }
      });
    };
    const submitLoginForm = () => {
      postmessage2.send("submitLoginForm", null, iframeModal == null ? void 0 : iframeModal.iframeId);
    };
    const authByPasswordless = () => {
      return new Promise((resolve, reject) => {
        const query2 = {
          aid: globalConfig.aid || pn.aid,
          passwordless_token: globalConfig.passwordlessToken,
          lang: getLang()
        };
        requestManager2.oldRequest({
          url: `${urlManager2.getIdentifyUrl()}/passwordless/authorization/code?${jqUtils2.param(query2)}`,
          type: "POST",
          success: (resp) => {
            _onPasswordlessLoginSuccess(resp);
            resolve(null);
          },
          error: ({ response }) => {
            const { error_code_list } = JSON.parse(response);
            _onPasswordlessLoginError(error_code_list);
            reject();
          }
        });
      });
    };
    const _onPasswordlessLoginSuccess = (resp) => __async(void 0, null, function* () {
      const {
        access_token,
        error,
        token_type,
        direction_url,
        code,
        extend_expired_access_enabled
      } = resp;
      if (!error && token_type === "code" && direction_url && code) {
        const redirectUriWithCode = new URL(direction_url);
        redirectUriWithCode.searchParams.append("code", code);
        window.open(redirectUriWithCode, window.name);
      } else if (!error && access_token) {
        _completeCheckout(resp);
        delete globalConfig["passwordlessToken"];
        util2.removeQueryParamByName(PASSWORDLESS_TOKEN_QUERY);
        if (sss.isSssEnabled()) {
          sss.setSssAccessToken(access_token, true);
        }
        yield setToken({
          source: PIANO_ID_SOURCE,
          token: access_token,
          user: jwtDecode2(access_token),
          extendExpiredAccessEnabled: extend_expired_access_enabled
        });
        if (sss.isSssEnabled()) {
          sss.setSssAccessToken(access_token);
        }
      }
      util2.doneCall("refreshUserToken");
    });
    const _onPasswordlessLoginError = (errors) => {
      _showCustom({
        screen: "passwordless_confirmation",
        jsonpError: {
          error_description: errors.map((e) => e.message).join("\n")
        }
      });
      delete globalConfig["passwordlessToken"];
      util2.removeQueryParamByName(PASSWORDLESS_TOKEN_QUERY);
    };
    const _completeCheckout = (resp) => {
      const data = {
        aid: globalConfig.aid || pn.aid,
        login_token_id: resp.login_token_id,
        user_token: resp.access_token
      };
      const additionalConfig = {
        passwordlessToken: resp.passwordless_token,
        redirectUri: resp.direction_url
      };
      _sendCompleteRequest(data, additionalConfig);
    };
    const _sendCompleteRequest = (data, additionalConfig) => {
      containerUtils2.showWaitPanel();
      api2.callApi("/anon/passwordless/complete", data, (resp) => {
        if (resp.result && resp.result.polling_enabled) {
          return checkPolling(resp).then((response) => {
            completeCheckoutCallback(response, additionalConfig);
          });
        }
        completeCheckoutCallback(resp, additionalConfig);
      });
    };
    const checkPolling = (response) => {
      return new Promise((resolve) => {
        const pollingRequestParams = {
          aid: pn.aid,
          oid: response.result.oid,
          process_id: response.result.process_id,
          user_token: pn.user.getProvider().getToken()
        };
        sendPollingRequest(pollingRequestParams, 0, response.result.polling_timeouts, resolve);
      });
    };
    const sendPollingRequest = (requestParams, attempts, timeouts, callback) => {
      api2.callApi("/anon/passwordless/check", requestParams, (response) => {
        attempts++;
        if (response && response.result && response.result.poll_status !== "waiting") {
          callback(response);
        } else if (!response.result && response.message) {
          util2.error("Passwordless purchase failed", response.message);
          callback();
        } else if (attempts <= timeouts.length) {
          setTimeout(() => {
            sendPollingRequest(requestParams, attempts, timeouts, callback);
          }, timeouts[attempts - 1]);
        } else {
          callback();
        }
      });
    };
    const completeCheckoutCallback = (response, additionalConfig) => {
      try {
        const resource = response.result.resource || {};
        const showOfferParams = JSON.parse(response.result.show_offer_params);
        let config = getCustomScreenConfig(additionalConfig);
        if (!Object.keys(resource).length && !Object.keys(showOfferParams).length) {
          return _showCustom(config);
        }
        if (resource.name) {
          config = getCustomScreenConfig(additionalConfig, {
            customParams: {
              resourceName: resource.name
            }
          });
        } else {
          config = getCustomScreenConfig(additionalConfig, {
            customEvents: {
              checkoutContinue: () => {
                closeModalContainer();
                containerUtils2.closeModalContainer();
                pn.offer.show(showOfferParams);
              }
            }
          });
        }
        _showCustom(config);
      } catch (e) {
        _showCustom(getCustomScreenConfig(additionalConfig));
      } finally {
        containerUtils2.hideWaitPanel();
      }
    };
    const getCustomScreenConfig = (additionalConfig, config) => {
      const defaultConfig = {
        screen: "passwordless_confirmation"
      };
      if (additionalConfig) {
        defaultConfig.passwordlessToken = additionalConfig.passwordlessToken;
        defaultConfig.redirectUri = additionalConfig.redirectUri;
      }
      if (config) {
        return Object.assign(defaultConfig, config);
      }
      return Object.assign(defaultConfig, { passwordlessSuccess: true });
    };
    const getLoginSuccessPayload = (source, stage) => {
      const user2 = getUser();
      if (!user2) {
        return;
      }
      const token = tokenManager2.loadToken();
      const payload = {
        token,
        user: user2,
        source,
        stage
      };
      const params = {
        event: "loginSuccess",
        params: payload.user,
        user_token: payload.token,
        registration: isNewUser,
        source,
        stage
      };
      return { payload, params };
    };
    const getRegistrationSuccessPayload = (source) => {
      const user2 = getUser();
      const token = tokenManager2.loadToken();
      if (!user2 || !token) {
        return;
      }
      return {
        token,
        user: user2,
        source
      };
    };
    const fireLoginSuccessEvent = (data) => {
      data = data || {};
      const result = getLoginSuccessPayload(data.source, data.stage);
      if (!result) {
        return;
      }
      fireLocalCallbacks("loggedIn", result.payload);
      fireLocalCallbacks("loginSuccess", result.payload);
      if (data.source === PIANO_ID_SOURCE) {
        fireLocalCallbacks("fire_loginSuccess", result.params);
        fireGlobalCallbacks("loginSuccess", result.params);
      }
    };
    const _fireLoggedOut = (source) => {
      const data = {
        source
      };
      fireLocalCallbacks("loggedOut", data);
      fireGlobalCallbacks("logout", data);
    };
    const _fireChangeScreen = (screen2, onlyGlobal) => {
      const eventNamesMap = {
        login: "loginDisplayed",
        register: "registerDisplayed"
      };
      const eventName = eventNamesMap[screen2];
      if (!onlyGlobal) {
        fireLocalCallbacks(eventName, {});
      }
      fireGlobalCallbacks(eventName, {});
    };
    const _fireCustomEvent = (config, params) => {
      var _a;
      (_a = config == null ? void 0 : config.customEvent) == null ? void 0 : _a.call(config, params);
      fireGlobalCallbacks("customEvent", params);
    };
    const fireLocalCallbacks = (event, params) => {
      var _a;
      _fireCallbackForActiveInstance(event, params);
      (_a = localCallbacks[event]) == null ? void 0 : _a.forEach((callback) => callback(params));
    };
    const _fireCallbackForActiveInstance = (event, payload) => {
      iframes.filter((i) => !i.closed).map((i) => _getCallbackFromConfig(i.config, event)).filter((f2) => !!f2).forEach((f2) => f2(payload));
    };
    const _getCallbackFromConfig = (config, callbackName) => typeof (config == null ? void 0 : config[callbackName]) === "function" ? config[callbackName] : void 0;
    const fireGlobalCallbacks = (event, params) => {
      var _a;
      (_a = globalCallbacks[event]) == null ? void 0 : _a.forEach((callback) => callback(params));
    };
    const fireCallbacks = (event, params) => {
      fireLocalCallbacks(event, params);
      fireGlobalCallbacks(event, params);
    };
    const _fireCustomEvents = (name4) => {
      if (customEvents && typeof customEvents[name4] === "function") {
        customEvents[name4]();
      }
    };
    const setCallbacks = (callbacks) => {
      if (!callbacks) {
        return;
      }
      Object.keys(localCallbacks).forEach((eventName) => {
        var _a;
        const callback = callbacks[eventName];
        if (callback) {
          (_a = localCallbacks[eventName]) == null ? void 0 : _a.push(callback);
        }
      });
    };
    const setRequestTimeout = (time) => {
      REQUEST_TIMEOUT = time;
    };
    const getDefaultWidth = (widthFromConfig) => {
      const screenWidth = window.innerWidth || document.documentElement.clientWidth || window.screen.width;
      return Math.min(screenWidth, widthFromConfig || 400);
    };
    const loginByToken = (accessToken) => __async(void 0, null, function* () {
      const user2 = jwtDecode2(accessToken);
      yield setToken({
        user: user2,
        token: accessToken
      });
      closeIframesOrHideCloseButton(user2);
    });
    const logout = (callback, source, skipCallbacks) => __async(void 0, null, function* () {
      isNewUser = false;
      yield removeTokenInAuthCookie();
      removeAllTokens();
      sss.logout();
      localStorage4.remove(TC_STRING_LOCAL_STORAGE_KEY);
      util2.setAccessTokenListCookie({ value: null }, void 0, true);
      if (!skipCallbacks) {
        _fireLoggedOut(source);
      }
      callback && callback();
    });
    function messageReceiver(iframe) {
      return function(message) {
        var _a, _b, _c, _d, _e, _f, _g;
        const config = iframe.config;
        const trackingId = config.trackingId;
        const formName = config.formName;
        switch (message.event) {
          case "updateToken":
            setToken(message.params);
            break;
          case "loaded":
            if (config.displayMode === "modal" /* Modal */) {
              containerUtils2.checkBackdropAndContainer(iframe, true);
            }
            (_a = config.loadedCallback) == null ? void 0 : _a.call(config, iframe);
            const consentParams = pn.consent.getByPurpose();
            if (consentParams) {
              postmessage2.send("consentWithModes", consentParams, iframe.iframeId);
            }
            break;
          case "stateReady":
            (_b = config.readyCallback) == null ? void 0 : _b.call(config, iframe);
            break;
          case "resize": {
            const width = config.displayMode === "modal" ? getDefaultWidth(config.width) : message.params;
            containerUtils2.resizeIframe(iframe, __spreadProps(__spreadValues({}, message.params), { width }));
            break;
          }
          case "restoreSize":
            if (iframe.config.displayMode === "inline") {
              containerUtils2.resizeIframe(iframe, {
                width: jqUtils2.getWidth(iframe.container)
              });
            }
            break;
          case "loginSuccess":
            onRegistrationOrLoginSuccess(message, () => {
              var _a2;
              (_a2 = config.callback) == null ? void 0 : _a2.call(config);
              pn.user.refreshAccessToken(true);
              postmessage2.broadcast("pianoIdLoginSuccess", message.params);
            });
            break;
          case "loginFailed":
            fireCallbacks("loginFailed", message.params);
            break;
          case "registrationSuccess":
            onRegistrationOrLoginSuccess(message, () => {
              fireCallbacks("registrationSuccess", message.params);
              postmessage2.broadcast("pianoIdLoginSuccess", message.params);
            });
            break;
          case "registrationFailed":
            fireCallbacks("registrationFailed", message.params);
            break;
          case "lang":
            updateLang(message.params.lang, true);
            toggleRTLStyles(message.params.lang, iframe);
            break;
          case "customEvent":
            _fireCustomEvent(iframe.config, message.params);
            break;
          case "closed":
            const entityType = iframe.config.entityType;
            if (entityType === "customForm") {
              fireGlobalCallbacks("customFormClosed", {
                config: iframe.config,
                reason: (_c = message.params) == null ? void 0 : _c.reason
              });
            }
            closeIframe(iframe, { force: true });
            (_d = config.closedCallback) == null ? void 0 : _d.call(config, iframe);
            break;
          case "cfFormSubmission":
            analytics2.log.event({
              eventType: "logCustomFormSubmission" /* LOG_CUSTOM_FORM_SUBMISSION */,
              payload: {
                trackingId,
                formName,
                source: SOURCE_CUSTOM_FORM
              }
            });
            break;
          case "formSend":
            fireGlobalCallbacks("customFormSubmitted", {
              config: iframe.config,
              submittedFields: (_e = message.params) == null ? void 0 : _e.submittedFields
            });
            closeIframe(iframe, { reason: "customFormSubmitted" });
            break;
          case "formSkip":
            closeIframe(iframe);
            break;
          case "cfAppImpression":
            analytics2.log.event({
              eventType: "logCustomFormImpression" /* LOG_CUSTOM_FORM_IMPRESSION */,
              payload: {
                trackingId,
                formName,
                source: SOURCE_REGISTRATION
              }
            });
            break;
          case "cfAppSubmission":
            analytics2.log.event({
              eventType: "logCustomFormSubmission" /* LOG_CUSTOM_FORM_SUBMISSION */,
              payload: {
                trackingId,
                formName,
                source: SOURCE_REGISTRATION
              }
            });
            break;
          case "cfFormImpression":
            analytics2.log.event({
              eventType: "logCustomFormImpression" /* LOG_CUSTOM_FORM_IMPRESSION */,
              payload: {
                trackingId,
                formName,
                source: SOURCE_CUSTOM_FORM
              }
            });
            break;
          case "changeScreen":
            _fireChangeScreen(message.params.screen);
            break;
          case "screenReady":
            if (config.initTime) {
              logging2.setTime("idShow", Math.floor(performance.now() - config.initTime), {
                aot: (_f = message.params) == null ? void 0 : _f.AOT,
                form_type: (_g = config.entityType) != null ? _g : ""
              });
            }
            fireCallbacks("onShow");
            break;
          case "layoutReady":
            fireCallbacks("layoutReady", message.params);
            break;
          case "confirmationEmailSent":
            if (iframe.config.displayMode !== "inline" && !message.params.isDOI && !message.params.isPasswordlessDigitalCode) {
              closeIframe(iframe);
            }
            break;
          case "verificationCodeStartCheckout":
            let startCheckoutParams = {};
            try {
              startCheckoutParams = JSON.parse(message.params.startCheckoutParams);
            } catch (e) {
              util2.log("error parse start checkout params");
              startCheckoutParams = {};
            }
            authByCookie(true, true).then(() => {
              closeIframe(iframe, { force: true });
            });
            util2.waitCall("refreshUserToken", function() {
              pn.offer.show(startCheckoutParams);
            });
            break;
          case "removeParamFromGlobalConfig":
            removeParamFromGlobalConfig(message);
            break;
          case "verifyCode":
            verifyCode(message, iframe);
            break;
          case "openPasswordlessLoginWithCreatingUser":
            openPasswordlessLoginWithCreateUser();
            break;
          case "fireCustomEvent":
            _fireCustomEvents(message.params.name);
            break;
          case "passwordRestored":
            util2.removeQueryParamByName(RESET_TOKEN_QUERY);
            globalConfig.resetPasswordToken = void 0;
            break;
          case "emitGAEvent" /* EMIT_GA_EVENT */:
            analytics2.ga.event({
              payload: message.params,
              eventType: "emitGAEvent" /* EMIT_GA_EVENT */
            });
            break;
          case "redirect":
            document.location.href = message.params.url;
            break;
          case "designVersion":
            containerUtils2.addClassToContainer(iframe, `piano-id-modal-ver-${message.params.version}`);
            break;
          case "profileUpdated":
            fireLocalCallbacks("profileUpdate", message.params);
            break;
          case "logout":
            const isUserLoggedIn = isUserValid();
            if (isUserLoggedIn) {
              logout();
            }
            break;
          case "successDOI":
            postmessage2.broadcast(message.event, message.params);
            gmSsoActionAfterTokenVerify();
            break;
          default:
            util2.debug("Received invalid event type: " + message.event);
            break;
        }
      };
    }
    const openPasswordlessLoginWithCreateUser = () => {
      show({ createPasswordlessUser: true });
    };
    const removeParamFromGlobalConfig = (message) => {
      const parameter = message.params.name;
      const camelCaseName = util2.fromUnderscoreToCamelCase(parameter);
      delete globalConfig[camelCaseName];
      if (message.params.removeFromUrl) {
        util2.removeQueryParamByName(parameter);
      }
    };
    const verifyCode = (message, iframe) => {
      const verificationCode = message.params.verificationCode;
      const locale = message.params.locale;
      const clientId = globalConfig.aid || pn.aid;
      const access_token = tokenManager2.getToken();
      const site = document.location.href;
      const trackingId = iframe.config.trackingId;
      requestManager2.oldRequest({
        url: `${urlManager2.getIdentifyUrl()}/verification/code`,
        dataType: "jsonp",
        data: {
          client_id: clientId,
          access_token,
          site,
          verification_code: verificationCode,
          lang: locale,
          tracking_id: trackingId
        },
        success: (resp) => {
          if (!resp.error) {
            onVerificationSuccess(resp, iframe);
          }
        },
        xhrFields: {
          withCredentials: true
        },
        crossDomain: true
      });
    };
    const onVerificationSuccess = (resp, iframe) => {
      if (!resp.error && resp.access_token) {
        storeToken({
          token: resp.access_token,
          user: jwtDecode2(resp.access_token),
          cookie_domain: resp.site_cookie_domain
        });
        if (sss.isSssEnabled()) {
          sss.setSssAccessToken(resp.access_token);
        }
      }
      postmessage2.send("verificationCodeComplete", resp, iframe.iframeId);
    };
    const onRegistrationOrLoginSuccess = (message, callback) => __async(void 0, null, function* () {
      var _a;
      if (message && message.params && !message.params.areCookiesSet) {
        message.params.source = PIANO_ID_SOURCE;
        isNewUser = !!message.params.registration;
        const data = yield setToken(message.params);
        callback(data);
        closeIframesOrHideCloseButton((_a = message.params) == null ? void 0 : _a.user);
      } else if (typeof callback === "function") {
        callback();
      }
      markGmSsoConfirmAsShown();
    });
    const offerMessageReceiver = (message) => {
      switch (message.params.event) {
        case "cfAppImpression":
        case "cfFormImpression":
          analytics2.log.event({
            eventType: "logCustomFormImpression" /* LOG_CUSTOM_FORM_IMPRESSION */,
            payload: {
              trackingId: message.params.trackingId,
              formName: message.params.trackingId,
              source: SOURCE_CHECKOUT
            }
          });
          break;
        case "cfFormSubmission":
          analytics2.log.event({
            eventType: "logCustomFormSubmission" /* LOG_CUSTOM_FORM_SUBMISSION */,
            payload: {
              trackingId: message.params.trackingId,
              formName: message.params.trackingId,
              source: SOURCE_CHECKOUT
            }
          });
          break;
        case "updateToken":
          setToken(message.params.params);
          break;
        case "changeScreen":
          _fireChangeScreen(message.params.params.screen, true);
          break;
        case "loginFailed":
        case "registrationFailed":
        case "successDOI":
        case "registrationSuccess":
        case "customEvent":
          fireGlobalCallbacks(message.params.event, message.params.params);
          break;
        case "emitGAEvent" /* EMIT_GA_EVENT */:
          analytics2.ga.event({
            payload: message.params.params,
            eventType: "emitGAEvent" /* EMIT_GA_EVENT */
          });
          break;
        case "redirect":
          document.location.href = message.params.params.url;
          break;
        default:
          util2.debug("Received invalid event type: " + message.params.event);
          return;
      }
    };
    const getPianoIdDomain = () => {
      const isSandbox = pn.sandbox || pn.isNonProdEndpoint();
      let domain = globalConfig.iframeUrl || pn.pianoIdUrl || !isSandbox && DEFAULT_PIANOID_ORIGIN || "/";
      if (domain === "/") {
        domain = pn.getEndpointRoot(true);
      }
      return domain.replace(/\/$/, "");
    };
    const closeIframesOrHideCloseButton = (user2) => {
      const isDOIEnabled = user2 == null ? void 0 : user2.email_confirmation_required;
      const verificationCode = globalConfig.verification_code;
      if (isDOIEnabled || verificationCode) {
        containerUtils2.hideCloseButton();
      } else {
        closeIframes();
      }
    };
    const authBySssRedirect = (config, configModifier) => {
      configManager2.prepareConfig(config, configModifier);
      if (!tokenManager2.getToken()) {
        window.open(iframeBuilder.buildIframeUrl(urlManager2.getPianoIdUrl(), config), window.name);
      }
    };
    const createIframe = (config) => {
      const wrapper = config.containerSelector ? jqUtils2.queryEl(config.containerSelector) : null;
      const id = `piano-id-${!config.isRegistration ? "form-" : ""}${util2.randomString()}`;
      config.singleContainer = wrapper;
      const iframeParams = {
        iframeId: id,
        containerSelector: config.containerSelector,
        width: config.width,
        height: config.height
      };
      let iframeUrl = iframeBuilder.buildIframeUrl(urlManager2.getPianoIdUrl(), config, iframeParams);
      let container2;
      let element;
      let containerReady = true;
      let obs;
      config.iframeParams = iframeParams;
      if (config.displayMode === "inline" /* Inline */) {
        const inlineContainer = containerUtils2.initInlineContainer(config);
        container2 = inlineContainer.container;
        if (!container2) {
          return;
        }
        element = containerUtils2.generateIframe(config, iframeParams, iframeUrl);
        containerReady = !!inlineContainer.containerReady;
        if (config.observeContainer) {
          obs = observer2.create(container2, checkInlineWidgetResize);
        }
      } else if (config.displayMode === "modal" /* Modal */) {
        container2 = containerUtils2.getModalContainer(config, () => {
          return closeIframe(iframeModal);
        });
        element = containerUtils2.generateIframe(config, iframeParams, iframeUrl);
      } else if (config.displayMode === "popup" /* Popup */) {
        if (util2.isIE()) {
          container2 = containerUtils2.generateIframeWrapper();
          iframeUrl = iframeBuilder.buildIframeUrl(urlManager2.getPianoIdUrl(), config, iframeParams, urlManager2.getPianoIdUrl() + "proxy.html");
          iframeParams.iframeUrl = iframeUrl;
          iframeParams.pos = containerUtils2.getPopupPosition(iframeParams);
          const popupUrl = iframeBuilder.buildIframeUrl(urlManager2.getPianoIdUrl() + "proxy.html", config, iframeParams);
          config.displayMode = "inlinePopup" /* InlinePopup */;
          element = containerUtils2.generateIframe({}, iframeParams, popupUrl);
        } else {
          container2 = containerUtils2.generatePopup(iframeParams, iframeUrl);
          try {
            try {
              element = container2.document;
            } catch (e) {
              element = container2;
            }
          } catch (e) {
            element = window.document;
          }
        }
      }
      const iframe = {
        iframeId: iframeParams.iframeId,
        config,
        element,
        container: container2,
        iframeParams,
        containerReady
      };
      addEventsListener(iframe);
      if (config.displayMode === "inline" /* Inline */) {
        const elementWrapper = document.createElement("div");
        jqUtils2.addClass(containerInner, elementWrapper);
        jqUtils2.append(elementWrapper, element);
        jqUtils2.append(container2, elementWrapper);
      } else if (config.displayMode === "modal" /* Modal */) {
        jqUtils2.append(container2, element);
      } else if (config.displayMode === "inlinePopup" /* InlinePopup */) {
        jqUtils2.append(container2, element);
        jqUtils2.append(document.body, container2);
      }
      util2.debug("creating iframe: ", config);
      iframes.push(iframe);
      if (config.displayMode === "modal" /* Modal */) {
        iframeModal = iframe;
        iframeModal.observer = obs;
        const lang = getLang();
        toggleRTLStyles(lang, iframe);
      }
      return iframe;
    };
    const addEventsListener = (iframe) => {
      const initParams = {
        center: util2.centerScreen(),
        originUrl: document.location.href
      };
      postmessage2.init({
        postMessageUrl: urlManager2.getPianoIdUrl(),
        receive: messageReceiver(iframe),
        iframe,
        iframeParams: iframe.iframeParams
      }, initParams);
    };
    const closeModalContainer = (iframe) => {
      if (!iframeModal) {
        return;
      }
      const mobileModalFix = containerUtils2.__private__.mobileModalFix;
      containerUtils2.closeModal(iframeModal);
      jqUtils2.remove(iframeModal.element);
      if (iframeModal.observer) {
        iframeModal.observer.disconnect();
      }
      if (mobileModalFix.isIphoneCaretFixed) {
        mobileModalFix.modalClosed();
      }
      iframeModal = void 0;
    };
    const getBaseCookieOptions = () => {
      const options = {
        path: "/",
        secure: util2.__protected__.isHttpsProtocol(),
        priority: "High"
      };
      if (pn.cookieDomain) {
        options.domain = pn.cookieDomain;
      } else {
        const domainFromCookie = util2.__protected__.getCookie(DOMAIN_COOKIE_NAME);
        const domain = util2.extractCookieDomain(domainFromCookie);
        if (domain) {
          options.domain = domain;
        }
      }
      if (pn.cookiePath) {
        options.path = pn.cookiePath;
      }
      return options;
    };
    const storeToken = (data) => {
      if (!data || !data.user || !data.token) {
        return;
      }
      removeAllTokens({
        keepRememberMe: true,
        keepExtendExpiredAccess: true
      });
      if (data.cookie_domain) {
        setDomainCookie(data.cookie_domain);
      }
      const rememberMe = "r" in data.user ? data.user.r : data.user.rememberMe || hasRememberMeCookie();
      const options = {};
      if (rememberMe) {
        options.expires = new Date(data.user.exp * 1e3);
        setCookie(REMEMBER_ME_COOKIE_NAME, 1, options);
      }
      if (!!data.extendExpiredAccessEnabled) {
        postMessagesBatchPush("setExtendExpiredAccess", true, "broadcast");
        setCookie(EXTEND_EXPIRED_ACCESS_COOKIE_NAME, "true", options);
      }
      if (sss.isSssEnabled()) {
        return;
      }
      const domains = util2.getPossibleCookieDomains();
      for (let i in domains) {
        util2.deleteCookie(COOKIE_NAME2, domains[i]);
      }
      setCookie(COOKIE_NAME2, data.token, options);
    };
    const setCookie = (name4, value, additionalOptions) => {
      util2.__protected__.setCookieConsent("id", name4, value, __spreadValues(__spreadValues({}, getBaseCookieOptions()), additionalOptions));
    };
    const setDomainCookie = (value) => {
      setCookie(DOMAIN_COOKIE_NAME, value, { domain: value, expires: 30 });
    };
    const removeAllTokens = ({
      keepRememberMe,
      keepExtendExpiredAccess
    } = {}) => {
      const options = getBaseCookieOptions();
      const domains = util2.getPossibleCookieDomains(options.domain);
      domains.forEach((domain) => {
        if (!domain) {
          return;
        }
        const domain_option = __spreadProps(__spreadValues({}, options), { domain });
        cookie3.remove(COOKIE_NAME2, domain_option);
        if (!keepExtendExpiredAccess) {
          cookie3.remove(EXTEND_EXPIRED_ACCESS_COOKIE_NAME, domain_option);
        }
        if (!keepRememberMe) {
          removeRememberMeCookie(domain_option);
        }
      });
    };
    const getUser = () => {
      let user2 = null;
      const token = tokenManager2.loadToken();
      if (token) {
        try {
          user2 = jwtDecode2(token);
          if (user2) {
            user2.firstName = user2.given_name;
            user2.lastName = user2.family_name;
            user2.valid = true;
            user2.uid = user2.sub;
            user2.confirmed = !user2.email_confirmation_required && !user2.pn_cr;
            const now = new Date();
            const exp = new Date(user2.exp * 1e3);
            if (exp < now) {
              removeAllTokens();
              user2 = null;
            }
          }
        } catch (e) {
        }
      }
      return user2;
    };
    const loadExtendedUser = (_config) => {
      const config = Object.assign({}, globalConfig, _config);
      getUserInfo(config).then((data) => {
        const newData = Object.assign({}, data);
        if (data && Array.isArray(data.custom_field_values)) {
          data.custom_field_values = data.custom_field_values.map((field) => {
            let value;
            try {
              value = JSON.parse(field.value);
            } catch (e) {
              value = field.value;
            }
            return {
              field_name: field.field_name,
              value,
              created: field.created
            };
          });
        }
        if (typeof config.extendedUserLoaded === "function") {
          config.extendedUserLoaded(newData);
        }
        fireGlobalCallbacks("extendedUserLoaded", newData);
      });
    };
    const setToken = (data, silent) => __async(void 0, null, function* () {
      storeToken(data);
      yield storeTokenInAuthCookie(data.token, data.rememberMe);
      !silent && fireLoginSuccessEvent({ stage: data.stage, source: data.source });
    });
    const isUserValid = () => {
      if (PianoIdUtils.isPianoIdLiteConfigured()) {
        return !!pn.externalJWT;
      }
      return !!getUser();
    };
    const authSetToken = (resp, silent, closeModal) => __async(void 0, null, function* () {
      const user2 = jwtDecode2(resp.access_token);
      const result = yield setToken({
        token: resp.access_token,
        user: user2,
        cookie_domain: resp.site_cookie_domain,
        extendExpiredAccessEnabled: resp.extend_expired_access_enabled
      }, silent);
      if (closeModal) {
        closeIframesOrHideCloseButton(user2);
      }
      util2.doneCall("refreshUserToken");
      return result;
    });
    const authByGmSsoModalOrPopup = (config) => __async(void 0, null, function* () {
      let gmSsoShowConfig = __spreadProps(__spreadValues({}, config), {
        isGmSsoEnabled
      });
      configManager2.prepareConfig(gmSsoShowConfig, (config2) => {
        setDefaultGmSsoConfirmationType(config2);
      });
      if (iframeModal) {
        util2.log("Modal login window already shown");
        return;
      }
      if (!tokenManager2.getToken()) {
        createIframe(gmSsoShowConfig);
      } else {
        const isNeedShowAfterConfirmation = gmSsoShowConfig.confirmation !== "none" /* None */ && !wasGmSsoModalShown() && gmSsoShowConfig.displayMode !== "popup" /* Popup */;
        if (isNeedShowAfterConfirmation) {
          createIframe(__spreadProps(__spreadValues({}, gmSsoShowConfig), {
            confirmation: "after" /* After */
          }));
          markGmSsoConfirmAsShown();
        }
      }
    });
    const gmSsoActionAfterTokenVerify = () => {
      if ((gmSsoParamsAfterRedirect == null ? void 0 : gmSsoParamsAfterRedirect.offerId) && (gmSsoParamsAfterRedirect == null ? void 0 : gmSsoParamsAfterRedirect.termId)) {
        let config = {
          offerId: gmSsoParamsAfterRedirect.offerId,
          termId: gmSsoParamsAfterRedirect.termId,
          closeOnLogout: true
        };
        if (gmSsoParamsAfterRedirect.formNameByTermId) {
          config.formNameByTermId = gmSsoParamsAfterRedirect.formNameByTermId;
        }
        if (gmSsoParamsAfterRedirect.experienceId) {
          config.experienceId = gmSsoParamsAfterRedirect.experienceId;
        }
        if (gmSsoParamsAfterRedirect.checkoutFlowId) {
          config.checkoutFlowId = gmSsoParamsAfterRedirect.checkoutFlowId;
        }
        pn.offer.show(config);
        gmSsoParamsAfterRedirect.offerId = void 0;
        gmSsoParamsAfterRedirect.termId = void 0;
        gmSsoParamsAfterRedirect.formNameByTermId = void 0;
        gmSsoParamsAfterRedirect.experienceId = void 0;
        gmSsoParamsAfterRedirect.checkoutFlowId = void 0;
        gmSsoParamsAfterRedirect.emailConfirmationRequired = void 0;
        return;
      }
      if (gmSsoParamsAfterRedirect == null ? void 0 : gmSsoParamsAfterRedirect.emailConfirmationRequired) {
        showEmailConfirmationRequired({ displayMode: "modal" /* Modal */ });
        gmSsoParamsAfterRedirect.emailConfirmationRequired = void 0;
        return;
      }
      if (gmSsoParamsAfterRedirect == null ? void 0 : gmSsoParamsAfterRedirect.formName) {
        showForm({ formName: gmSsoParamsAfterRedirect == null ? void 0 : gmSsoParamsAfterRedirect.formName });
        gmSsoParamsAfterRedirect.formName = void 0;
      }
      if (globalConfig.confirmation !== "none" /* None */ && !wasGmSsoModalShown()) {
        authByGmSsoModalOrPopup({ doNotCloseAfterLogin: true, isRegistration: true });
      }
    };
    const authByCookie = (silent, withoutCloseModal) => {
      return new Promise((resolve, reject) => {
        util2.startCall("refreshUserToken");
        const onAuthByCookieComplete = (options) => {
          if (options.isSuccessful) {
            resolve(null);
            if (isGmSsoEnabled) {
              gmSsoActionAfterTokenVerify();
            }
            msqa.clearConfirmationParameters();
          } else {
            reject(options.failReason);
          }
          util2.doneCall("refreshUserToken");
        };
        const authByCookieSuccess = (resp) => __async(void 0, null, function* () {
          isGmSsoEnabled = resp.authorized_by_sso;
          if (!resp.error && resp.access_token) {
            if (!PianoIdUtils.isPianoIdLiteConfigured()) {
              yield authSetToken(resp, false, true);
            }
            onAuthByCookieComplete({ isSuccessful: true });
          } else {
            if (resp.site_cookie_domain) {
              setDomainCookie(resp.site_cookie_domain);
            }
            removeAllTokens();
            onAuthByCookieComplete({
              isSuccessful: false,
              failReason: "token_not_valid"
            });
          }
        });
        const accessToken = tokenManager2.getToken() || void 0;
        const data = {
          client_id: globalConfig.aid || pn.aid,
          site: document.location.origin || document.location.href
        };
        const tcString = getTcString();
        if (!!tcString) {
          data.tcf = tcString;
        }
        if (accessToken) {
          requestManager2.oldRequest({
            url: `${urlManager2.getIdentifyUrl()}/token/validation`,
            data: {
              client_id: globalConfig.aid || pn.aid,
              site: document.location.origin || document.location.href
            },
            headers: {
              Authorization: accessToken
            },
            success: function(resp) {
              authByCookieSuccess(resp);
              if (resp.access_token) {
                saveTcStringToLocalStorage(tcString);
              }
            },
            error: () => onAuthByCookieComplete({
              isSuccessful: false,
              failReason: "request_failed"
            })
          });
        } else {
          requestManager2.oldRequest({
            url: `${urlManager2.getIdentifyUrl()}/token/verify`,
            data,
            success: function(resp) {
              authByCookieSuccess(resp);
              if (resp.access_token) {
                saveTcStringToLocalStorage(tcString);
                if (sss.isSssEnabled()) {
                  sss.setSssAccessToken(resp.access_token);
                }
              }
            },
            error: () => onAuthByCookieComplete({
              isSuccessful: false,
              failReason: "request_failed"
            }),
            dataType: "jsonp",
            xhrFields: {
              withCredentials: true
            },
            crossDomain: true
          });
        }
      });
    };
    const getTcString = () => {
      const windowRef = window;
      let localTcString = localStorage4.get(TC_STRING_LOCAL_STORAGE_KEY);
      const isTcStringActual = function(data) {
        if (!data)
          return false;
        const tcData = data;
        if (!tcData || !tcData.tcString || !tcData.date)
          return false;
        const currentDate = new Date();
        const tcStringGenerateDate = new Date(tcData.date);
        const delta = Math.abs(tcStringGenerateDate.getTime() - currentDate.getTime());
        const daysPassed = Math.ceil(delta / (1e3 * 60 * 60 * 24));
        return daysPassed <= 1;
      };
      const generateTcString = function() {
        let result = null;
        const callback = function(tcData, success) {
          if (success && !!tcData.tcString) {
            result = tcData.tcString;
          }
        };
        if (windowRef.__tcfapi) {
          windowRef.__tcfapi("getTCData", 2, callback, [412]);
        }
        return result;
      };
      if (isTcStringActual(localTcString)) {
        return null;
      }
      return generateTcString();
    };
    const saveTcStringToLocalStorage = (value) => {
      if (value) {
        const saveObject = {
          date: new Date().toString(),
          tcString: value
        };
        setToLocalStorage(TC_STRING_LOCAL_STORAGE_KEY, JSON.stringify(saveObject));
      }
    };
    const extendUserToken = () => {
      const token = tokenManager2.loadToken();
      if (!token) {
        return;
      }
      const now = new Date().getTime();
      const isExtendAccessEnabled = util2.__protected__.getCookie(EXTEND_EXPIRED_ACCESS_COOKIE_NAME);
      const user2 = jwtDecode2(token);
      const isPassed1DayAfterTokenIssue = now - user2.iat * 1e3 > 24 * 60 * 60 * 1e3;
      if (isExtendAccessEnabled && isPassed1DayAfterTokenIssue) {
        authByCookie(false, true);
      }
    };
    const removeTokenInAuthCookie = () => {
      return new Promise((resolve) => {
        const token = tokenManager2.getToken();
        const data = {
          client_id: globalConfig.aid || pn.aid
        };
        if (!!token) {
          Object.assign(data, { token });
        }
        requestManager2.oldRequest({
          url: `${urlManager2.getIdentifyUrl()}/logout`,
          data,
          dataType: "jsonp",
          complete: resolve,
          xhrFields: {
            withCredentials: true
          },
          crossDomain: true
        });
      });
    };
    const storeTokenInAuthCookie = (token, rememberMe) => {
      return new Promise((resolve) => {
        const isSessionCookie = !(rememberMe || hasRememberMeCookie());
        requestManager2.oldRequest({
          url: `${urlManager2.getIdentifyUrl()}/vxauth/cookie`,
          data: {
            client_id: globalConfig.aid || pn.aid,
            session_cookie: isSessionCookie
          },
          headers: {
            Authorization: token || void 0
          },
          complete: resolve
        });
      });
    };
    const closeIframe = (iframe, { force, reason } = {}) => {
      if (!iframe) {
        return;
      }
      if (!force) {
        postmessage2.send("close", { reason }, iframe.iframeId);
        iframes = iframes.filter(function(iframeItem) {
          return iframeItem.iframeId !== iframe.iframeId;
        });
        setTimeout(() => {
          closeIframe(iframe, { force: true });
        }, FORCE_CLOSE_IFRAME_TIMEOUT);
      } else if (!iframe.closed) {
        iframe.closed = true;
        if (iframe.config.displayMode === "inline") {
          jqUtils2.empty(iframe.container);
        } else if (iframe.config.displayMode === "popup") {
          iframe.container.close();
        } else if (iframe.config.displayMode === "modal") {
          closeModalContainer(iframe);
          jqUtils2.remove(iframe.container.parentElement);
        }
        if (isGmSsoEnabled) {
          markGmSsoConfirmAsShown();
        }
      }
    };
    const closeIframes = () => {
      iframes.filter((iframe) => {
        const config = iframe.config;
        return !config.doNotCloseAfterLogin;
      }).forEach((iframe) => {
        closeIframe(iframe);
      });
      iframes = [];
    };
    const updateLang = (locale, within) => {
      const currentLangInCookie = util2.__protected__.getCookie(LANG_COOKIE_NAME);
      const domainFromCookie = util2.__protected__.getCookie(DOMAIN_COOKIE_NAME);
      if (currentLangInCookie === locale || !domainFromCookie) {
        return;
      }
      setCookie(LANG_COOKIE_NAME, locale, { expires: 30 });
      if (!within) {
        iframes.forEach((iframe) => {
          postmessage2.send("lang", { lang: locale }, iframe.iframeId);
        });
      }
      Object.keys(langChangeFromIframe).forEach((iframeId) => {
        const callback = langChangeFromIframe[iframeId];
        if (postmessage2.__protected__.isIframeManaged(iframeId) && callback) {
          callback(locale);
        } else {
          delete langChangeFromIframe[iframeId];
        }
      });
      fireCallbacks("langChange", locale);
    };
    const onLangChange = (func, iframeId) => {
      langChangeFromIframe[iframeId] = func;
      return () => {
        delete langChangeFromIframe[iframeId];
      };
    };
    const getLang = () => {
      return pn.locale || util2.__protected__.getCookie(LANG_COOKIE_NAME) || "";
    };
    const getRememberMeCookie = () => {
      return util2.__protected__.getCookie(REMEMBER_ME_COOKIE_NAME) || false;
    };
    const removeRememberMeCookie = (options) => {
      if (options) {
        cookie3.remove(REMEMBER_ME_COOKIE_NAME, options);
      }
    };
    const hasRememberMeCookie = () => {
      return !!getRememberMeCookie();
    };
    const onLoginSuccess = (params) => __async(void 0, null, function* () {
      if (loginSuccessInProgress) {
        return;
      }
      loginSuccessInProgress = true;
      const data = {
        source: params.source,
        token: params.user_token,
        user: params.params || params.user,
        cookie_domain: params.cookie_domain,
        stage: params.stage
      };
      util2.setAccessTokenListCookie({
        value: params.token_list,
        cookie_domain: params.cookie_domain
      }, params.user_token);
      yield setToken(data);
      closeIframesOrHideCloseButton(data.user);
      loginSuccessInProgress = false;
    });
    const onProfileUpdate = (params, callback) => __async(void 0, null, function* () {
      const data = {
        token: params.token,
        user: params.user,
        cookie_domain: params.cookie_domain
      };
      yield setToken(data, true);
      callback();
      fireLocalCallbacks("profileUpdate", data);
    });
    const onExtendedUserLoginRequired = () => {
      _showCustom();
    };
    const isConfigured = () => {
      return pn.usePianoIdUserProvider === true || typeof pn.usePianoIdUserProvider === "string" && pn.usePianoIdUserProvider === "true";
    };
    const getName = () => {
      return "piano_id";
    };
    const registerCallback = (event, callback) => {
      var _a;
      const eventCallbacks = (_a = globalCallbacks[event]) != null ? _a : [];
      globalCallbacks[event] = [...eventCallbacks, callback];
    };
    const getUserInfo = (config) => {
      return new Promise((resolve) => {
        const showConfig = Object.assign({}, globalConfig, config);
        requestManager2.oldRequest({
          url: `${urlManager2.getIdentifyUrl()}/userinfo`,
          data: {
            client_id: globalConfig.aid || pn.aid,
            form_name: showConfig.formName
          },
          headers: {
            Authorization: tokenManager2.getToken() || void 0
          },
          success: resolve,
          complete: () => resolve(null)
        });
        setTimeout(resolve, REQUEST_TIMEOUT);
      });
    };
    const isAot = () => {
      iframes.forEach((iframe) => {
        postmessage2.send("isAOT", {}, iframe.iframeId);
      });
    };
    const isGmSso = () => {
      return isGmSsoEnabled;
    };
    const isGmSsoRedirectEnabled = (config) => {
      const isBrowserBlocksThirdPartyCookies = util2.isSafariOrUiWebView() || util2.isChrome();
      const isRedirectConfigured = (config == null ? void 0 : config.displayMode) === "redirect" /* Redirect */ || !(config == null ? void 0 : config.displayMode) && (globalConfig == null ? void 0 : globalConfig.displayMode) === "redirect" /* Redirect */;
      const isSafariAndDisplayModeUndefined = isBrowserBlocksThirdPartyCookies && !(config == null ? void 0 : config.displayMode) && !(globalConfig == null ? void 0 : globalConfig.displayMode);
      return isRedirectConfigured || isSafariAndDisplayModeUndefined;
    };
    const authByGmSsoRedirect = (config) => {
      var _a;
      if (tokenManager2.getToken()) {
        return;
      }
      config = __spreadProps(__spreadValues(__spreadValues({}, globalConfig), config), {
        redirectUri: (_a = config.redirectUri) != null ? _a : window.location.href
      });
      const buildGmSsoRedirectUrl = (base, config2) => {
        var _a2;
        const { pageViewId: pageViewId2, pageTitle } = util2.getPageViewContext();
        const userState2 = util2.getUserState();
        const query2 = {
          client_id: config2.aid,
          gm_sso_piano_id_domain: getPianoIdDomain(),
          site: document.location.href,
          display_mode: "redirect",
          gm_sso_redirect_container_width: (_a2 = config2.width) != null ? _a2 : getDefaultWidth(),
          page_view_id: pageViewId2 != null ? pageViewId2 : void 0,
          page_title: pageTitle,
          browser_id: getBrowserId()
        };
        const lang = getLang();
        if (lang) {
          query2.lang = lang;
        }
        if (pn.staticDomain) {
          query2.static_domain = pn.staticDomain;
        }
        if (config2.screen) {
          query2.screen = config2.screen;
        }
        if (config2.resetPasswordToken) {
          query2.reset = config2.resetPasswordToken;
        }
        if (config2.redirectUri) {
          query2.redirect_uri = config2.redirectUri;
        }
        if (config2.offerId) {
          query2.gm_sso_offer_id = config2.offerId;
        }
        if (config2.termId) {
          query2.gm_sso_term_id = config2.termId;
        }
        if (config2.experienceId) {
          query2.gm_sso_experience_id = config2.experienceId;
        }
        if (config2.checkoutFlowId) {
          query2.gm_sso_checkout_flow_id = config2.checkoutFlowId;
        }
        if (config2.confirmation) {
          query2.gm_sso_confirm = config2.confirmation;
        }
        if (config2.transparentMode) {
          query2.transparent_mode = true;
        }
        if (userState2) {
          query2.user_state = userState2;
        }
        const wasTermOpenedViaComposer = config2.termId && config2.formNameByTermId;
        if (config2.formName) {
          query2.form_name = config2.formName;
        } else if (wasTermOpenedViaComposer) {
          const checkoutFormName = getCheckoutCustomFormName(config2.formNameByTermId, config2.termId);
          if (checkoutFormName) {
            query2.form_name = checkoutFormName;
          }
        }
        if (config2.formNameByTermId) {
          query2.form_name_by_term_id = config2.formNameByTermId;
        }
        if (config2.sss) {
          query2.sss_mode = config2.sss.sss_mode;
          query2.sss_callback_url = config2.sss.sss_callback_url;
          query2.sss_origin_url = config2.sss.sss_origin_url;
        }
        base += "gm-sso";
        return [base, jqUtils2.param(query2)].join("?");
      };
      const openRedirectGmSsoPage = (config2) => {
        const openedWindow = window.open(buildGmSsoRedirectUrl(urlManager2.getPianoIdUrl(), config2), window.name);
        if (!!openedWindow) {
          markGmSsoConfirmAsShown();
        }
      };
      const getCheckoutCustomFormName = (formNameByTermIdJson, termId) => {
        const formNameByTermId = JSON.parse(formNameByTermIdJson);
        return formNameByTermId[termId];
      };
      configManager2.prepareConfig(config, (conf) => {
        setDefaultGmSsoConfirmationType(conf);
      });
      openRedirectGmSsoPage(config);
    };
    const postMessagesBatchPush = (name4, data, type2) => {
      postMessagesBatch.push({ type: type2, name: name4, data });
    };
    const executePostMessagesBatch = () => {
      while (postMessagesBatch.length) {
        const pm = postMessagesBatch.pop();
        if (pm.type === "broadcast") {
          postmessage2.broadcast(pm.name, pm.data);
        } else {
          postmessage2.send(pm.name, pm.data);
        }
      }
    };
    const toggleRTLStyles = (locale, iframe) => {
      if (RTL_LOCALES.includes(locale)) {
        containerUtils2.turnOnRTL(iframe);
      } else {
        containerUtils2.turnOffRTL(iframe);
      }
    };
    const wasGmSsoModalShown = () => {
      return !!util2.__protected__.getCookie("piano-id-initial-gm-sso-shown-" + (globalConfig.aid || pn.aid));
    };
    const markGmSsoConfirmAsShown = () => {
      setCookie(`piano-id-initial-gm-sso-shown-${globalConfig.aid || pn.aid}`, true, { expires: 30 });
    };
    const setToLocalStorage = (key2, value) => {
      if (consent4.id) {
        consent4.id.localStorage.set(key2, value);
      } else {
        localStorage4.set(key2, value);
      }
    };
    const getBrowserId = () => {
      var _a;
      return (_a = util2.getBrowserId()) != null ? _a : void 0;
    };
    const getStage = () => globalConfig.stage;
    const showMsqaPrompt = () => __async(void 0, null, function* () {
      if (util2.isEdge()) {
        yield msqaInitializationPromise;
        return msqa.showPrompt();
      }
    });
    const checkVerificationCode = () => {
      const verificationCode = util2.getQueryParamByName(VERIFICATION_CODE_QUERY);
      if (!verificationCode) {
        return;
      }
      const trackingId = util2.getQueryParamByName(TRACKING_ID_QUERY);
      const pianoIdConfig = __spreadValues({
        verification_code: verificationCode
      }, trackingId ? { trackingId } : {});
      if (!isUserValid()) {
        show(pianoIdConfig);
      } else {
        showEmailConfirmation(pianoIdConfig);
      }
    };
    const updateUser = (_0) => __async(void 0, [_0], function* ({
      firstName,
      lastName
    }) {
      const accessToken = tokenManager2.getToken() || void 0;
      if (!accessToken) {
        throw new Error("The user must be logged in.");
      }
      try {
        const { token: newAccessToken } = yield requestManager2.request({
          type: "PUT",
          contentType: "application/json",
          dataType: "json",
          url: `${urlManager2.getIdentifyUrl()}/userinfo/name?${jqUtils2.param({
            lang: getLang()
          })}`,
          headers: { Authorization: accessToken },
          data: JSON.stringify({
            aid: globalConfig.aid || pn.aid,
            first_name: firstName,
            last_name: lastName
          })
        });
        yield setToken({
          token: newAccessToken,
          user: jwtDecode2(newAccessToken)
        });
      } catch (e) {
        throw e;
      }
    });
    return {
      name: name3,
      isv,
      init,
      prepare,
      show,
      showForm,
      checkAndShowEmailIsNotConfirmed,
      showEmailConfirmationRequired,
      submitLoginForm,
      loginByToken,
      logout,
      getToken: tokenManager2.getToken,
      getUser,
      loadExtendedUser,
      getName,
      isConfigured,
      onLoginSuccess,
      onProfileUpdate,
      onExtendedUserLoginRequired,
      isUserValid,
      setCallbacks,
      getIframeUrl: urlManager2.getPianoIdUrl,
      updateLang,
      onLangChange,
      getLang,
      isAot,
      registerCallback,
      setRequestTimeout,
      showMsqaPrompt,
      updateUser,
      __protected__: {
        offerMessageReceiver,
        showEmailConfirmation,
        checkAndShowEmailIsNotConfirmed,
        closeModalContainer,
        executePostMessagesBatch,
        isGmSso,
        isGmSsoRedirectEnabled,
        authByGmSsoRedirect,
        extendUserToken,
        getStage,
        isSssEnabled: sss.isSssEnabled,
        getSssParams: sss.getSssParams,
        checkVerificationCode
      },
      __private__: {
        prepareConfig: (config) => configManager2.prepareConfig(config, (conf) => {
          setDefaultGmSsoConfirmationType(conf);
        }),
        setRequestTimeout,
        createIframe,
        addEventsListener,
        gmSsoActionAfterTokenVerify
      }
    };
  };
  pn.container.register("pianoId", {
    useValue: pianoId()
  });
  pn.pianoId = pn.container.resolve("pianoId");

  // ../src/lib/pianoIdLite.ts
  var pianoIdLite = (() => {
    const util2 = pn.container.resolve("util");
    const pianoId2 = pn.container.resolve("pianoId");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const isv = false;
    const name3 = "pianoIdLite";
    const eventManager = eventUtils2.createEventManager(["userChanged", "onHide", "logout"]);
    const COOKIE_NAME2 = util2.getAidSpecifiedName("__utp");
    const getName = () => {
      return "piano_id_lite";
    };
    const getToken = () => {
      return pn.externalJWT || readTokenFromCookie();
    };
    const isUserValid = () => {
      return !!getToken();
    };
    const readTokenFromCookie = () => {
      return util2.findCookieByName(COOKIE_NAME2) || null;
    };
    const onLoginSuccess = (params) => {
      util2.setAccessTokenListCookie({
        value: params.token_list,
        cookie_domain: params.cookie_domain
      }, params.user_token);
    };
    const isConfigured = () => {
      return pn.usePianoIdLiteUserProvider === true || typeof pn.usePianoIdLiteUserProvider === "string" && pn.usePianoIdLiteUserProvider === "true";
    };
    const loginByToken = (accessToken) => {
      pianoId2.loginByToken(accessToken);
    };
    const logout = (callback) => {
      util2.waitCall("refreshUserToken", function() {
        typeof callback === "function" && callback();
      });
      eventManager.fireCallbacks("logout", null, void 0, true);
    };
    const registerCallback = (callbackName, callback) => {
      eventManager.addEvent(callbackName);
      eventManager.registerCallback(callbackName, callback);
    };
    return {
      name: name3,
      isv,
      isConfigured,
      isUserValid,
      getToken,
      getName,
      onLoginSuccess,
      registerCallback,
      loginByToken,
      logout
    };
  })();
  pn.container.register("pianoIdLite", {
    useValue: pianoIdLite
  });
  pn.pianoIdLite = pn.container.resolve("pianoIdLite");

  // ../src/lib/user.ts
  var user = (container = pn.container) => {
    const api2 = container.resolve("api");
    const util2 = container.resolve("util");
    const janrain2 = container.resolve("janrain");
    const tinypassAccounts2 = container.resolve("tinypassAccounts");
    const condeUserProvider2 = container.resolve("condeUserProvider");
    const gigya2 = container.resolve("gigya");
    const pianoId2 = container.resolve("pianoId");
    const pianoIdLite2 = container.resolve("pianoIdLite");
    const eventUtils2 = container.resolve("eventUtils");
    const TAC_COOKIE_MAX_BYTE_SIZE = 4096;
    const name3 = "user";
    const eventManager = eventUtils2.createEventManager([]);
    const _addProviderHandler = (handlerName, cb) => {
      [janrain2, tinypassAccounts2, condeUserProvider2, gigya2, pianoId2, pianoIdLite2].forEach((provider) => {
        provider.registerCallback(handlerName, cb);
      });
    };
    _addProviderHandler("logout", () => {
      util2.__protected__.setVxUsersToDataLayer(null);
      dataLayer.set("userStatus", "anon");
    });
    const userRefProvider = (() => {
      var _getName = function() {
        return "publisher_user_ref";
      };
      var _getToken = function() {
        if (!pn.userRef) {
          return null;
        }
        if (pn.userRef.constructor === "".constructor) {
          return pn.userRef;
        } else if (pn.userRef.constructor === {}.constructor) {
          return "{jox}" + JSON.stringify(pn.userRef);
        } else {
          return pn.userRef;
        }
      };
      var _isUserValid = function() {
        return typeof pn.userRef !== "undefined" && pn.userRef && pn.userRef.length > 0 ? true : false;
      };
      return {
        isv: false,
        getName: function() {
          return _getName();
        },
        getToken: function() {
          return _getToken();
        },
        isUserValid: function() {
          return _isUserValid();
        },
        onLoginSuccess,
        logout: function(callback) {
          util2.setAccessTokenListCookie();
          if (callback) {
            callback();
          }
        }
      };
      function onLoginSuccess(params) {
        util2.setAccessTokenListCookie({ value: params.token_list, cookie_domain: params.cookie_domain }, params.user_token);
      }
    })();
    const getProvider = () => {
      const userProviderList = [
        janrain2,
        tinypassAccounts2,
        condeUserProvider2,
        gigya2,
        pianoId2,
        pianoIdLite2
      ];
      const configuredPP = userProviderList.find((pp) => {
        return pp.isConfigured() && !pp.isv;
      });
      if (configuredPP) {
        return configuredPP;
      } else {
        return userRefProvider;
      }
    };
    const getTacCookieSize = () => {
      const tacCookieName = "__tac";
      const tacCookieValue = util2.__protected__.getCookie(tacCookieName);
      if (tacCookieValue === void 0) {
        return 0;
      }
      const tacCookieEncodedValue = encodeURIComponent(tacCookieValue);
      const encoder = new TextEncoder();
      try {
        return encoder.encode(tacCookieEncodedValue + tacCookieName).byteLength;
      } catch (err) {
        util2.debug("couldn't encode __tac cookie", err);
        return (tacCookieEncodedValue + tacCookieName).length;
      }
    };
    const isTokenNeedsForRefresh = (userIsValid, forceRefresh) => {
      if (typeof forceRefresh !== "undefined" && forceRefresh) {
        return true;
      }
      if (userIsValid) {
        const accessExpires = util2.__protected__.getCookie("__tae");
        if (typeof accessExpires === "undefined" || !accessExpires) {
          return true;
        } else {
          const expires = new Date(parseInt(accessExpires));
          const now = new Date();
          if (now.getTime() - expires.getTime() > 24 * 60 * 60 * 1e3) {
            return true;
          }
        }
      }
      return false;
    };
    const refreshAccessToken = (forceRefresh, callback) => {
      let needsRefresh = false;
      const userIsValid = getProvider().isUserValid();
      if (getTacCookieSize() >= TAC_COOKIE_MAX_BYTE_SIZE) {
        needsRefresh = true;
        console.warn(`__tac cookie exceeds max size equals ${TAC_COOKIE_MAX_BYTE_SIZE} bytes`);
        util2.setAccessTokenListCookie(null, "", true);
      } else {
        needsRefresh = isTokenNeedsForRefresh(userIsValid, forceRefresh);
      }
      if (typeof callback === "undefined" || !callback) {
        callback = function() {
        };
      }
      if (!needsRefresh && userIsValid) {
        callback(null);
        return;
      }
      util2.waitCall("refreshUserToken", () => {
        util2.waitCall("offerCreate", () => {
          util2.waitCall("experienceExecute", () => {
            if (!getProvider().isUserValid()) {
              if (util2.__protected__.getCookie("__tac")) {
                util2.setAccessTokenListCookie(null, "", true);
              }
              if (callback) {
                callback("");
              }
              return;
            }
            util2.startCall("refreshAccessTokenList");
            var params = {
              url: util2.prepareUrlParameter(window.location.href)
            };
            api2.callApi("/access/token/list", params, (response) => {
              util2.doneCall("refreshAccessTokenList");
              if (typeof response.access_token_list === "undefined") {
                if (callback) {
                  callback(null);
                }
                return;
              }
              util2.setAccessTokenListCookie(response.access_token_list);
              if (callback) {
                callback(response.access_token_list.value);
              }
            }, void 0, void 0);
          });
        });
      });
    };
    const showLogin = (config) => {
      var providerName = getProvider().getName();
      if (providerName === "tinypass_accounts") {
        tinypassAccounts2.login(config);
      } else if (providerName === "piano_id") {
        var showConfig = config || {};
        pianoId2.show(showConfig);
      } else if (providerName === "publisher_user_ref") {
        eventManager.fireCallbacks("loginRequired", {}, void 0, true);
      }
    };
    const isUserValid = () => {
      return getProvider().isUserValid();
    };
    const isUserConfirmed = () => {
      const providerName = getProvider().getName();
      if (providerName === "piano_id") {
        return pn.pianoId.getUser().confirmed;
      }
      return true;
    };
    const logout = (callback, source) => {
      getProvider().logout(callback, source);
    };
    const providerInit = (callback) => {
      if (typeof callback === "undefined" || !callback) {
        callback = function() {
        };
      }
      var provider = getProvider();
      if (typeof provider.prepare === "function") {
        if ("prepare" in provider) {
          provider.prepare().then(callback, callback);
        }
      } else {
        callback();
      }
    };
    const registerCallback = (event, callback) => {
      eventManager.addEvent(event);
      eventManager.registerCallback(event, callback);
    };
    const getUserLang = () => {
      return util2.__protected__.getCookie("LANG") || "";
    };
    const getUserInfoParams = (config) => {
      var userToken = config.userToken;
      if (!userToken) {
        var _token = getProvider().getToken();
        userToken = _token && _token.length > 0 ? _token : "";
      }
      return {
        "user_token": userToken,
        "user_lang": getUserLang(),
        "is_preview": config.preview,
        "is_non_logged_user": config.previewNonLoggedUser
      };
    };
    return {
      name: name3,
      getProvider,
      providerInit,
      refreshAccessToken,
      showLogin,
      isUserValid,
      logout,
      registerCallback,
      getUserInfoParams,
      isUserConfirmed
    };
  };
  pn.container.register("user", {
    useValue: user()
  });
  pn.user = pn.container.resolve("user");

  // ../src/lib/viewportExit.ts
  var viewportExit = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const name3 = "viewportExit";
    const viewportExitActivated = "viewport-exit-activated";
    const viewportExitPrepared = "viewport-exit-prepared";
    let shouldTriggerHistoryStateChange = false;
    let mouseMoveCalled = false;
    let mouseX = 0;
    let mouseY = 0;
    const sides = ["top", "right", "bottom", "left"];
    let enabled = true;
    let initialized = false;
    let initializedMobile = false;
    let listeners = [];
    const noneDirection = 0;
    const codesDirection = {
      top: {
        visited: false,
        value: 1
      },
      right: {
        visited: false,
        value: 2
      },
      bottom: {
        visited: false,
        value: 4
      },
      left: {
        visited: false,
        value: 8
      }
    };
    let sumOfCodesDirection = noneDirection;
    const initialize = () => {
      if (initialized) {
        return;
      }
      initialized = true;
      sumOfCodesDirection = noneDirection;
      const mouseLeaveElement = /(?:Firefox|Safari)[\/\s](\d+\.\d+)/.test(navigator.userAgent) ? document.body : document;
      jqUtils2.on(mouseLeaveElement, "mouseleave", (event) => handleMouseLeave(event));
      jqUtils2.on(document, "mousemove", (event) => handleMouseMove(event));
    };
    function onListenUserAction(cb) {
      if (util2.isIphone() && (util2.getIphoneVersion() || 0) >= 16) {
        let actionWasDone = false;
        const onUserAction = () => {
          if (!actionWasDone) {
            actionWasDone = true;
            cb();
          }
          document.removeEventListener("touchstart", onUserAction);
          document.removeEventListener("click", onUserAction);
        };
        document.addEventListener("touchstart", onUserAction);
        document.addEventListener("click", onUserAction);
      } else {
        cb();
      }
    }
    function initializeMobile() {
      if (initializedMobile) {
        return;
      }
      initializedMobile = true;
      onListenUserAction(() => {
        window.addEventListener("popstate", function(e) {
          if (shouldTriggerHistoryStateChange && e.state && e.state.pianoViewportExitState === viewportExitActivated) {
            shouldTriggerHistoryStateChange = false;
            fire("back");
          }
        });
        var currentHistoryState = window.history.state || {};
        if (currentHistoryState && currentHistoryState.pianoViewportExitState !== viewportExitPrepared) {
          if (currentHistoryState.pianoViewportExitState !== viewportExitActivated) {
            currentHistoryState.pianoViewportExitState = viewportExitActivated;
            window.history.replaceState(currentHistoryState, document.title);
          }
          window.history.pushState({ pianoViewportExitState: viewportExitPrepared }, document.title);
        }
        shouldTriggerHistoryStateChange = true;
      });
    }
    const calculateSumBySide = (side) => {
      if (sides.indexOf(side) !== -1) {
        if (!codesDirection[side].visited) {
          codesDirection[side].visited = true;
          sumOfCodesDirection += codesDirection[side].value;
        }
      } else {
        util2.debug("viewportExit: the detect of the exit side failed");
      }
    };
    const getExitSide = (clientX, clientY) => {
      const winSize = jqUtils2.winSize();
      var windowWidth = winSize.width;
      var windowHeight = winSize.height;
      var side = "";
      if (isRight()) {
        side = "right";
      }
      if (isBottom()) {
        side = "bottom";
      }
      if (isLeft()) {
        side = "left";
      }
      if (isTop()) {
        side = "top";
      }
      function isTop() {
        return clientY <= 0;
      }
      function isRight() {
        return clientX >= windowWidth;
      }
      function isBottom() {
        return clientY >= windowHeight;
      }
      function isLeft() {
        return clientX <= 0;
      }
      return side;
    };
    const indexMin = (array) => {
      if (array.length === 0) {
        return -1;
      }
      var min = array[0];
      var minIndex = 0;
      for (var i = 1; i < array.length; i++) {
        if (array[i] < min) {
          minIndex = i;
          min = array[i];
        }
      }
      return minIndex;
    };
    const getNearestSideByLastMove = () => {
      if (!mouseMoveCalled) {
        return "";
      }
      const winSize = jqUtils2.winSize();
      var windowWidth = winSize.width;
      var windowHeight = winSize.height;
      var differenceWithSide = [mouseY, windowWidth - mouseX, windowHeight - mouseY, mouseX];
      return sides[indexMin(differenceWithSide)];
    };
    const checkWrongPoint = (e) => {
      return e.clientX === e.clientY && e.clientX < 0 && e.clientX >= -1;
    };
    const handleMouseLeave = (e) => {
      var closestSide;
      closestSide = checkWrongPoint(e) ? "" : getExitSide(e.clientX, e.clientY);
      if (!closestSide) {
        closestSide = getNearestSideByLastMove();
        if (!closestSide) {
          util2.debug("viewportExit: the detect of the exit side failed");
        }
      }
      if (closestSide) {
        calculateSumBySide(closestSide);
      }
      fire("all");
      if (closestSide === "top") {
        fire("top");
      }
    };
    const handleMouseMove = (e) => {
      mouseMoveCalled = true;
      mouseY = e.clientY;
      mouseX = e.clientX;
    };
    const fire = (type2) => {
      if (!enabled) {
        return;
      }
      var listener;
      var execute = [];
      var noExecute = [];
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i];
        if ((listener.detectExitMode === type2 || type2 === "back" && listener.detectBackButtonForMobile) && listener.consumeEventFn()) {
          execute.push(listener);
        } else {
          noExecute.push(listener);
        }
      }
      if (execute.length) {
        util2.debug("viewportExit: listeners was run fire with type: ", type2);
      }
      listeners = noExecute;
      for (var i = 0; i < execute.length; i++) {
        listener = execute[i];
        listener.callback();
      }
    };
    const addListener = (callback, options, consumeEventFn) => {
      if ((options.clientDevice === "mobile" || options.clientDevice === "tablet") && !!options.detectBackButtonForMobile) {
        initializeMobile();
      }
      initialize();
      if (typeof consumeEventFn !== "function") {
        consumeEventFn = function() {
          return true;
        };
      }
      listeners.push({
        callback,
        detectExitMode: options.detectExitMode,
        detectBackButtonForMobile: options.detectBackButtonForMobile,
        consumeEventFn
      });
    };
    const removeListeners = () => {
      listeners = [];
    };
    const isInitialized = () => {
      return initialized;
    };
    const getSumOfCodesDirection = () => {
      return sumOfCodesDirection;
    };
    const resetSumOfCodesDirectionToDefault = () => {
      sumOfCodesDirection = noneDirection;
    };
    const enable = () => {
      enabled = true;
    };
    const disable = () => {
      enabled = false;
    };
    return {
      name: name3,
      initialize,
      isInitialized,
      addListener,
      resetSumOfCodesDirectionToDefault,
      getSumOfCodesDirection,
      removeListeners,
      enable,
      disable
    };
  })();
  pn.container.register("viewportExit", {
    useValue: viewportExit
  });
  pn.viewportExit = pn.container.resolve("viewportExit");

  // ../src/lib/template.ts
  var template = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const containerUtils2 = pn.container.resolve("containerUtils");
    const user2 = pn.container.resolve("user");
    const api2 = pn.container.resolve("api");
    const util2 = pn.container.resolve("util");
    const name3 = "template";
    function createTemplateIframe(config) {
      return createTemplateIframeWithUrl(config, "/checkout/template/show");
    }
    function createCacheableTemplateIframe(config) {
      config.initContextLoadPromise = (config2, statsParams) => {
        config2.contextLoadingPromise = loadTemplateContext(config2, statsParams);
      };
      return createTemplateIframeWithUrl(config, "/checkout/template/cacheableShow");
    }
    const createTemplateIframeWithUrl = (config, endpointUrl) => {
      const url = pn.getEndpointRoot(true) + endpointUrl;
      config.iframeUrl = url;
      config.postMessageUrl = url;
      config.widget = "template";
      return pn.offer.createOfferIframe(config);
    };
    const loadTemplateContext = (config, statsParams) => {
      const templateContextParams = user2.getUserInfoParams(config);
      templateContextParams.tracking_id = config.trackingId;
      templateContextParams.templateId = config.templateId;
      templateContextParams.templateVariantId = config.templateVariantId;
      templateContextParams.aid = pn.aid;
      templateContextParams.preload = config.isPreload;
      templateContextParams.cookie_consents = JSON.stringify(util2.getCookieConsents());
      templateContextParams.previous_user_segments = util2.getUserSegmentsString();
      templateContextParams.userState = util2.getUserState();
      if (config.affiliateState) {
        templateContextParams.affiliateState = JSON.stringify(config.affiliateState);
      }
      Object.keys(statsParams).forEach((key2) => {
        templateContextParams[key2] = statsParams[key2];
      });
      return new Promise((resolve, reject) => {
        api2.callApi("/anon/template/loadTemplateContext", templateContextParams, ({
          code,
          templateContext,
          message
        }) => {
          code === 0 ? resolve(templateContext) : reject(message);
        }, void 0, void 0);
      });
    };
    const buildQueryStringFn = (iframeParams, jqUtils2) => {
      var filteredParams = {};
      var whiteListedParams = [
        "aid",
        "templateId",
        "templateVariantId",
        "previewTemplateVersion",
        "preload",
        "preview",
        "previewUncached",
        "deploymentItemId",
        "gaClientId",
        "zuoraSelectedRatePlanIds",
        "newscycleSelectedIds",
        "addNewsletterAssets",
        "offerId",
        "experienceId",
        "iframeId",
        "displayMode",
        "debug",
        "pianoIdUrl",
        "widget",
        "url"
      ];
      whiteListedParams.forEach((f2) => {
        if (iframeParams[f2]) {
          filteredParams[f2] = iframeParams[f2];
        }
      });
      return jqUtils2.param(filteredParams);
    };
    function initCacheableTemplate(config) {
      config.deferredContextLoading = true;
      config.buildQueryStringFn = buildQueryStringFn;
    }
    function setCreatingIframeFunctionToConfig(config) {
      if (pn.getCacheableShowTemplate()) {
        initCacheableTemplate(config);
        config.createIframeFn = createCacheableTemplateIframe;
      } else {
        config.createIframeFn = createTemplateIframe;
      }
    }
    const show = (config) => {
      config.offerId = containerUtils2.fakeOfferId;
      config.trackStatsOnShow = true;
      setCreatingIframeFunctionToConfig(config);
      return pn.offer.show(config);
    };
    const deferredShow = (config) => {
      config.offerId = containerUtils2.fakeOfferId;
      setCreatingIframeFunctionToConfig(config);
      return pn.offer.deferredShow(config);
    };
    const close = () => {
      containerUtils2.closeModalContainer();
    };
    const closeInline = (selector) => {
      containerUtils2.__protected__.closeInlineContainers(selector);
    };
    const showBackdrop = () => {
      containerUtils2.showBackdrop();
    };
    const hideBackdrop = () => {
      containerUtils2.hideBackdrop();
    };
    const centerBackdrop = (container) => {
      containerUtils2.centerBackdrop(container);
    };
    const registerCallback = (callbackName, callback) => {
    };
    const refreshUser = (iframeId) => {
      user2.refreshAccessToken(true, () => {
        postmessage2.send("externalLoginSuccess", {
          user_token: user2.getProvider().getToken()
        }, iframeId);
      });
    };
    return {
      name: name3,
      show,
      deferredShow,
      close,
      closeInline,
      createTemplateIframe,
      showBackdrop,
      hideBackdrop,
      centerBackdrop,
      registerCallback,
      refreshUser
    };
  })();
  pn.container.register("template", {
    useValue: template
  });
  pn.template = pn.container.resolve("template");

  // ../src/lib/offer.ts
  var offer = (container = pn.container) => {
    const jqUtils2 = container.resolve("jqUtils");
    const util2 = container.resolve("util");
    const postmessage2 = container.resolve("postmessage");
    const user2 = container.resolve("user");
    const containerUtils2 = container.resolve("containerUtils");
    const eventUtils2 = container.resolve("eventUtils");
    const viewportExit2 = container.resolve("viewportExit");
    const gaService2 = container.resolve("gaService");
    const sha12 = container.resolve("sha1");
    const logging2 = container.resolve("logging");
    const template2 = container.resolve("template");
    const analytics2 = container.resolve("analytics");
    const gaCollectingService2 = container.resolve("gaCollectingService");
    const ajax3 = container.resolve("ajax");
    const acp2 = container.resolve("acp");
    const api2 = container.resolve("api");
    const iframes = [];
    const lockedConfigs = {};
    let frameIdCount = 0;
    let closeState = "close";
    const lockTimeout = 1e4;
    const LOGIN_LOGOUT_SOURCE = "OFFER";
    let needReloadOnStartCheckout = false;
    let loginRequiredTermId;
    let loginRequiredIframeId;
    let loginRequiredAllowReturnToStartState = false;
    let isAddedUserProviderCallbacks = false;
    const customVariablesPerIframe = {};
    const iframeCounterByTemplateParamsMap = /* @__PURE__ */ new Map();
    let templateIframeParams = {};
    const RTL_LOCALES = ["he_IL", "ar_EG"];
    let trackingId = "";
    let lastGAEvent;
    let currentIframeId;
    const PROCESS_3DS_RURL = "pn_rurl_3ds";
    const visibilityCheckTiming = 1e3;
    const visibleImpressionTrackedIframes = /* @__PURE__ */ new Map();
    const HIDDEN_TERM_TYPE_PROPERTY = Symbol();
    const HIDDEN_SENDER_ID_PROPERTY = Symbol();
    const eventManager = eventUtils2.createEventManager([
      "complete",
      "cancel",
      "close",
      "error",
      "loginRequired",
      "loginSuccess",
      "loaded",
      "customEvent",
      "startCheckout",
      "resize",
      "onMeterExpired",
      "onMeterActive",
      "onAccessGranted",
      "onShowOffer",
      "pianoIdEvent",
      "parentSize",
      "redeemCredit",
      "onStartCreditRedemption",
      "showAuthForm",
      "callLinkTermSelectedCallback",
      "callLinkedTermSelectedCallback",
      "callLinkTermSelectedCallback",
      "visibleImpression",
      "selectChangeOption",
      "checkoutSelectChangeOption",
      ...acp2.getComposerAcpEvents()
    ]);
    containerUtils2.setIframesPopstateHandlers();
    const _getOfferBaseUrl = () => {
      if (pn.offerBaseUrl) {
        return pn.offerBaseUrl;
      }
      return pn.getEndpointRoot() + "/checkout/offer/show";
    };
    const _getCheckoutBaseUrl = () => {
      return pn.getEndpointRoot(true) + "/checkout/offer/show";
    };
    const needToParseLinkedTermProductIds = (externalProductIds) => {
      return !!(externalProductIds && !Array.isArray(externalProductIds));
    };
    const parseLinkedTermProductIds = (externalProductIds) => {
      if (typeof externalProductIds === "string") {
        return externalProductIds.split(",");
      }
      return [externalProductIds];
    };
    const getLinkedTermDataToPass = (data) => {
      if (!data) {
        return null;
      }
      const _a = data, { linkedTermData, linkTermSignedData, linkedTermSignedData } = _a, commonLinkedTermData = __objRest(_a, ["linkedTermData", "linkTermSignedData", "linkedTermSignedData"]);
      const linkTermSignedDataParams = linkedTermSignedData || linkTermSignedData;
      switch (true) {
        case Boolean(linkedTermData):
          return __spreadValues({
            linkedTermData
          }, commonLinkedTermData);
        case Boolean(linkTermSignedDataParams):
          return __spreadValues({
            linkTermSignedData: linkTermSignedDataParams
          }, commonLinkedTermData);
        default:
          return commonLinkedTermData;
      }
    };
    const getLinkedTermExternalTermId = (linkedTermData, dataType) => {
      if (dataType === "linkedTermData" /* COMMON */) {
        return linkedTermData.externalTermId || "";
      }
      if (dataType === "linkTermSignedData" /* SIGNED */) {
        try {
          return JSON.parse(linkedTermData.payload).externalTermId || "";
        } catch (err) {
          console.warn(err);
          return "";
        }
      }
      return "";
    };
    const createSession = (offerStatData = {}, pageViewData = {}) => {
      const url = pn.getApiEndpoint() + "/linkedTerm/session/create";
      const sessionData = __spreadValues(__spreadValues({
        tracking_id: trackingId || "",
        tbc: util2.getTbcCookie() || "",
        pcid: util2.getPcidCookie() || "",
        consents: JSON.stringify(util2.getCookieConsents()),
        previous_user_segments: util2.getUserSegmentsString(),
        user_state: util2.getUserState()
      }, offerStatData), pageViewData);
      return new Promise((resolve, reject) => {
        try {
          ajax3.request({
            url,
            type: "POST",
            dataType: "json",
            data: JSON.stringify(sessionData),
            contentType: "application/json",
            success: resolve,
            error: reject
          });
        } catch (err) {
          reject(err);
        }
      });
    };
    const hasActiveSubscriptionToLinkedTerm = (aid, externalTermId) => {
      const url = `${pn.getApiEndpoint()}/linkedTerm/subscription/hasActive`;
      const data = {
        aid,
        external_term_id: externalTermId,
        user_token: user2.getProvider().getToken()
      };
      return new Promise((resolve, reject) => {
        try {
          ajax3.request({
            url,
            type: "POST",
            dataType: "json",
            data,
            contentType: "application/x-www-form-urlencoded",
            success: resolve,
            error: reject
          });
        } catch (err) {
          reject(err);
        }
      });
    };
    const getGAEventPayload = (eventType) => {
      switch (eventType) {
        case "purge":
          return {
            eventCategory: "checkoutClose",
            eventLabel: "Checkout close"
          };
        case "customEvent":
          return {
            eventCategory: "checkoutCustomEvent",
            eventLabel: "Checkout custom event"
          };
        case "checkoutPaymentError":
        case "error":
          return {
            eventCategory: "checkoutError",
            eventLabel: "Checkout error"
          };
        case "checkoutStateChange":
          return {
            eventCategory: "checkoutStateChange",
            eventLabel: "Checkout state change"
          };
        case "showTemplate":
          return {
            eventCategory: "showTemplate",
            eventLabel: "Show template"
          };
        case "startCheckout":
          return {
            eventCategory: "startCheckout",
            eventLabel: "Start checkout",
            isModalOnly: true
          };
        case "logout":
          return {
            eventCategory: "logout",
            eventLabel: "Logout event"
          };
        case "loginRequired":
          return {
            eventCategory: "loginRequired",
            eventLabel: "Login required"
          };
        default:
          return null;
      }
    };
    const sendGAEvent = (eventType, params) => {
      const eventPayload = getGAEventPayload(eventType);
      if ((eventPayload == null ? void 0 : eventPayload.isModalOnly) && params.displayMode !== "modal") {
        return;
      }
      if (eventPayload && lastGAEvent !== eventPayload.eventCategory) {
        analytics2.ga.event({
          eventType: "emitGAEvent" /* EMIT_GA_EVENT */,
          payload: __spreadValues(__spreadValues({
            iframeId: params.sender
          }, eventPayload), params.params)
        });
        lastGAEvent = eventPayload.eventCategory;
      }
    };
    function _receive(params, evFromChildrenToParent) {
      var _a, _b, _e;
      var iframe = containerUtils2.getIframe(params.sender);
      var invokeCallbacksOnFire = true;
      if (iframe && iframe.config) {
        invokeCallbacksOnFire = !iframe.config.parent;
      }
      switch (params.event) {
        case "initContext":
          if (params.params && params.params.resultCallbackId) {
            var result = {
              resultCallbackId: params.params.resultCallbackId,
              affiliateState: iframe.config["affiliateState"]
            };
            postmessage2.send("resultCallback", result, params.sender);
          }
          break;
        case "storeCustomVariables":
          tp.saveCustomVariablesToLocalStorage(5 * 60);
          break;
        case "fullRedirectThreeDS":
          window.location.href = params.params.bankSecureUrl;
          break;
        case "resize":
          if (params.params.iframeId === params.sender) {
            let resizingOptions = params.params.width === void 0 ? __spreadProps(__spreadValues({}, params.params), { width: jqUtils2.getWidth(iframe.container) }) : params.params;
            containerUtils2.resizeIframe(iframe, resizingOptions);
            if (iframe.config.displayMode === "modal") {
              if (params.params.closeButtonType === "boilerplate") {
                containerUtils2.hideCloseButton(iframe.container);
              }
              containerUtils2.centerIt(iframe.container);
            }
            postmessage2.send("afterResize", {}, iframe.iframeId);
          }
          eventManager.fireCallbacks(params.event, params.params, params.sender, invokeCallbacksOnFire);
          iframes.forEach((displayedIframe) => {
            if (shouldCheckVisibilityOnInit(displayedIframe)) {
              checkVisibleImpression(displayedIframe.iframeId);
            }
          });
          break;
        case "startCheckout":
          params.params.width = null;
          if (params.displayMode === "inline") {
            params.params.closeOnLogout = true;
            var startCheckoutConfig = merge(params.params, iframe.statParams);
            startCheckoutConfig.browserId = iframe.browserId;
            startCheckoutConfig.isOpenedFromInlineCheckout = true;
            startCheckout(startCheckoutConfig, params.sender);
          }
          if (params.params.iframeId === params.sender) {
            eventManager.fireCallbacks(params.event, params.params, params.sender, invokeCallbacksOnFire);
            sendGAEvent(params.event, params);
          } else {
            _setTrackedIframeValue(params.params.iframeId, {
              isVisibleImpressionEventSent: true
            });
            if ((_a = visibleImpressionTrackedIframes.get(params.sender)) == null ? void 0 : _a.isVisibleImpressionEventSent) {
              removeScrollListener((_b = iframes.find((item) => item.iframeId === params.sender)) == null ? void 0 : _b.displayMode);
            }
          }
          break;
        case "showAuthForm":
          const { params: pianoIdParams = {} } = params;
          pn.pianoId.show(__spreadValues({
            closedCallback: () => {
              postmessage2.send("authFormClosed", {}, params.sender);
            }
          }, pianoIdParams));
          break;
        case "callLinkTermSelectedCallback":
        case "callLinkedTermSelectedCallback":
          if (!params.params || !tp.linkedTermSelectedCallbacks.length) {
            return;
          }
          const { params: _c } = params, _d = _c, { linkedTermData, linkTermData, offerStatData, pageViewData } = _d, restData = __objRest(_d, ["linkedTermData", "linkTermData", "offerStatData", "pageViewData"]);
          const linkedTermParams = linkedTermData || linkTermData;
          const linkedTermPassedData = getLinkedTermDataToPass(linkedTermParams) || restData;
          const dataType = linkedTermPassedData.linkedTermData ? "linkedTermData" /* COMMON */ : "linkTermSignedData" /* SIGNED */;
          const externalTermId = getLinkedTermExternalTermId(linkedTermPassedData[dataType], dataType);
          Promise.all([
            createSession(offerStatData, pageViewData),
            hasActiveSubscriptionToLinkedTerm(tp.aid, externalTermId)
          ]).then(([{ data: sessionId }, { data: userHasActiveSubscriptionToTerm }]) => {
            if (containerUtils2.hasModalIframe()) {
              containerUtils2.closeModalContainer();
            }
            tp.linkedTermSelectedCallbacks.forEach((callback) => {
              if (typeof callback === "function") {
                callback(sessionId || "", __spreadProps(__spreadValues({}, linkedTermPassedData), {
                  [dataType]: __spreadProps(__spreadValues({}, linkedTermPassedData[dataType]), {
                    userHasActiveSubscriptionToTerm
                  })
                }));
              }
            });
          }).catch(util2.debug);
          break;
        case "loaded":
          if (params.params.iframeId === params.sender) {
            postmessage2.send("setupCustomVariables", customVariablesPerIframe[params.params.iframeId], params.params.iframeId);
            postmessage2.send("setupEVTFields", iframe.config["externalVerificationFields"], params.params.iframeId);
            passCookieConsents(iframe);
            passUserSegments(iframe);
            passUserState(iframe);
            if (iframe.config.deferredContextLoading) {
              _castUserDataContextLoadedEvent(iframe, params);
            }
            if (iframe.waitFinishProcesses) {
              containerUtils2.__protected__.closeAndRemoveIframe(iframe);
              return;
            }
            if (user2.getProvider().name === "pianoId") {
              pn.pianoId.__protected__.executePostMessagesBatch();
            }
            if (iframe.config.displayMode === "modal") {
              containerUtils2.resizeIframe(iframe, params.params);
              if (!iframe.config.isPreload) {
                containerUtils2.checkBackdropAndContainer(iframe, true);
              }
            }
            if (iframe.config.displayMode === "popup") {
              containerUtils2.resizeIframe(iframe, params.params);
            }
            if (!iframe.config.isPreload && !iframe.config.trackStatsOnShow || iframe.config.forceTrackStat) {
              trackStat(iframe);
            }
            passBrowserId(iframe);
            passPcidBrowserId(iframe);
            passPageViewContext(iframe);
            eventManager.fireCallbacks(params.event, params.params, params.sender, invokeCallbacksOnFire);
            if (iframe.config.displayMode === "inline") {
              if (!iframe.containerReady) {
                containerUtils2.operationWithContainer(iframe.iframeParams.containerSelector, (container2) => {
                  const tempContainer = jqUtils2.queryEl("#temp-inline-" + iframe.iframeId);
                  if (tempContainer) {
                    container2.innerHTML = tempContainer.innerHTML;
                    jqUtils2.remove(tempContainer);
                  }
                  iframe.element = jqUtils2.queryEl("iframe", container2);
                  iframe.containerReady = true;
                  containerUtils2.resizeIframe(iframe, params.params);
                });
              } else {
                containerUtils2.resizeIframe(iframe, params.params);
              }
            }
            const { offerId, templateId, initTime, logType } = iframe.iframeParams;
            logging2.setTime(logType, Math.floor(performance.now() - initTime), { offer_id: offerId === "fakeOfferId" ? void 0 : offerId, template_id: templateId });
            _releaseConfig(iframe.config);
            util2.doneCall("offerCreate");
          }
          break;
        case "downForMaintenance":
          containerUtils2.resizeIframe(iframe, { width: 300, height: 200 });
          if (iframe.config.displayMode === "modal") {
            if (!iframe.config.isPreload) {
              containerUtils2.checkBackdropAndContainer(iframe);
            }
          }
          break;
        case "removeQueryParamByName":
          if (params && params.params && Array.isArray(params.params.paramsToRemove)) {
            params.params.paramsToRemove.forEach((name4) => {
              util2.removeQueryParamByName(name4);
            });
          }
          break;
        case "purge":
          if (!evFromChildrenToParent) {
            if (params && params.params && params.params.alreadyPurchased) {
              closeState = "alreadyHasAccess";
            }
            if (params && params.params && params.params.completePayment) {
              closeState = "checkoutCompleted";
            }
            if (shouldRemoveScrollListener()) {
              removeScrollListener(iframe == null ? void 0 : iframe.config.displayMode);
            }
            containerUtils2.purgeIframe(params.sender, iframe.config.parent);
            acp2.handleAcpEvent(eventManager.fireCallbacks, params, iframe.config, invokeCallbacksOnFire);
            _releaseConfig(iframe.config);
            sendGAEvent(params.event, params);
          }
          break;
        case "close":
          if (!evFromChildrenToParent) {
            if (params && params.params && params.params.alreadyPurchased) {
              closeState = "alreadyHasAccess";
            }
            if (params && params.params && params.params.completePayment) {
              closeState = "checkoutCompleted";
            }
            if (util2.hasQueryParamByName("voucher_code")) {
              closeState = "voucherRedemptionCompleted";
            }
            containerUtils2.closeContainer(params.sender, iframe.config.parent);
            _releaseConfig(iframe.config);
          }
          break;
        case "closeAndRefresh":
          var url = params.params;
          if (url) {
            window.location.assign(url);
          } else {
            window.location.reload();
          }
          break;
        case "selectTerm":
        case "selectChangeOption":
          if (params && params.params && params.params.alreadyPurchased) {
            closeState = "alreadyHasAccess";
          } else {
            closeState = "close";
          }
          break;
        case "submitPayment":
          eventManager.fireCallbacks(params.event, merge(params.params, { offerId: iframe.iframeParams.offerId }), params.sender, invokeCallbacksOnFire);
          break;
        case "complete":
          if (typeof params.params.token_list !== "undefined") {
            const userToken = user2.getProvider().getToken();
            util2.setAccessTokenListCookie({ value: params.params.token_list, cookie_domain: params.params.cookie_domain }, userToken);
          }
          var callbackParams = merge(params.params, { offerId: iframe.iframeParams.offerId });
          eventManager.fireCallbacks(params.event, callbackParams, params.sender, invokeCallbacksOnFire);
          closeState = "checkoutCompleted";
          break;
        case "checkoutSelectTerm":
        case "checkoutSelectChangeOption":
          eventManager.fireCallbacks(params.event, merge(params.params, { offerId: iframe.iframeParams.offerId }), params.sender, invokeCallbacksOnFire);
          break;
        case "checkoutStateChange":
          _setTrackedIframeValue(iframe.iframeId, { previousState: (_e = visibleImpressionTrackedIframes.get(iframe.iframeId)) == null ? void 0 : _e.currentState });
          _setTrackedIframeValue(iframe.iframeId, { currentState: params.params.stateName });
          eventManager.fireCallbacks(params.event, params.params, params.sender, invokeCallbacksOnFire);
          sendGAEvent(params.event, params);
          break;
        case "checkoutPaymentError":
        case "alreadyPurchased":
        case "startThreeDBankSecure":
        case "cancel":
        case "error":
        case "completeUpgradePurchase":
          eventManager.fireCallbacks(params.event, params.params, params.sender, invokeCallbacksOnFire);
          sendGAEvent(params.event, params);
          break;
        case "customEvent":
          acp2.handleAcpEvent(eventManager.fireCallbacks, params, iframe.config, invokeCallbacksOnFire);
          sendGAEvent(params.event, params);
          break;
        case "loginRequired":
          needReloadOnStartCheckout = true;
          eventManager.fireCallbacks(params.event, mergeLoginRequiredParamsWithConfig(iframe, params.params, params.sender), params.sender, invokeCallbacksOnFire);
          sendGAEvent(params.event, params);
          break;
        case "logout":
          _logout(params.event, params.params, params.sender, iframe.config.parent, invokeCallbacksOnFire);
          sendGAEvent(params.event, params);
          break;
        case "loginSuccess":
          _loginSuccess(params.event, params.params, params.sender, invokeCallbacksOnFire);
          break;
        case "inputFocus":
          const tpModalEl = jqUtils2.queryEl(".tp-modal");
          if (tpModalEl) {
            tpModalEl.style.zIndex = pn.zIndexes.modal + 1 + "";
            tpModalEl.style.zIndex = pn.zIndexes.modal + "";
          }
          break;
        case "inputBlur":
          const tpModalElBlur = jqUtils2.queryEl(".tp-modal");
          if (tpModalElBlur) {
            tpModalElBlur.style.zIndex = pn.zIndexes.modal + 1 + "";
            tpModalElBlur.style.zIndex = pn.zIndexes.modal + "";
          }
          break;
        case "getLocation":
          if (params.params && params.params.resultCallbackId) {
            params.params.result = window.location.href;
            postmessage2.send("resultCallback", params.params, params.sender);
          }
          break;
        case "setLocationHash":
          if (params.params && params.params.hash) {
            window.location.hash = params.params.hash;
          }
          break;
        case "langChangedWithinOffer":
          if (pn.pianoId.isConfigured()) {
            pn.pianoId.updateLang(params.params.lang);
          }
          if (RTL_LOCALES.indexOf(params.params.lang) >= 0) {
            containerUtils2.turnOnRTL(iframe);
          } else {
            containerUtils2.turnOffRTL(iframe);
          }
          break;
        case "loginStart":
          viewportExit2.disable();
          break;
        case "loginEnd":
          viewportExit2.enable();
          break;
        case "pianoIdEvent":
          if (params.params.iframeId === params.sender) {
            if (params.params.event === "closed") {
              containerUtils2.closeContainer(params.sender);
            }
            pn.pianoId.__protected__.offerMessageReceiver(params);
          }
          _handleSuccessDOI(params.params, params.sender);
          break;
        case "swgCheckoutStart":
          break;
        case "sharedAccountsSuccessfullyAdded":
          postmessage2.broadcast("refreshMyAccount", { userToken: user2.getProvider().getToken() });
          break;
        case "newsletterSignupImpression":
        case "newsletterSignupSubmission":
          pn.pianoEsp.__protected__.offerMessageReceiver(params);
          eventManager.fireCallbacks(params.event, params.params, params.sender, invokeCallbacksOnFire);
          break;
        case "parentSize":
          const winSize = jqUtils2.winSize();
          var sizes = {
            width: winSize.width,
            height: winSize.height
          };
          postmessage2.send("parentSize", sizes, params.sender);
          break;
        case "gigyaPasswordlessLogin":
          if (params.params.iframeId === params.sender) {
            loginRequiredIframeId = params.params.iframeId;
            pn.gigya.loginByPasswordless(params.params);
          }
          break;
        case "emitGAEvent" /* EMIT_GA_EVENT */:
          !evFromChildrenToParent && analytics2.ga.event({
            eventType: "emitGAEvent" /* EMIT_GA_EVENT */,
            payload: __spreadValues({
              iframeId: params.sender
            }, params.params)
          });
          return;
        case "emitMetricsEvent" /* EMIT_METRICS_EVENT */:
          !evFromChildrenToParent && analytics2.ga.event({
            eventType: "emitMetricsEvent" /* EMIT_METRICS_EVENT */,
            payload: params.params
          });
          break;
        case "bannerInit":
          iframe.config.singleContainer.classList.add("tp-banner");
          break;
        case "bannerDestroy":
          iframe.config.singleContainer.classList.remove("tp-banner");
          break;
        case "redeemCredit":
          let res = eventManager.fireCallbacks("onStartCreditRedemption", params.params, params.sender, invokeCallbacksOnFire);
          if (res && res.then) {
            res.then(function(p) {
              postmessage2.send("successfullyCreditRedeem", p, params.sender);
            }, function(p) {
              postmessage2.send("creditRedeemFailed", p, params.sender);
            });
          }
          break;
        case "scrollModalTo":
          if (params.displayMode === "modal") {
            var tpModalContainer = jqUtils2.queryEl(".tp-modal");
            if (tpModalContainer) {
              var x = params.params.x || 0;
              var y = params.params.y || 0;
              tpModalContainer.scrollTo(x, y);
            }
          }
          break;
        case "frequencyEvent":
          var payload = {
            event_name: "piano_frequency_event",
            event_type: params.params.eventType === "closeClick" ? "close_click" : "visible_impression",
            experience_Id: params.params.experienceId,
            experience_action_Id: params.params.experienceActionId
          };
          if (params.params.eventType !== "closeClick" && !isVisibleImpressionEventSent(iframe.iframeId) || params.params.eventType === "closeClick") {
            eventManager.fireCallbacks("piano_frequency_event", payload, params.sender, invokeCallbacksOnFire);
          }
        default:
          util2.debug("Received invalid event type: " + params.event);
          return;
      }
    }
    ;
    const _setTrackedIframeValue = (key2, value) => {
      visibleImpressionTrackedIframes.set(key2, __spreadValues(__spreadValues({}, visibleImpressionTrackedIframes.get(key2)), value));
    };
    const _handleSuccessDOI = (params, sender) => {
      if (params.event !== "successDOI") {
        return;
      }
      if (params.iframeId !== sender) {
        containerUtils2.closeContainer(params.iframeId);
      }
      postmessage2.send("afterSuccessDOI", params.params, sender);
    };
    const _castUserDataContextLoadedEvent = (iframe, params) => {
      iframe.config.contextLoadingPromise.then((userContext) => {
        const userDataContext = {
          iframeParams: iframe.iframeParams,
          userContext
        };
        userDataContext.iframeParams.url = util2.prepareUrlParameter(window.location.href);
        postmessage2.send("userDataContextLoaded", userDataContext, params.params.iframeId);
      });
    };
    const _logout = (event, params, sender, parent2, invokeCallbacksOnFire) => {
      user2.logout(() => {
        var _a, _b;
        var config = {};
        const offerType = (_b = (_a = iframes.find((iframe) => iframe.iframeId === sender)) == null ? void 0 : _a.config) == null ? void 0 : _b.offerType;
        if (isUpgradeOffer(offerType)) {
          containerUtils2.closeContainer(sender, parent2);
          return;
        }
        config.userProvider = user2.getProvider().getName();
        config.userToken = user2.getProvider().getToken() && user2.getProvider().getToken().length > 0 ? user2.getProvider().getToken() : "";
        config.noNeedStartCheckout = true;
        _reloadAll(config);
      }, LOGIN_LOGOUT_SOURCE);
      if (params.closeOnLogout) {
        containerUtils2.closeModalContainer(sender, parent2);
      }
    };
    const _loginSuccess = (event, params, sender, invokeCallbacksOnFire) => {
      params.source = LOGIN_LOGOUT_SOURCE;
      user2.getProvider().onLoginSuccess(params);
      eventManager.fireCallbacks("loginSuccess", params, sender, invokeCallbacksOnFire);
      if (!isAddedUserProviderCallbacks) {
        var altConfig = {
          userToken: params.user_token,
          user: params.user,
          reloadAfterLogin: true
        };
        _reloadAll(altConfig, sender);
      }
    };
    const _getTpConfigurationParameters = (iframeParams) => {
      var propsToCopy = [
        "debug",
        "aid",
        "gaClientId",
        "tags",
        "contentSection",
        "contentAuthor",
        "debug",
        "zone"
      ];
      propsToCopy.forEach((value) => {
        if (pn[value]) {
          iframeParams[value] = pn[value];
        }
      });
      if (pn.customVariables) {
        customVariablesPerIframe[iframeParams.iframeId] = JSON.stringify(pn.customVariables);
        iframeParams.customVariables = customVariablesPerIframe[iframeParams.iframeId];
      }
      var contentCreated = pn.contentCreated;
      if (contentCreated) {
        iframeParams.contentCreated = contentCreated;
      }
      if (pn && pn.main) {
        iframeParams["visitId"] = pn.main.fetchVisitId();
      }
      if (pn && pn.util) {
        const { pageTitle, pageViewId: pageViewId2 } = pn.util.getPageViewContext();
        iframeParams["browserId"] = pn.util.getBrowserId();
        iframeParams["pageViewId"] = pageViewId2;
        iframeParams["pageTitle"] = pageTitle;
        iframeParams["userState"] = pn.util.getUserState();
      }
      return iframeParams;
    };
    const _getConfigurationParameters = (c) => {
      var iframeParams = {};
      if (c.termIds) {
        if (!(c.termIds instanceof Array))
          c.termIds = [c.termIds];
      }
      var genericProperties = [
        "displayMode",
        "containerSelector",
        "templateId",
        "templateVariantId",
        "offerId",
        "termId",
        "termIds",
        "rid",
        "aid",
        "isCheckout",
        "isOpenedFromInlineCheckout",
        "pw_id",
        "paywallId",
        "width",
        "preview",
        "previewUncached",
        "previewTemplateType",
        "previewTemplateVersion",
        "tokenType",
        "janrainCaptureToken",
        "closeOnLogout",
        "voucherCode",
        "isRedemption",
        "allowReturnToStartState",
        "startFromInlineCheckout",
        "formNameByTermId",
        "hideCompletedFields",
        "startFromInlineCheckout",
        "reloadAfterLogin",
        "preventReloadAfterLogin",
        "isAuth",
        "authStartScreen",
        "showCloseButton",
        "closeButtonType",
        "checkoutFlowId",
        "offerState",
        "oid",
        "promoCode",
        "promoCodeId",
        "promoCodeTermId",
        "rurl_3ds",
        "thirdPartyParams",
        "termId3ds",
        "providerId",
        "deploymentItemId",
        "sharedAccountCode",
        "targetedTermId",
        "widget",
        "linkTermCheckoutState",
        "linkedTermCheckoutState",
        "purchasedLinkTermData",
        "purchasedLinkedTermData",
        "subscriptionId",
        "experienceActionId",
        "continuation",
        "offerType",
        "termChangeOptionId"
      ];
      var composerProperties = [
        "trackingId",
        "experienceId",
        "experienceActionId",
        "activeMeters",
        "directCheckout"
      ];
      var additionalParamNames = c.additionalParamNames ? c.additionalParamNames : [];
      var propsToCopy = genericProperties.concat(composerProperties, additionalParamNames);
      propsToCopy.forEach((value) => {
        if (c[value]) {
          iframeParams[value] = c[value];
        }
        if (value === "showCloseButton") {
          if (c[value] === void 0) {
            iframeParams[value] = true;
          } else {
            iframeParams[value] = c[value];
          }
        }
      });
      var trackingId2 = decodeURIComponent(util2.getQueryParamByName("_ptid"));
      if (trackingId2) {
        iframeParams.trackingId = trackingId2;
        setTrackingIdToGa(trackingId2);
      }
      if (c.preview) {
        iframeParams.activeMeters = JSON.stringify([{
          meterName: "preview-meter",
          views: 10,
          viewsLeft: 5,
          maxViews: 20,
          totalViews: 20
        }]);
      }
      return iframeParams;
    };
    const _compactConfig = (config) => {
      var displayMode = config.displayMode || "modal";
      return [config.offerId, displayMode, config.containerSelector].join("|");
    };
    const _isLockedConfig = (config) => {
      var jsonConfig = _compactConfig(config);
      return !!lockedConfigs[jsonConfig];
    };
    const _lockConfig = (config) => {
      var jsonConfig = _compactConfig(config);
      lockedConfigs[jsonConfig] = true;
    };
    const _releaseConfig = (config) => {
      var jsonConfig = _compactConfig(config);
      delete lockedConfigs[jsonConfig];
    };
    const createOfferIframe = (c) => {
      closeState = "close";
      readConfigParamsFromHostUrl(c);
      if (typeof c.displayMode === "undefined") {
        c.displayMode = "modal";
      } else if (c.displayMode !== "modal" && c.displayMode !== "inline" && c.displayMode !== "popup") {
        util2.log("Invalid offer displayMode; must be one of: modal, inline, popup");
        _releaseConfig(c);
        return;
      }
      if (c.displayMode === "modal" && !c.isPreload && containerUtils2.hasModalIframe()) {
        util2.log("Modal offer is already shown; must be one modal offer per time");
        _releaseConfig(c);
        return;
      }
      if (c.displayMode !== "modal") {
        const containers = jqUtils2.qa(c.containerSelector);
        if (!c.isPreload) {
          let iframe;
          containers.forEach((el) => {
            const _c = merge({}, c);
            _c.singleContainer = el;
            iframe = _createIframe(_c);
          });
          if (iframe) {
            return iframe;
          }
        }
        const singleContainer = containers[containers.length - 1];
        if (singleContainer) {
          c.singleContainer = singleContainer;
        }
      }
      return _createIframe(c);
    };
    function prepareStatsParams(config, params) {
      const { pageTitle, url, referrerUrl, contentType } = util2.getPageViewContext();
      params.pageTitle = pageTitle;
      params.url = url;
      params.referrerUrl = referrerUrl;
      params.contentType = contentType;
    }
    function _createIframe(config, containerWrapper) {
      var iframeParams = _getConfigurationParameters(config);
      const initTime = performance.now();
      if (!iframeParams.widget) {
        iframeParams.widget = "offer";
      }
      var tbc = util2.getTbcCookie();
      if (tbc && tbc.length > 0) {
        iframeParams["tbc"] = tbc;
      }
      if (config.deferredContextLoading) {
        iframeParams.iframeId = generateIframeIdFn(config);
        iframeParams.url = window.location.origin;
      } else {
        iframeParams.iframeId = "offer-" + frameIdCount++ + "-" + util2.randomString();
        iframeParams.url = util2.prepareUrlParameter(window.location.href);
      }
      const winSize = jqUtils2.winSize();
      iframeParams.parentDualScreenLeft = window.screenLeft !== void 0 ? window.screenLeft : screen.left;
      iframeParams.parentDualScreenTop = window.screenTop !== void 0 ? window.screenTop : screen.top;
      iframeParams.parentWidth = winSize.width ? winSize.width : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;
      iframeParams.parentHeight = winSize.height ? winSize.height : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;
      iframeParams.parentOuterHeight = window.outerHeight;
      if (config.previewNonLoggedUser) {
        iframeParams.previewNonLoggedUser = config.previewNonLoggedUser;
      }
      if (config.isPreload) {
        iframeParams.preload = 1;
      }
      if (pn.locale) {
        iframeParams.lang = pn.locale;
      }
      if (!!gaService2.getClientId()) {
        iframeParams.gaClientId = gaService2.getClientId();
      }
      if (!!gaService2.getGAAccount()) {
        iframeParams.gaAccount = gaService2.getGAAccount();
      }
      _getTpConfigurationParameters(iframeParams);
      var hasLoginRequiredCallback = eventManager.hasCallback("loginRequired");
      if (pn.janrain.isConfigured() && (typeof config.loginRequired === "undefined" || !config.loginRequired)) {
        var hiddenIframes = [];
        pn.janrain.addEventHandler("onModalClose", () => {
          containerUtils2.activateContainers(hiddenIframes);
        });
        setUpJanrainCallbacks();
        config.loginRequired = (params) => {
          hiddenIframes = containerUtils2.hideModalContainer();
          loginRequiredAllowReturnToStartState = params.allowReturnToStartState;
          needReloadOnStartCheckout = false;
          loginRequiredTermId = params.termId;
          loginRequiredIframeId = iframeParams.iframeId;
          util2.waitCall("refreshUserToken", () => {
            pn.janrain.login(void 0, params);
          });
          return false;
        };
      } else if (pn.gigya.isConfigured() && (typeof config.loginRequired === "undefined" || !config.loginRequired)) {
        var hiddenIframes = [];
        pn.gigya.registerCallback("onHide", (params) => {
          if (params && params.afterLogin) {
            containerUtils2.activateContainers(hiddenIframes);
          } else {
            pn.offer.close();
          }
          postmessage2.send("gigyaHide", params, loginRequiredIframeId);
        });
        setUpGigyaCallbacks();
        config.loginRequired = (params) => {
          loginRequiredAllowReturnToStartState = params.allowReturnToStartState;
          needReloadOnStartCheckout = false;
          hiddenIframes = containerUtils2.hideModalContainer();
          loginRequiredTermId = params.termId;
          loginRequiredIframeId = iframeParams.iframeId;
          util2.waitCall("refreshUserToken", () => {
            pn.gigya.login();
          });
          return false;
        };
      } else if (pn.pianoId.isConfigured()) {
        if (typeof config.loginRequired === "undefined" || !config.loginRequired) {
          config.loginRequired = (params) => {
            if (params.preventExternalLogin) {
              return;
            }
            loginRequiredTermId = params.termId;
            loginRequiredIframeId = iframeParams.iframeId;
            pn.pianoId.show({ screen: params.startScreen });
            return false;
          };
        }
        setUpPianoIdCallbacks();
        iframeParams.pianoIdUrl = pn.pianoId.getIframeUrl();
        iframeParams.pianoIdStage = pn.pianoId.__protected__.getStage();
        if (config.isGmSso) {
          iframeParams.isGmSso = config.isGmSso;
        }
        if (pn.staticDomain) {
          iframeParams.staticDomain = pn.staticDomain;
        }
        var lang = pn.pianoId.getLang();
        if (lang) {
          iframeParams.lang = lang;
        }
        pn.pianoId.onLangChange((lang2) => {
          postmessage2.send("langChanged", { lang: lang2 }, iframeParams.iframeId);
        }, iframeParams.iframeId);
      } else if (pn.pianoIdLite.isConfigured()) {
        iframeParams.pianoIdUrl = pn.pianoId.getIframeUrl();
      }
      iframeParams.userProvider = user2.getProvider().getName();
      if (config.userToken) {
        iframeParams.userToken = config.userToken;
      } else {
        iframeParams.userToken = user2.getProvider().getToken() && user2.getProvider().getToken().length > 0 ? user2.getProvider().getToken() : "";
      }
      util2.getCampaigns(iframeParams);
      iframeParams.customCookies = JSON.stringify(util2.getCustomCookies());
      eventManager.registerCallback(config, iframeParams.iframeId);
      iframeParams.hasLoginRequiredCallback = eventManager.hasIframeCallback("loginRequired", iframeParams.iframeId) || hasLoginRequiredCallback;
      iframeParams.initMode = "context";
      setIframeParamsFromQueryParams(iframeParams);
      var iframeUrl = config.iframeUrl ? config.iframeUrl : iframeParams.isCheckout ? _getCheckoutBaseUrl() : _getOfferBaseUrl();
      var postMessageUrl = config.postMessageUrl ? config.postMessageUrl : _getOfferBaseUrl();
      if (config.deferredContextLoading) {
        var statParams_ = getStatsParams(iframeParams);
        prepareStatsParams(config, statParams_);
        config.initContextLoadPromise(config, statParams_);
      }
      var statParams = extractStatParams(iframeParams, config);
      if (pn.pianoId.__protected__.isSssEnabled()) {
        const sssParams = pn.pianoId.__protected__.getSssParams();
        iframeParams.sss_mode = sssParams.sss_mode;
        iframeParams.sss_callback_url = sssParams.sss_callback_url;
        iframeParams.sss_origin_url = sssParams.sss_origin_url;
      }
      if (config.splitTestIds) {
        iframeParams.abTestIds = config.splitTestIds;
      }
      if (config.socialName) {
        iframeParams.socialName = config.socialName;
      }
      if (config.responseType) {
        iframeParams.responseType = config.responseType;
      }
      iframeParams.requestUserAuthForLinkedTerm = tp.requestUserAuthForLinkedTerm;
      iframeParams.initTime = initTime;
      const logType = iframeUrl.indexOf("/offer/") >= 0 ? "offerShow" : "templateShow";
      iframeParams.logType = logType;
      var iframe = containerUtils2.createContainer({
        url: iframeUrl,
        config,
        parent: config.parent,
        postMessageUrl,
        receive: _receive,
        iframeParams,
        singleContainer: config.singleContainer,
        close: () => {
          eventManager.fireCallbacks("close", { state: closeState }, iframeParams.iframeId, true);
        }
      });
      templateIframeParams = iframeUrl.indexOf("/template/") >= 0 && iframeParams.offerId === containerUtils2.fakeOfferId ? iframeParams : templateIframeParams;
      setGaParams(iframeParams, "offerId", "width", "termId", "displayMode", "experienceId", "iframeId", "templateId", "templateVariantId");
      iframe.statParams = statParams;
      iframe.browserId = config.browserId;
      iframes.push(iframe);
      return iframe;
    }
    const checkVisibleImpression = (iframeId) => {
      var _a;
      if (isVisibleImpressionEventSent(iframeId)) {
        return;
      }
      if (document.getElementById(iframeId) && !((_a = visibleImpressionTrackedIframes.get(iframeId)) == null ? void 0 : _a.initiatedFirstCheckVisibleImpression)) {
        _setTrackedIframeValue(iframeId, { initiatedFirstCheckVisibleImpression: true });
        calculateIframeVisibility(iframeId);
      }
      const iframe = iframes.find((iframe2) => iframe2.iframeId === iframeId);
      if ((iframe == null ? void 0 : iframe.config.displayMode) === "modal") {
        modalScrollListener(iframeId);
      } else {
        inlineScrollListener(iframeId);
      }
    };
    const inlineScrollListener = (iframeId) => {
      currentIframeId = iframeId;
      document.addEventListener("scroll", scrollListenerCallback);
    };
    const scrollListenerCallback = () => {
      var _a;
      if (shouldRemoveScrollListener()) {
        document.removeEventListener("scroll", scrollListenerCallback);
        return;
      }
      (_a = iframes.filter((iframe) => iframe.iframeParams.displayMode === "inline")) == null ? void 0 : _a.forEach((iframe) => {
        calculateIframeVisibility(iframe.iframeId);
      });
    };
    const modalScrollListener = (iframeId) => {
      var _a;
      currentIframeId = iframeId;
      (_a = document.getElementsByClassName("tp-modal")[0]) == null ? void 0 : _a.addEventListener("scroll", modalScrollListenerCallback);
    };
    const modalScrollListenerCallback = () => {
      var _a, _b;
      if (shouldRemoveScrollListener()) {
        (_a = document.getElementsByClassName("tp-modal")[0]) == null ? void 0 : _a.removeEventListener("scroll", modalScrollListenerCallback);
        return;
      }
      (_b = iframes.filter((iframe) => iframe.iframeParams.displayMode !== "inline")) == null ? void 0 : _b.forEach((iframe) => {
        calculateIframeVisibility(iframe.iframeId);
      });
    };
    const removeScrollListener = (displayMode) => {
      var _a;
      if (displayMode === "modal") {
        (_a = document.getElementsByClassName("tp-modal")[0]) == null ? void 0 : _a.removeEventListener("scroll", modalScrollListenerCallback);
      } else {
        document.removeEventListener("scroll", scrollListenerCallback);
      }
    };
    const shouldRemoveScrollListener = () => {
      return iframes.every((item) => {
        var _a;
        return !!((_a = visibleImpressionTrackedIframes.get(item.iframeId)) == null ? void 0 : _a.isVisibleImpressionEventSent);
      });
    };
    const calculateIframeVisibility = (iframeId) => {
      const calculateParams = getCalculateParams(iframeId);
      if (isVisibleImpressionReached(calculateParams)) {
        checkPositionAndSendEvent(calculateParams, iframeId);
      }
    };
    const getCalculateParams = (iframeId) => {
      var _a, _b, _c;
      const iframeBoundingClientRect = (_a = document.getElementById(iframeId)) == null ? void 0 : _a.getBoundingClientRect();
      return {
        top: (iframeBoundingClientRect == null ? void 0 : iframeBoundingClientRect.top) || 0,
        bottom: (iframeBoundingClientRect == null ? void 0 : iframeBoundingClientRect.bottom) || 0,
        left: (iframeBoundingClientRect == null ? void 0 : iframeBoundingClientRect.left) || 0,
        right: (iframeBoundingClientRect == null ? void 0 : iframeBoundingClientRect.right) || 0,
        iframeHeight: (iframeBoundingClientRect == null ? void 0 : iframeBoundingClientRect.height) || 0,
        iframeWidth: (iframeBoundingClientRect == null ? void 0 : iframeBoundingClientRect.width) || 0,
        viewportHeight: ((_b = window.visualViewport) == null ? void 0 : _b.height) || 0,
        viewportWidth: ((_c = window.visualViewport) == null ? void 0 : _c.width) || 0
      };
    };
    const checkPositionAndSendEvent = (calculateParams, iframeId) => {
      setTimeout(function() {
        if (isVisibleImpressionReached(calculateParams)) {
          fireVisibleImpressionCallbacks(iframeId);
        }
      }, visibilityCheckTiming);
    };
    const isVisibleImpressionReached = (calculateParams) => {
      if (calculateParams.iframeHeight === 0 || calculateParams.iframeWidth === 0) {
        return false;
      }
      if (calculateParams.iframeHeight > calculateParams.viewportHeight) {
        return isVisibleImpressionReachedForHighIframe(calculateParams);
      } else {
        return isVisibleImpressionReachedForShortIframe(calculateParams);
      }
    };
    const isVisibleImpressionReachedForHighIframe = (calculateParams) => {
      if (calculateParams.viewportWidth > calculateParams.iframeWidth) {
        return calculateParams.top < 0 && Math.abs(calculateParams.top) >= calculateParams.iframeHeight / 2 - calculateParams.viewportHeight && Math.abs(calculateParams.top) <= calculateParams.iframeHeight / 2 && (calculateParams.left >= 0 && calculateParams.left <= calculateParams.viewportWidth - calculateParams.iframeWidth / 2 || calculateParams.left < 0 && calculateParams.right >= calculateParams.iframeWidth / 2);
      } else {
        return calculateParams.top < 0 && Math.abs(calculateParams.top) >= calculateParams.iframeHeight / 2 - calculateParams.viewportHeight && Math.abs(calculateParams.top) <= calculateParams.iframeHeight / 2 && (calculateParams.left <= 0 && Math.abs(calculateParams.left) >= calculateParams.iframeWidth / 2 - calculateParams.viewportWidth && Math.abs(calculateParams.left) <= calculateParams.iframeWidth / 2);
      }
    };
    const isVisibleImpressionReachedForShortIframe = (calculateParams) => {
      if (calculateParams.viewportWidth > calculateParams.iframeWidth) {
        return (calculateParams.top >= 0 && calculateParams.top <= calculateParams.viewportHeight - calculateParams.iframeHeight / 2 || calculateParams.top < 0 && calculateParams.bottom >= calculateParams.iframeHeight / 2) && (calculateParams.left >= 0 && calculateParams.left <= calculateParams.viewportWidth - calculateParams.iframeWidth / 2 || calculateParams.left < 0 && calculateParams.right >= calculateParams.iframeWidth / 2);
      } else {
        return (calculateParams.top >= 0 && calculateParams.top <= calculateParams.viewportHeight - calculateParams.iframeHeight / 2 || calculateParams.top < 0 && calculateParams.bottom >= calculateParams.iframeHeight / 2) && (calculateParams.left <= 0 && Math.abs(calculateParams.left) >= calculateParams.iframeWidth / 2 - calculateParams.viewportWidth && Math.abs(calculateParams.left) <= calculateParams.iframeWidth / 2);
      }
    };
    const fireVisibleImpressionCallbacks = (iframeId) => {
      var _a, _b;
      const iframe = iframes.find((iframe2) => iframe2.iframeId === iframeId);
      var payload = {
        event_name: "piano_frequency_event",
        event_type: "visible_impression",
        experience_Id: (_a = iframe == null ? void 0 : iframe.iframeParams) == null ? void 0 : _a.experienceId,
        experience_action_Id: (_b = iframe == null ? void 0 : iframe.iframeParams) == null ? void 0 : _b.experienceActionId
      };
      if (iframe && !isVisibleImpressionEventSent(iframeId) && document.getElementById(iframeId)) {
        eventManager.fireCallbacks("piano_frequency_event", payload, iframeId, true);
        _setTrackedIframeValue(iframeId, { isVisibleImpressionEventSent: true });
      }
    };
    const isVisibleImpressionEventSent = (id) => {
      var _a;
      return !!((_a = visibleImpressionTrackedIframes.get(id)) == null ? void 0 : _a.isVisibleImpressionEventSent);
    };
    const setGaParams = (iframeParams, ...paramNames) => {
      const params = paramNames.reduce((paramMap, paramName) => __spreadProps(__spreadValues({}, paramMap), {
        [paramName]: iframeParams[paramName]
      }), {});
      gaCollectingService2.setParamMap(params);
    };
    const setTrackingIdToGa = (id) => {
      gaCollectingService2.setParam("trackingId", id);
    };
    const generateIframeIdFn = (config) => {
      var counter = 0;
      var hash = "offer_" + sha12.hash(config.iframeUrl + "?" + config.buildQueryStringFn(config, jqUtils2), 20);
      if (iframeCounterByTemplateParamsMap.has(hash)) {
        counter = iframeCounterByTemplateParamsMap.get(hash) + 1;
      }
      iframeCounterByTemplateParamsMap.set(hash, counter);
      return hash + "-" + counter;
    };
    const setIframeParamsFromQueryParams = (iframeParams) => {
      var termId = util2.getQueryParamByName("termId");
      var paySource = util2.getQueryParamByName("paySource");
      if (termId) {
        iframeParams.termId = termId;
      }
      if (paySource) {
        iframeParams.paySource = paySource;
      }
    };
    const getStatsParams = (iframeParams) => {
      var result = {};
      var statsParams = [
        "tbc",
        "trackingId",
        "pageViewId",
        "visitId",
        "tags",
        "contentCreated",
        "contentSection",
        "contentAuthor",
        "pageTitle",
        "referrerUrl"
      ];
      statsParams.forEach((value) => {
        if (iframeParams[value]) {
          result[value] = iframeParams[value];
        }
      });
      Object.keys(iframeParams).forEach((key2) => {
        if (key2.indexOf("tpcc_") === 0) {
          result[key2] = iframeParams[key2];
        }
      });
      return result;
    };
    const extractStatParams = (iframeParams, config) => {
      var result = {};
      if (config.trackStatsOnShow || config.deferredContextLoading) {
        return result;
      }
      result = getStatsParams(iframeParams);
      Object.keys(result).forEach((key2) => {
        delete iframeParams[key2];
      });
      return result;
    };
    const trackStat = (iframe) => {
      let params = merge(iframe.iframeParams, iframe.statParams);
      if (iframe.config.affiliateState) {
        params.affiliateState = iframe.config.affiliateState;
      }
      prepareStatsParams(iframe.config, params);
      postmessage2.send("trackStat", params, iframe.iframeId);
    };
    const passBrowserId = (iframe) => {
      var params = {
        browserId: iframe.browserId
      };
      postmessage2.send("passBrowserId", params, iframe.iframeId);
    };
    const passPcidBrowserId = (iframe) => {
      postmessage2.send("passPcidBrowserId", { browser_id: util2.getBrowserId() }, iframe.iframeId);
    };
    const passCookieConsents = (iframe) => {
      postmessage2.send("passCookieConsents", util2.getCookieConsents(), iframe.iframeId);
    };
    const passUserSegments = (iframe) => {
      postmessage2.send("passUserSegments", util2.getUserSegmentsString(), iframe.iframeId);
    };
    const passUserState = (iframe) => {
      postmessage2.send("passUserState", util2.getUserState(), iframe.iframeId);
    };
    const passPageViewContext = (iframe) => {
      const { pageTitle, url, pageViewId: pageViewId2, referrerUrl, author, created, section, tags, contentType } = util2.getPageViewContext();
      postmessage2.send("passPageViewContext", {
        page_title: pageTitle,
        url,
        page_view_id: pageViewId2,
        referrer: referrerUrl,
        content_author: author,
        content_created: created == null ? void 0 : created.toString(),
        content_section: section,
        tags: tags ? JSON.stringify(tags) : null,
        content_type: contentType
      }, iframe.iframeId);
    };
    const merge = (firstObj, secondObj) => {
      var result = {};
      Object.keys(firstObj).forEach((key2) => {
        result[key2] = firstObj[key2];
      });
      Object.keys(secondObj).forEach((key2) => {
        result[key2] = secondObj[key2];
      });
      return result;
    };
    const setUpGigyaCallbacks = () => {
      if (!isAddedUserProviderCallbacks) {
        pn.gigya.registerCallback("userChanged", (result) => {
          if (result && result.user_token) {
            let params = {
              token_list: result.access_token.value,
              user_token: result.user_token,
              userToken: result.user_token,
              cookie_domain: result.access_token.cookie_domain,
              user: result.user,
              allowReturnToStartState: loginRequiredAllowReturnToStartState,
              termId: loginRequiredTermId
            };
            if (loginRequiredIframeId) {
              var iframe = containerUtils2.getIframe(loginRequiredIframeId);
              if (iframe) {
                postmessage2.send("externalLoginSuccess", params, loginRequiredIframeId);
                delete params.termId;
                _reloadAll(params, loginRequiredIframeId);
              } else {
                _reloadAll(params);
              }
            } else {
              _reloadAll(params);
            }
          }
        });
        pn.gigya.registerCallback("logout", () => {
          var config = {};
          config.userProvider = user2.getProvider().getName();
          config.userToken = user2.getProvider().getToken() && user2.getProvider().getToken().length > 0 ? user2.getProvider().getToken() : "";
          config.noNeedStartCheckout = true;
          var iframe;
          if (loginRequiredIframeId) {
            iframe = containerUtils2.getIframe(loginRequiredIframeId);
          }
          if (iframe) {
            if (iframe.config.displayMode === "inline") {
              containerUtils2.closeModalContainer();
            }
          }
          loginRequiredTermId = "";
          loginRequiredIframeId = "";
          loginRequiredAllowReturnToStartState = false;
          _reloadAll(config);
        });
        isAddedUserProviderCallbacks = true;
      }
    };
    const setUpJanrainCallbacks = () => {
      if (!isAddedUserProviderCallbacks) {
        pn.janrain.registerCallback("userChanged", (result) => {
          if (result && result.user_token) {
            var params = {
              token_list: result.access_token.value,
              user_token: result.user_token,
              userToken: result.user_token,
              cookie_domain: result.access_token.cookie_domain,
              user: result.user,
              allowReturnToStartState: loginRequiredAllowReturnToStartState,
              termId: loginRequiredTermId
            };
            if (loginRequiredIframeId) {
              var iframe = containerUtils2.getIframe(loginRequiredIframeId);
              if (iframe) {
                postmessage2.send("externalLoginSuccess", params, loginRequiredIframeId);
                delete params.termId;
                _reloadAll(params, loginRequiredIframeId);
              } else {
                _reloadAll(params);
              }
            } else {
              _reloadAll(params);
            }
          }
        });
        pn.janrain.addEventHandler("onCaptureSessionEnded", () => {
          var config = {};
          config.userProvider = user2.getProvider().getName();
          config.userToken = user2.getProvider().getToken() && user2.getProvider().getToken().length > 0 ? user2.getProvider().getToken() : "";
          config.noNeedStartCheckout = true;
          var iframe;
          if (loginRequiredIframeId) {
            iframe = containerUtils2.getIframe(loginRequiredIframeId);
          }
          if (iframe) {
            if (iframe.config.displayMode === "inline") {
              containerUtils2.closeModalContainer();
            }
          }
          loginRequiredTermId = "";
          loginRequiredIframeId = "";
          loginRequiredAllowReturnToStartState = false;
          _reloadAll(config);
        });
        isAddedUserProviderCallbacks = true;
      }
    };
    const setUpPianoIdCallbacks = () => {
      if (!isAddedUserProviderCallbacks) {
        pn.pianoId.setCallbacks({
          loggedIn: (data) => {
            util2.log("offer.js - piano id user logged in");
            var params = {
              user_token: data.token,
              userToken: data.token,
              user: data.user,
              reloadAfterLogin: true,
              termId: loginRequiredTermId
            };
            if (loginRequiredIframeId) {
              var iframe = containerUtils2.getIframe(loginRequiredIframeId);
              if (iframe) {
                postmessage2.send("externalLoginSuccess", params, loginRequiredIframeId);
                reload(loginRequiredIframeId, params);
                delete params.termId;
                _reloadAll(params, loginRequiredIframeId);
              } else {
                _reloadAll(params);
              }
            } else {
              _reloadAll(params);
            }
          },
          loggedOut: (data) => {
            if (data.source !== LOGIN_LOGOUT_SOURCE) {
              var config = {};
              config.userProvider = user2.getProvider().getName();
              config.userToken = user2.getProvider().getToken() && user2.getProvider().getToken().length > 0 ? user2.getProvider().getToken() : "";
              config.noNeedStartCheckout = true;
              _reloadAll(config);
            }
            loginRequiredTermId = "";
            loginRequiredIframeId = "";
          }
        });
        isAddedUserProviderCallbacks = true;
      }
    };
    function _applyPreloadIframe(iframe) {
      return containerUtils2.showPreloadedContainer(iframe);
    }
    const _fireCallback = (config) => {
      const event = config.offerId === containerUtils2.fakeOfferId ? "showTemplate" : "showOffer";
      if (eventManager.hasCallback(event)) {
        eventManager.fireCallbacks(event, config, void 0, true);
      }
      sendGAEvent(event, { params: config });
    };
    const readConfigParamsFromHostUrl = (config) => {
      const POSSIBLE_PREDEFINED_PARAMS = [{
        queryParam: "promo_code",
        configParam: "promoCode"
      }];
      POSSIBLE_PREDEFINED_PARAMS.forEach((param2) => {
        const value = util2.getQueryParamByName(param2.queryParam);
        if (value.length) {
          config[param2.configParam] = value;
        }
      });
    };
    const getRurl3ds = () => {
      return util2.getQueryParamByName(PROCESS_3DS_RURL);
    };
    const isModalOpenOnScaStepWithoutRurl3ds = (config) => {
      const rurl_3ds = getRurl3ds();
      return rurl_3ds && !config.rurl_3ds && config.displayMode === "modal";
    };
    const _show = (config) => {
      if (!config.offerId && config.preview !== true) {
        util2.error("Must specify offerId");
        return;
      }
      if (_isLockedConfig(config)) {
        return false;
      }
      if (isModalOpenOnScaStepWithoutRurl3ds(config)) {
        return;
      }
      trackingId = config.trackingId;
      setTrackingIdToGa(trackingId);
      if (!config.preview && !tp.disableLockConfig) {
        _lockConfig(config);
      }
      setTimeout(() => {
        _releaseConfig(config);
      }, lockTimeout);
      if (isUpgradeOffer(config.offerType)) {
        createUpgradeOffer(config);
      } else {
        _createOffer(config);
      }
    };
    function _createOffer(config) {
      util2.waitCall("refreshUserToken", () => {
        util2.waitCall("refreshAccessTokenList", () => {
          util2.waitCall("myAccountLogin", () => {
            util2.startCall("offerCreate");
            let iframe;
            if (config.createIframeFn) {
              readConfigParamsFromHostUrl(config);
              iframe = config.createIframeFn(config);
            } else {
              iframe = createOfferIframe(config);
            }
            if (!iframe) {
              util2.doneCall("offerCreate");
              util2.error("Could not initialize offer; check configuration");
              return;
            }
            if (_isDirectCheckout(config)) {
              _setTrackedIframeValue(iframe.iframeId, { isDirectCheckout: true });
              _startDirectCheckout(iframe.iframeId);
            }
            _fireCallback(config);
          });
        });
      });
    }
    function _preload(config) {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      let ilRes;
      let ilRej;
      const iframeLoadPromise = new Promise((res, rej) => {
        ilRes = res;
        ilRej = rej;
      });
      if (config.displayMode !== "popup" && config.offerId) {
        util2.waitCall("refreshAccessTokenList", () => {
          config.isPreload = true;
          util2.startCall("offerCreate");
          let iframe;
          if (config.createIframeFn) {
            readConfigParamsFromHostUrl(config);
            iframe = config.createIframeFn(config);
          } else {
            iframe = createOfferIframe(config);
          }
          if (!iframe) {
            util2.doneCall("offerCreate");
            util2.error("Could not initialize offer; check configuration");
            reject();
          } else {
            iframe.element.onload = () => {
              ilRes(iframe);
            };
            resolve(iframe);
          }
        });
      } else {
        reject();
      }
      return {
        promise,
        show: function() {
          promise.then(_applyPreloadIframe).then(() => {
            return iframeLoadPromise;
          }).then((iframe) => {
            trackStat(iframe);
            if (_isDirectCheckout(config)) {
              _startDirectCheckout(iframe.iframeId);
            }
            _fireCallback(config);
          }, () => {
            _show(config);
            delete config.isPreload;
          });
        }
      };
    }
    ;
    const _isDirectCheckout = (config) => {
      return !!config.directCheckout && config.displayMode !== "inline";
    };
    const _startDirectCheckout = (iframeId) => {
      util2.waitCall("offerCreate", () => {
        postmessage2.send("startDirectCheckout", {}, iframeId);
      });
    };
    const shouldInterruptCheckoutStart = (config) => {
      return !config.offerId && !config.isRedemption && !config.preview;
    };
    const shouldAuthByGmSsoRedirect = () => {
      return pn.pianoId.__protected__.isGmSsoRedirectEnabled() && !pn.pianoId.getToken();
    };
    const processLinkedTermCheckoutAfterExternalLogin = ({ token, termId, iframeId }) => {
      var _a;
      postmessage2.send("startLinkedTermProcessAfterExternalLogin", { termId }, iframeId);
      if (needReloadOnStartCheckout) {
        _reloadAll({
          userProvider: (_a = user2.getProvider()) == null ? void 0 : _a.getName(),
          userToken: token,
          noNeedStartCheckout: true,
          noNeedStartCheckoutAfterLogin: true
        });
        needReloadOnStartCheckout = false;
      }
    };
    const startCheckout = (config, sender) => {
      if (shouldInterruptCheckoutStart(config)) {
        return;
      }
      const hasLoginRequiredCallback = eventManager.hasCallback("loginRequired");
      if (config.isSiteLicensing && hasLoginRequiredCallback && (isUserRef() || isAuthSync())) {
        template2.refreshUser(templateIframeParams.iframeId);
        return;
      }
      if (containerUtils2.hasModalIframe() && !isLinkedTermCheckout(config)) {
        containerUtils2.closeModalContainer();
      }
      util2.debug("creating checkout: ", config);
      config.displayMode = config.displayMode === "popup" ? "popup" : "modal";
      config.isCheckout = true;
      config.parent = sender;
      util2.waitCall("refreshUserToken", () => {
        util2.waitCall("refreshAccessTokenList", () => {
          var _a;
          if (isLinkedTermCheckout(config) && config.reloadAfterLogin && isAuthSync()) {
            const token = (_a = user2.getProvider()) == null ? void 0 : _a.getToken();
            if (!token || !config[HIDDEN_SENDER_ID_PROPERTY]) {
              util2.log("external checkout cannot be continued.");
              return;
            }
            processLinkedTermCheckoutAfterExternalLogin({
              token,
              termId: config.termId,
              iframeId: config[HIDDEN_SENDER_ID_PROPERTY]
            });
            return;
          }
          util2.startCall("offerCreate");
          var iframe;
          if (pn.pianoId.__protected__.isGmSso()) {
            if (shouldAuthByGmSsoRedirect()) {
              pn.pianoId.__protected__.authByGmSsoRedirect(config);
              return;
            }
            config = __spreadProps(__spreadValues({}, config), { isGmSso: true });
          }
          if (config.createIframeFn) {
            iframe = config.createIframeFn(config);
          } else {
            iframe = createOfferIframe(config);
          }
          containerUtils2.__protected__.addChildToInlineIframe(iframe, sender);
          if (!iframe) {
            util2.doneCall("offerCreate");
            util2.error("Could not start checkout; check configuration");
          } else if (needReloadOnStartCheckout) {
            util2.waitCall("offerCreate", () => {
              needReloadOnStartCheckout = false;
              var reloadConfig = {};
              reloadConfig.userProvider = user2.getProvider().getName();
              if (user2.getProvider().getToken() && user2.getProvider().getToken().length > 0) {
                reloadConfig.userToken = user2.getProvider().getToken();
              } else {
                reloadConfig.userToken = "";
              }
              reloadConfig.noNeedStartCheckout = true;
              reloadConfig.noNeedStartCheckoutAfterLogin = true;
              _reloadAll(reloadConfig, iframe.iframeId);
            });
          }
        });
      });
    };
    const startLinkedTermCheckout = (termId, offerId) => {
      if (!iframes.length) {
        util2.debug("there are not offer iframes.");
        return;
      }
      if (offerId) {
        const offerIframe = iframes.find((iframe) => {
          var _a, _b;
          return ((_a = iframe == null ? void 0 : iframe.config) == null ? void 0 : _a.offerId) === offerId || ((_b = iframe == null ? void 0 : iframe.iframeParams) == null ? void 0 : _b.offerId) === offerId;
        });
        if (offerIframe) {
          postmessage2.send("tpStartLinkedTermCheckout", { termId }, offerIframe.iframeId);
        } else {
          util2.debug(`offer iframe ${offerId} was not found`);
        }
        return;
      }
      iframes.forEach((iframe) => {
        postmessage2.send("tpStartLinkedTermCheckout", { termId }, iframe.iframeId);
      });
    };
    const startRedeemVoucher = (config, sender) => {
      containerUtils2.closeModalContainer();
      if (!config) {
        config = {};
      }
      config.isRedemption = true;
      util2.debug("starting redeem voucher: ", config);
      config.displayMode = config.displayMode === "popup" ? "popup" : "modal";
      config.isCheckout = false;
      config.parent = sender;
      util2.waitCall("refreshAccessTokenList", () => {
        util2.startCall("offerCreate");
        var iframe;
        if (config.createIframeFn) {
          iframe = config.createIframeFn(config);
        } else {
          iframe = createOfferIframe(config);
        }
        if (!iframe) {
          util2.doneCall("offerCreate");
          util2.error("Could not start redeem; check configuration");
        }
      });
    };
    const reload = (iframeId, config) => {
      postmessage2.send("reloadOffer", config, iframeId);
    };
    const _reloadAll = (config, exceptIframeId) => {
      postmessage2.broadcast("reloadOffer", config, exceptIframeId);
    };
    const mergeLoginRequiredParamsWithConfig = (iframe, params, senderId) => {
      var config = {
        reloadAfterLogin: true
      };
      Object.assign(config, iframe.config);
      if (config.singleContainer) {
        delete config.singleContainer;
      }
      if (params.termId) {
        config.termId = params.termId;
      }
      if (params.term) {
        config.term = {};
        config.term = merge(config.term, params.term);
      }
      if (params.startScreen) {
        config.startScreen = params.startScreen;
      }
      if (params.isRedemption) {
        config.isRedemption = params.isRedemption;
        config.voucherCode = params.redemption && params.redemption.form && params.redemption.form.redeemCode;
        config.termId = null;
      }
      if (params && params.currentState && iframe.config.displayMode === "modal") {
        config.allowReturnToStartState = true;
      }
      if (params.preventExternalLogin) {
        config.preventExternalLogin = params.preventExternalLogin;
      }
      if (params.sharedAccountCode) {
        config.sharedAccountCode = params.sharedAccountCode;
      }
      if (params.isSiteLicensing) {
        config.isSiteLicensing = params.isSiteLicensing;
      }
      if (params.campaignCode) {
        config.campaignCode = params.campaignCode;
      }
      if (params.campaignGroupId) {
        config.campaignGroupId = params.campaignGroupId;
      }
      if (params.termType) {
        config[HIDDEN_TERM_TYPE_PROPERTY] = params.termType;
      }
      if (senderId) {
        config[HIDDEN_SENDER_ID_PROPERTY] = senderId;
      }
      config.displayMode = "modal";
      return config;
    };
    const checkThreeDSRedirect = () => {
      var rurl_3ds = getRurl3ds();
      if (rurl_3ds) {
        var additionalParamsNames = {
          offerId: "pn_offer_id",
          oid: "pn_oid",
          termId3ds: "pn_term_id",
          providerId: "pn_provider_id",
          thirdPartyParams: "third_party_params"
        };
        var parametersForRemove = [PROCESS_3DS_RURL];
        var additionalParams = Object.keys(additionalParamsNames).reduce((acc, paramKey) => {
          var nAcc = Object.assign({}, acc);
          nAcc[paramKey] = util2.getQueryParamByName(additionalParamsNames[paramKey]);
          parametersForRemove.push(additionalParamsNames[paramKey]);
          return nAcc;
        }, {});
        util2.removeQueryParamByName(parametersForRemove);
        _show(Object.assign({
          displayMode: "modal",
          rurl_3ds
        }, additionalParams));
      }
    };
    const name3 = "offer";
    const show = (config) => {
      if (config.displayMode === "inline") {
        containerUtils2.operationWithContainer(config.containerSelector, () => {
          _show(config);
        });
      } else {
        _show(config);
      }
    };
    const deferredShow = (config) => {
      return _preload(config);
    };
    const close = () => {
      containerUtils2.closeModalContainer();
    };
    const closeInline = (selector) => {
      containerUtils2.__protected__.closeInlineContainers(selector);
    };
    const showBackdrop = () => {
      containerUtils2.showBackdrop();
    };
    const hideBackdrop = () => {
      containerUtils2.hideBackdrop();
    };
    const centerBackdrop = (container2) => {
      containerUtils2.centerBackdrop(container2);
    };
    const registerCallback = (callbackName, callback) => {
      eventManager.addEvent(callbackName);
      eventManager.registerCallback(callbackName, callback);
    };
    const reloadAll = (config, exceptIframeId) => {
      var initConfig = config || {};
      util2.waitCall("refreshUserToken", () => {
        _reloadAll(Object.assign(initConfig, { userToken: pn.user.getProvider().getToken() }), exceptIframeId);
      });
    };
    const resetUserAndReloadAll = (config, exceptIframeId) => {
      var initConfig = config || {};
      _reloadAll(Object.assign(initConfig, { userToken: "" }), exceptIframeId);
    };
    const isUserRef = () => {
      return user2.getProvider().getName() === "publisher_user_ref";
    };
    const isAuthSync = () => {
      return user2.getProvider().getName() === "piano_id_lite";
    };
    const isLinkedTermCheckout = (config) => {
      const isLinkedTerm = config[HIDDEN_TERM_TYPE_PROPERTY] === "linked" /* LINKED */;
      const isLinkedTermBackwardCompatibility = config[HIDDEN_TERM_TYPE_PROPERTY] === "link" /* LINK */;
      return isLinkedTerm || isLinkedTermBackwardCompatibility;
    };
    const shouldCheckVisibilityOnInit = (iframe) => {
      var _a, _b;
      return ((_a = iframe == null ? void 0 : iframe.iframeParams) == null ? void 0 : _a.experienceId) && ((_b = iframe == null ? void 0 : iframe.iframeParams) == null ? void 0 : _b.experienceActionId) && getCalculateParams(iframe.iframeId).iframeWidth !== 0 && getCalculateParams(iframe.iframeId).iframeHeight !== 0;
    };
    const isUpgradeOffer = (offerType) => {
      return offerType === "upgradeOffer" /* UPGRADE */;
    };
    const shouldCreateUpgradeOffer = (config) => {
      const upgradeOfferParams = user2.getUserInfoParams(config);
      upgradeOfferParams.user_provider = user2.getProvider().getName();
      upgradeOfferParams.aid = pn.aid;
      upgradeOfferParams.offer_id = config.offerId;
      return new Promise((resolve, reject) => {
        api2.callApi("/anon/term/change/offer/hasData", upgradeOfferParams, ({
          code,
          data
        }) => {
          if (code === 0) {
            resolve(data);
          } else {
            reject(code);
          }
        }, void 0, void 0);
      });
    };
    const continueCreateUpgradeOffer = (config) => {
      shouldCreateUpgradeOffer(config).then((response) => {
        if (response || config.preview) {
          _createOffer(config);
        }
      });
    };
    const createUpgradeOffer = (config) => {
      tp.enableDoubleOptInCheckOnAccessCheck();
      if (user2.isUserValid() && user2.isUserConfirmed() || config.preview) {
        continueCreateUpgradeOffer(config);
      } else if (user2.isUserValid() && !user2.isUserConfirmed()) {
        showDoubleOptInForm(config);
      } else {
        showLoginForm(config);
      }
    };
    const showDoubleOptInForm = (config) => {
      pn.doubleOptIn.check();
      setUserProviderCallbackToPreCheck(config);
    };
    const showLoginForm = (config) => {
      user2.showLogin({});
      setUserProviderCallbackToPreCheck(config);
    };
    const setUserProviderCallbackToPreCheck = (config) => {
      const isNotLoginRequired = typeof config.loginRequired === "undefined" || !config.loginRequired;
      if (pn.janrain.isConfigured() && isNotLoginRequired) {
        handleJanrainUserChangedForUpgradeOffer(config);
        return;
      }
      if (pn.gigya.isConfigured() && isNotLoginRequired) {
        handleGigyaUserChangedForUpgradeOffer(config);
        return;
      }
      if (pn.pianoId.isConfigured()) {
        handlePianoIdUserChangedForUpgradeOffer(config);
        return;
      }
    };
    const handleJanrainUserChangedForUpgradeOffer = (config) => {
      pn.janrain.registerCallback("userChanged", (result) => {
        if (result && result.user_token) {
          continueCreateUpgradeOffer(config);
        }
      });
    };
    const handleGigyaUserChangedForUpgradeOffer = (config) => {
      pn.janrain.registerCallback("userChanged", (result) => {
        if (result && result.user_token) {
          continueCreateUpgradeOffer(config);
        }
      });
    };
    const handlePianoIdUserChangedForUpgradeOffer = (config) => {
      pn.pianoId.setCallbacks({
        loggedIn: (data) => {
          var _a;
          if (user2.isUserValid() && ((_a = data.user) == null ? void 0 : _a.confirmed)) {
            continueCreateUpgradeOffer(config);
          }
        }
      });
    };
    return {
      name: name3,
      show,
      deferredShow,
      close,
      closeInline,
      startCheckout,
      startLinkedTermCheckout,
      startRedeemVoucher,
      createOfferIframe,
      showBackdrop,
      hideBackdrop,
      centerBackdrop,
      registerCallback,
      reload,
      reloadAll,
      resetUserAndReloadAll,
      checkThreeDSRedirect,
      passUserSegments,
      passCookieConsents,
      passUserState
    };
  };
  pn.container.register("offer", {
    useValue: offer()
  });
  pn.offer = pn.container.resolve("offer");

  // ../src/lib/myaccount.ts
  var myaccount = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const postmessage2 = pn.container.resolve("postmessage");
    const offer2 = pn.container.resolve("offer");
    const user2 = pn.container.resolve("user");
    const containerUtils2 = pn.container.resolve("containerUtils");
    const pianoId2 = pn.container.resolve("pianoId");
    const logging2 = pn.container.resolve("logging");
    const msqa = pn.container.resolve("microsoftQuickAuth");
    const acp2 = pn.container.resolve("acp");
    const name3 = "myaccount";
    const VERIFICATION_CODE_QUERY = "verification_code";
    const iframes = {};
    let tooTall = false;
    const callbacks = {
      loginRequired: [],
      loginSuccess: [],
      autoRenewalDisabled: [],
      subscriptionCancellation: []
    };
    const _getBaseUrl = () => {
      return pn.getEndpointRoot() + "/checkout/myaccount/show";
    };
    const _createContainer = () => {
      var container = document.createElement("div");
      jqUtils2.addClass("tp-modal", container);
      var close = document.createElement("div");
      jqUtils2.addClass("tp-close", close);
      jqUtils2.append(container, close);
      jqUtils2.append(document.body, container);
      return container;
    };
    const _resizeIframe = (iframe, params) => {
      iframe.element.style.height = (iframe.config.maxHeight ? Math.min(params.height, iframe.config.maxHeight) : params.height) + "px";
      iframe.container.style.height = (iframe.config.maxHeight ? Math.min(params.height, iframe.config.maxHeight) : params.height) + "px";
      iframe.element.style.width = params.width + "px";
      if (iframe.config.displayMode === "modal") {
        iframe.container.style.width = params.width + "px";
      }
      postmessage2.send("resized", {
        height: iframe.config.maxHeight ? Math.min(params.height, iframe.config.maxHeight) : params.height,
        width: params.width
      }, iframe.iframeId);
    };
    let dialog;
    const _createDialog = (params, onClose) => {
      const container = document.createElement("div");
      jqUtils2.addClass("tp-modal", container);
      const close = document.createElement("div");
      jqUtils2.addClass("tp-close", close);
      const message = document.createElement("div");
      jqUtils2.addClass("tp-message", message);
      container.style.width = (params.width ? params.width : 400) + "px";
      message.innerHTML = params.message;
      const btnContainer = document.createElement("div");
      jqUtils2.addClass("tp-btn-container", btnContainer);
      const okBtn = document.createElement("button");
      jqUtils2.addClass("tp-btn", okBtn);
      jqUtils2.addClass("tp-ok-btn", okBtn);
      okBtn.innerHTML = params.ok ? params.ok : "Ok";
      const cancelBtn = document.createElement("button");
      jqUtils2.addClass("tp-btn", cancelBtn);
      jqUtils2.addClass("tp-cancel-btn", cancelBtn);
      cancelBtn.innerHTML = params.cancel ? params.cancel : "Cancel";
      jqUtils2.on(close, "click", _closeDialog(onClose, params, "cancel"));
      jqUtils2.on(cancelBtn, "click", _closeDialog(onClose, params, "cancel"));
      jqUtils2.on(okBtn, "click", _closeDialog(onClose, params, "ok"));
      jqUtils2.append(container, close);
      jqUtils2.append(container, message);
      jqUtils2.append(btnContainer, okBtn);
      jqUtils2.append(btnContainer, cancelBtn);
      jqUtils2.append(container, btnContainer);
      jqUtils2.append(document.body, container);
      offer2.showBackdrop();
      jqUtils2.addClass("tp-active", container);
      _centerIt(container);
      dialog = container;
    };
    const _closeDialog = (onClose, params, result) => {
      return () => {
        if (dialog) {
          jqUtils2.removeClass("tp-active", dialog);
          offer2.hideBackdrop();
          window.setTimeout(() => {
            jqUtils2.remove(dialog);
          }, 250);
          params.result = result;
          onClose(params);
        }
      };
    };
    const _centerIt = (container) => {
      const winSize = jqUtils2.winSize();
      if (container.offsetHeight > winSize.height) {
        if (tooTall === false) {
          container.style.position = "absolute";
          tooTall = true;
        }
        container.style.marginTop = window.scrollY - winSize.height * 0.5 + "";
      } else {
        if (tooTall === true) {
          container.style.position = "fixed";
          tooTall = false;
        }
        container.style.marginTop = 0 - container.offsetHeight * 0.5 + "";
      }
      offer2.centerBackdrop(container);
      container.style.marginLeft = 0 - container.offsetWidth * 0.5 + "";
    };
    const _openDialog = (event, params) => {
      _createDialog(params.params, (result) => {
        postmessage2.send("closeDialog", result, iframes[params.sender].iframeId);
      });
    };
    const registerCallback = (event, callback) => {
      callbacks[event] = callbacks[event] || [];
      callbacks[event].push(callback);
    };
    const _fireCallbacks = (event, object, iframeId) => {
      util2.debug("received event: " + event, object);
      if (typeof callbacks[event] === "undefined") {
        return;
      }
      for (var i = 0; i < callbacks[event].length; ++i) {
        util2.debug("firing callback for event: " + event);
        var result = callbacks[event][i](object);
        if (object && object.resultCallbackId) {
          object.result = result;
          object.event = event;
          postmessage2.send("resultCallback", object, iframeId);
        }
      }
      if (!callbacks[event].length && object && object.resultCallbackId) {
        object.callbackNotFound = true;
        object.event = event;
        postmessage2.send("resultCallback", object, iframeId);
      }
    };
    const _receive = (params) => {
      util2.log("*** My account event received", params.event, params.params);
      switch (params.event) {
        case "resize":
          util2.debug("*** Resize event", params.params.width, params.params.height);
          _resizeIframe(iframes[params.sender], params.params);
          if (iframes[params.sender].config.displayMode === "modal") {
            _centerIt(iframes[params.sender].container);
          }
          break;
        case "loaded":
          const loadedIframe = iframes[params.sender];
          postmessage2.send("initMaxHeight", {
            height: loadedIframe.config.maxHeight
          }, loadedIframe.iframeId);
          pn.offer.passCookieConsents(loadedIframe);
          pn.offer.passUserSegments(loadedIframe);
          pn.offer.passUserState(loadedIframe);
          _resizeIframe(loadedIframe, params.params);
          if (user2.getProvider().name === "pianoId") {
            pianoId2.__protected__.executePostMessagesBatch();
          }
          if (loadedIframe.config.displayMode === "modal") {
            window.setTimeout(() => {
              jqUtils2.addClass("tp-active", loadedIframe.container);
              _centerIt(loadedIframe.container);
            }, 25);
          }
          logging2.setTime("myAccountShow", Math.floor(performance.now() - loadedIframe.config.initTime));
          break;
        case "cancel":
        case "complete":
        case "error":
        case "loginRequired":
        case "customEvent":
        case "completeUpgradePurchase":
          _fireCallbacks(params.event, params.params, params.sender);
          break;
        case "openDialog":
          _openDialog(params.event, params);
          break;
        case "pianoIdProfileUpdated":
          pianoId2.onProfileUpdate(params.params, () => {
            var object = params.params;
            if (object && object.resultCallbackId) {
              postmessage2.send("resultCallback", object, params.sender);
            }
            const config2 = {
              userToken: params.params.token,
              user: params.params.user
            };
            _reload(config2);
          });
          break;
        case "extendedUserLoginRequired":
          pianoId2.onExtendedUserLoginRequired();
          break;
        case "loginSuccess":
          user2.getProvider().onLoginSuccess(params.params);
          var config = {
            reloadAfterLogin: true,
            userToken: params.params.user_token,
            user: params.params.user
          };
          _reload(config);
          _fireCallbacks(params.event, params.params, params.sender);
          break;
        case "logout":
          user2.logout(() => {
            var config2 = {};
            config2.userProvider = user2.getProvider().getName();
            config2.userToken = user2.getProvider().getToken() && user2.getProvider().getToken().length > 0 ? user2.getProvider().getToken() : "";
            _reload(config2);
          });
          _fireCallbacks(params.event, params.params, params.sender);
          break;
        case "userProfileUpdateSuccess":
          var message = params;
          var messageEvent = message.event;
          var messageParams = message.params;
          var messageSender = message.sender;
          user2.getProvider().onLoginSuccess(messageParams);
          var reloadConfig = {
            userProvider: messageParams.user_provider,
            userToken: messageParams.user_token
          };
          _reload(reloadConfig);
          _fireCallbacks(messageEvent, messageParams, messageSender);
          for (var key2 in iframes) {
            if (iframes.hasOwnProperty(key2)) {
              var iframe = iframes[key2];
              var iframeConfig = iframe.config;
              if (iframeConfig.hasOwnProperty("userToken")) {
                delete iframeConfig.userToken;
              }
              show(iframeConfig);
            }
          }
          break;
        case "langChangedWithinMyAccount":
          if (pianoId2.isConfigured()) {
            pianoId2.updateLang(params.params.lang);
          }
          break;
        case "requestScrollData":
          _returnScrollData(params.sender);
          break;
        case "downForMaintenance":
          _resizeIframe(iframes[params.sender], { width: 300, height: 200 });
          break;
        case "removeQueryParamByName":
          if (Array.isArray(params.params.paramsToRemove)) {
            params.params.paramsToRemove.forEach((name4) => {
              util2.removeQueryParamByName(name4);
            });
          }
          break;
        case "getTrackingData":
          postmessage2.send("getTrackingDataResponseEvent", { pageViewId: pn.main.fetchPageViewId(), tbc: util2.getTbcCookie() }, params.sender);
          break;
        case "redirect":
          document.location.href = params.params.url;
          break;
        case "getTemplateInteractionConfig":
          acp2.sendTemplateInteractionActive(iframes[params.sender].config);
          break;
        case "acp-auto-renewal-disabled" /* autoRenewalDisabled */:
        case "acp-subscription-cancellation" /* subscriptionCancellation */:
          acp2.handleAcpEvent(_fireCallbacks, params, iframes[params.sender].config, true);
          break;
        default:
          util2.log("Received invalid event type: " + params.event);
          return;
      }
    };
    const _reload = (config) => {
      postmessage2.broadcast("reloadOffer", config);
    };
    const _handleKeystroke = (event) => {
    };
    const _returnScrollData = (senderId) => {
      var myAccountRect = iframes[senderId].element.getBoundingClientRect();
      var data = {
        iframeRect: {
          bottom: myAccountRect.bottom,
          height: myAccountRect.height,
          left: myAccountRect.left,
          right: myAccountRect.right,
          top: myAccountRect.top,
          width: myAccountRect.width
        }
      };
      postmessage2.send("returnScrollData", data, senderId);
    };
    const _checkIframeSizes = () => {
      for (var iframeId in iframes) {
        var iframe = iframes[iframeId];
        var needToSend = false;
        const iframeContainerWidth = jqUtils2.getWidth(iframe.container);
        if (iframeContainerWidth !== iframe.containerWidth) {
          iframe.element.style.width = iframeContainerWidth + "";
          iframe.containerWidth = iframeContainerWidth;
          needToSend = true;
        }
        const iframeContainerHeight = jqUtils2.getHeight(iframe.container);
        if (iframeContainerHeight !== iframe.containerHeight) {
          iframe.element.style.height = iframeContainerHeight + "";
          iframe.containerHeight = iframeContainerHeight;
          needToSend = true;
        }
        if (needToSend) {
          postmessage2.send("resize", {
            width: iframeContainerWidth,
            height: iframeContainerHeight
          }, iframeId);
        }
      }
    };
    function _createIframe(config) {
      config.initTime = performance.now();
      var iframeParams = {
        widget: "myaccount"
      };
      if (pn.staticDomain) {
        iframeParams.staticDomain = pn.staticDomain;
      }
      if (config.templateId) {
        iframeParams.templateId = config.templateId;
      }
      if (typeof config.displayMode === "undefined") {
        config.displayMode = "inline";
      } else {
        if (config.displayMode !== "modal" && config.displayMode !== "inline") {
          util2.log("Invalid offer displayMode; must be one of: modal, inline");
          return;
        }
      }
      iframeParams.displayMode = config.displayMode;
      iframeParams.iframeId = util2.randomString(16);
      iframeParams.url = window.location.href;
      iframeParams.initialWidth = config.width;
      iframeParams.initialHeight = config.height;
      iframeParams.maxHeight = config.maxHeight;
      iframeParams.v3ApiEndpoint = pn.getApiEndpoint();
      if (user2.getProvider().getName() === pianoId2.getName() && pianoId2.__protected__.isSssEnabled()) {
        const params = pianoId2.__protected__.getSssParams();
        iframeParams.piano_id_sss_mode = params.sss_mode;
        iframeParams.piano_id_sss_callback_url = params.sss_callback_url;
        iframeParams.piano_id_sss_origin_url = params.sss_origin_url;
      }
      if (pn.locale) {
        iframeParams.lang = pn.locale;
      }
      if (pn.janrain.isConfigured() && (typeof config.loginRequired === "undefined" || !config.loginRequired)) {
        var hiddenIframes = [];
        var savedOfferConfig = config;
        pn.janrain.addEventHandler("onModalClose", () => {
          containerUtils2.activateContainers(hiddenIframes);
          util2.doneCall("myAccountLogin");
        });
        pn.janrain.registerCallback("userChanged", (result) => {
          if (result && result.user_token) {
            var loginSuccessResult;
            if (config.loginSuccess) {
              loginSuccessResult = config.loginSuccess(result);
            }
            if (typeof loginSuccessResult === "undefined" || loginSuccessResult) {
              savedOfferConfig.userToken = result.user_token;
              show(savedOfferConfig);
            }
          }
        });
        pn.janrain.addEventHandler("onCaptureSessionEnded", (result) => {
          var loginSuccessResult;
          if (config.loginSuccess) {
            loginSuccessResult = config.loginSuccess(result);
          }
          if (typeof loginSuccessResult === "undefined" || loginSuccessResult) {
            savedOfferConfig.userToken = null;
            show(savedOfferConfig);
          }
        });
        config.loginRequired = () => {
          util2.waitCall("refreshAccessTokenList", () => {
            util2.waitCall("offerCreate", () => {
              util2.startCall("myAccountLogin");
              hiddenIframes = containerUtils2.hideModalContainer();
              pn.janrain.login();
            });
          });
          return false;
        };
      } else if (pn.gigya.isConfigured() && (typeof config.loginRequired === "undefined" || !config.loginRequired)) {
        var hiddenIframes = [];
        pn.gigya.registerCallback("onHide", () => {
          containerUtils2.activateContainers(hiddenIframes);
          util2.doneCall("myAccountLogin");
        });
        config.loginRequired = () => {
          var savedOfferConfig2 = config;
          util2.waitCall("refreshAccessTokenList", () => {
            util2.waitCall("offerCreate", () => {
              util2.startCall("myAccountLogin");
              hiddenIframes = containerUtils2.hideModalContainer();
              pn.gigya.login((result) => {
                var loginSuccessResult;
                if (config.loginSuccess) {
                  loginSuccessResult = config.loginSuccess(result);
                }
                if (typeof loginSuccessResult === "undefined" || loginSuccessResult) {
                  savedOfferConfig2.userToken = result.user_token;
                  show(savedOfferConfig2);
                }
              });
            });
          });
        };
      } else if (pn.pianoId.isConfigured()) {
        var savedOfferConfig = config;
        pn.pianoId.setCallbacks({
          loggedIn: (result) => {
            if (iframeParams.userToken === result.token) {
              return;
            }
            var loginSuccessResult;
            if (config.loginSuccess) {
              loginSuccessResult = config.loginSuccess(result);
            }
            if (typeof loginSuccessResult === "undefined" || loginSuccessResult) {
              savedOfferConfig.userToken = result.token;
              show(savedOfferConfig);
            }
          },
          loggedOut: () => {
            var config2 = {};
            config2.userProvider = user2.getProvider().getName();
            config2.userToken = user2.getProvider().getToken() && user2.getProvider().getToken().length > 0 ? user2.getProvider().getToken() : "";
            _reload(config2);
          }
        });
        if (pn.pianoId.getToken() !== null) {
          msqa.clearConfirmationParameters();
        }
        if (typeof config.loginRequired === "undefined" || !config.loginRequired) {
          var countOfLogins = 0;
          config.loginRequired = () => {
            countOfLogins++;
            if (countOfLogins > 10) {
              util2.log("Too many attemps to login for myAccount");
              return;
            }
            var verificationCode = util2.getQueryParamByName(VERIFICATION_CODE_QUERY);
            const pianoIdUrlString = util2.getQueryParamByName("internal_redirect_uri");
            const responseId = util2.getQueryParamByName("response_id");
            const isMsqaAuthConfirmationFlow = pianoIdUrlString && responseId;
            const { isGmSso, isGmSsoRedirectEnabled } = pn.pianoId.__protected__;
            const shouldShowAuthModal = !(isGmSso() && isGmSsoRedirectEnabled()) && !isMsqaAuthConfirmationFlow;
            if (shouldShowAuthModal) {
              pn.pianoId.show({ verificationCode });
            } else {
              pn.pianoId.init();
            }
          };
        }
        iframeParams.pianoIdUrl = pn.pianoId.getIframeUrl();
        var lang = pn.pianoId.getLang();
        if (lang) {
          iframeParams.lang = lang;
        }
        pn.pianoId.onLangChange((lang2) => {
          postmessage2.send("langChanged", { lang: lang2 }, iframeParams.iframeId);
        }, iframeParams.iframeId);
      } else if (pn.pianoIdLite.isConfigured()) {
        iframeParams.pianoIdUrl = pn.pianoId.getIframeUrl();
      }
      return new Promise(function(resolve) {
        util2.waitCall("refreshUserToken", function() {
          let container;
          let params = {};
          if (config.displayMode === "inline") {
            if (!config.containerSelector) {
              util2.log("My account must have a valid containerSelector");
              return;
            }
            container = jqUtils2.queryEl(config.containerSelector);
            if (!container) {
              util2.log("My account must have a valid containerSelector");
              return;
            }
            iframeParams.width = jqUtils2.getWidth(container);
          } else {
            container = _createContainer();
          }
          const { pageTitle, pageViewId: pageViewId2 } = util2.getPageViewContext();
          iframeParams.pageViewId = pageViewId2;
          iframeParams.tbc = util2.getTbcCookie();
          iframeParams.browserId = util2.getBrowserId();
          iframeParams.contentType = util2.getPageViewContext().contentType;
          iframeParams.pageTitle = pageTitle;
          iframeParams.userState = util2.getUserState();
          iframeParams.userProvider = user2.getProvider().getName();
          if (config.userToken) {
            iframeParams.userToken = config.userToken;
          } else {
            iframeParams.userToken = user2.getProvider().getToken();
          }
          for (var cb in callbacks) {
            if (typeof config[cb] === "function") {
              util2.debug("Registering " + cb + " callback for iframe " + iframeParams.iframeId);
              registerCallback(cb, config[cb]);
            }
          }
          iframeParams.aid = pn.aid;
          if (pn.isSensitiveDataProtectionEnabled) {
            params = {
              userToken: iframeParams.userToken,
              iframeId: iframeParams.iframeId
            };
            delete iframeParams.userToken;
          }
          var iframeSrc = _getBaseUrl() + "?" + jqUtils2.param(iframeParams);
          var iframe = document.createElement("iframe");
          const attrs = {
            scrolling: "no",
            allowtransparency: "true",
            name: iframeParams.iframeId,
            id: iframeParams.iframeId,
            allow: "payment"
          };
          if (!pn.isSensitiveDataProtectionEnabled) {
            attrs.src = iframeSrc;
          }
          Object.keys(attrs).forEach((key2) => {
            jqUtils2.setAttr(key2, attrs[key2], iframe);
          });
          const cssMap = {
            overflow: "hidden",
            border: "0",
            height: "0"
          };
          if (config.displayMode === "inline") {
            cssMap.width = iframeParams.width + "px";
          } else {
            cssMap.width = 0;
          }
          Object.keys(cssMap).forEach((key2) => {
            iframe.style[key2] = cssMap[key2];
          });
          iframes[iframeParams.iframeId] = {
            iframeId: iframeParams.iframeId,
            config,
            element: iframe,
            container,
            containerWidth: jqUtils2.getWidth(container),
            containerHeight: jqUtils2.getHeight(container)
          };
          postmessage2.init({
            postMessageUrl: _getBaseUrl(),
            receive: _receive,
            iframe: iframes[iframeParams.iframeId]
          });
          jqUtils2.on(window, "keyup", (event) => _handleKeystroke(event));
          if (config.displayMode === "modal") {
            jqUtils2.on(window, "resize", function() {
              _centerIt(container);
            });
          }
          if (config.displayMode === "modal") {
            _centerIt(container);
          } else {
            jqUtils2.empty(container);
          }
          if (pn.isSensitiveDataProtectionEnabled) {
            params.iframeSrc = iframeSrc;
            const form = containerUtils2.getForm(params);
            jqUtils2.append(container, iframe);
            jqUtils2.append(container, form);
            form.submit();
          } else {
            jqUtils2.append(container, iframe);
          }
          jqUtils2.on(window, "resize", () => {
            _checkIframeSizes();
          });
          if (config.displayMode === "inline") {
            if (window.ResizeObserver) {
              const resizeObserver = new ResizeObserver((entries) => {
                const width = jqUtils2.getWidth(container);
                if (width > 0) {
                  _resizeIframe(iframes[iframeParams.iframeId], {
                    width
                  });
                }
              });
              resizeObserver.observe(container);
              iframes[iframeParams.iframeId].resizeObserver = resizeObserver;
            }
          }
          if (pn.offer) {
            pn.offer.registerCallback("complete", () => {
              postmessage2.send("refreshNow", {}, iframeParams.iframeId);
            });
          }
          resolve(iframes[iframeParams.iframeId]);
        });
      });
    }
    ;
    const show = (config) => {
      util2.waitCall("offerCreate", () => {
        util2.waitCall("refreshAccessTokenList", () => {
          var _a;
          (_a = _createIframe(config)) == null ? void 0 : _a.then((iframe) => {
            if (!iframe) {
              util2.log("Could not initialize my account; check configuration");
            }
          });
        });
      });
    };
    return {
      name: name3,
      show,
      registerCallback
    };
  })();
  pn.container.register("myaccount", {
    useValue: myaccount
  });
  pn.myaccount = pn.container.resolve("myaccount");

  // ../src/lib/meter.ts
  var meter = (() => {
    const DEPRECATION_MSG = "This functionality is deprecated and code will be deleted soon, get rid of its usage";
    const name3 = "meter";
    const last = () => {
      console.warn(DEPRECATION_MSG);
      return {};
    };
    const isExpired = () => {
      console.warn(DEPRECATION_MSG);
      return false;
    };
    const isExpiredNextClick = () => {
      console.warn(DEPRECATION_MSG);
      return false;
    };
    const showCurtain = (c) => {
      console.warn(DEPRECATION_MSG);
    };
    const init = (c) => {
      console.warn(DEPRECATION_MSG);
    };
    const checkMeter = (targetElem) => {
      console.warn(DEPRECATION_MSG);
    };
    const registerCallback = (event, callback) => {
    };
    return {
      name: name3,
      init,
      isExpired,
      isExpiredNextClick,
      checkMeter,
      showCurtain,
      last,
      registerCallback
    };
  })();
  pn.container.register("meter", {
    useValue: meter
  });
  pn.meter = pn.container.resolve("meter");

  // ../src/lib/fingerprint.ts
  var fingerprint = (() => {
    const util2 = pn.container.resolve("util");
    const sha12 = pn.container.resolve("sha1");
    const name3 = "fingerprint";
    let fingerprint2 = "";
    const _getLocality = () => {
      "use strict";
      try {
        var fpOffset, language;
        language = window.navigator.userLanguage || window.navigator.language;
        fpOffset = new Date().getTimezoneOffset();
        return fpOffset + ":" + language;
      } catch (e) {
        return "";
      }
    };
    const _getBrowserPlugin = () => {
      "use strict";
      if (window.ActiveXObject) {
        return _getIEBrowserPluginValue();
      } else {
        try {
          var retVal = "";
          var numPlugins = navigator.plugins.length;
          if (numPlugins > 0) {
            for (var i = 0; i < numPlugins; i++) {
              retVal += navigator.plugins[i].name + "|";
            }
          }
          return retVal;
        } catch (e) {
          return "";
        }
      }
    };
    const _getIEBrowserPluginValue = () => {
      var plugins = [
        "ShockwaveFlash.ShockwaveFlash.6",
        "ShockwaveFlash.ShockwaveFlash.7",
        "SWCt1.SWCt1.9",
        "SWCtl.SWCtl",
        "Adobe.SVGCtl",
        "WMPlayer.OCX",
        "AgControl.AgControl",
        "AcroPDF.PDF",
        "PDF.PdfCtrl",
        "RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)",
        "RealPlayer",
        "Skype.Detection",
        "3dmlw.IEPlugin",
        "GoogleTalk.Plugin",
        "GoogleTalk.Plugin.1"
      ];
      var retVal = "";
      plugins.map(function(plugin) {
        try {
          new window.ActiveXObject(plugin);
          retVal += plugin + "|";
        } catch (e) {
        }
      });
      return retVal;
    };
    const _getScreen = () => {
      "use strict";
      try {
        return screen.height + "x" + screen.width + "+" + screen.colorDepth;
      } catch (e) {
        return "";
      }
    };
    const _getUserAgent = () => {
      "use strict";
      return navigator.userAgent;
      var browser;
      try {
        if (/Opera[\/\s](\d+\.\d+)/.test(navigator.userAgent)) {
          browser = "Opera";
        } else if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) {
          browser = "MSIE";
        } else if (/Navigator[\/\s](\d+\.\d+)/.test(navigator.userAgent)) {
          browser = "Netscape";
        } else if (/Chrome[\/\s](\d+\.\d+)/.test(navigator.userAgent)) {
          browser = "Chrome";
        } else if (/Safari[\/\s](\d+\.\d+)/.test(navigator.userAgent)) {
          browser = "Safari";
        } else if (/Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent)) {
          browser = "Firefox";
        }
        return browser;
      } catch (e) {
        return "";
      }
    };
    const _getBrowserObjects = () => {
      "use strict";
      var retStr = "";
      try {
        retStr += document.getElementById ? 1 : 0;
        retStr += window.getComputedStyle ? 1 : 0;
        retStr += screen.globalStorage ? 1 : 0;
        retStr += window.localStorage ? 1 : 0;
        retStr += window.sessionStorage ? 1 : 0;
        retStr += document.getElementsByClassName ? 1 : 0;
        retStr += document.querySelector ? 1 : 0;
        retStr += document.all ? 1 : 0;
        retStr += window.attachEvent ? 1 : 0;
        retStr += window.createPopup ? 1 : 0;
        retStr += window.XMLHttpRequest ? 1 : 0;
        retStr += window.ActiveXObject ? 1 : 0;
        retStr += window.XDomainRequest ? 1 : 0;
        retStr += window.msPerformance ? 1 : 0;
        retStr += document.documentMode ? 1 : 0;
        retStr += navigator.cpuClass ? 1 : 0;
        retStr += navigator.browserLanguage ? 1 : 0;
        retStr += window.opera ? 1 : 0;
        retStr += window.chrome ? 1 : 0;
      } catch (e) {
      }
      return retStr;
    };
    const getFingerprint = () => {
      if (fingerprint2) {
        return fingerprint2;
      }
      var fingerprint_raw = _getLocality();
      fingerprint_raw += _getBrowserPlugin();
      fingerprint_raw += _getScreen();
      fingerprint_raw += _getUserAgent();
      fingerprint_raw += _getBrowserObjects();
      fingerprint2 = sha12.hash(fingerprint_raw);
      util2.debug("Current browser fingerprint is: " + fingerprint2);
      return fingerprint2;
    };
    getFingerprint();
    return {
      name: name3,
      getFingerprint
    };
  })();
  pn.container.register("fingerprint", {
    useValue: fingerprint
  });
  pn.fingerprint = pn.container.resolve("fingerprint");

  // ../src/lib/scrollDepth.ts
  var scrollDepth = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const name3 = "scrollDepth";
    let maxDocumentHeight = 0;
    let maxScrollDepth = 0;
    let checkDuration = 200;
    let _timer;
    let maxScrolledPosition = 0;
    let listeners = [];
    jqUtils2.on(window, "scroll", function() {
      onScroll();
    });
    const initialize = (duration) => {
      var D = document;
      if (duration && duration > 0) {
        checkDuration = duration || checkDuration;
      }
      const updateMaxDepthAndHeight = () => {
        var body = D.body || {};
        var documentElement = D.documentElement || {};
        var newHeight = Math.max(body.scrollHeight, documentElement.scrollHeight, body.offsetHeight, documentElement.offsetHeight, body.clientHeight, documentElement.clientHeight);
        if (newHeight > maxDocumentHeight) {
          maxDocumentHeight = newHeight;
        }
        var newScroll = jqUtils2.scrollTop() + jqUtils2.winSize().height;
        if (newScroll > maxScrollDepth) {
          maxScrollDepth = newScroll;
          if (maxScrollDepth > maxDocumentHeight) {
            maxDocumentHeight = maxScrollDepth;
          }
        }
        if (_timer) {
          clearTimeout(_timer);
        }
        _timer = setTimeout(updateMaxDepthAndHeight, checkDuration);
      };
      updateMaxDepthAndHeight();
    };
    const getMaxScrollDepth = () => {
      return maxScrollDepth;
    };
    const getMaxDocumentHeight = () => {
      return maxDocumentHeight;
    };
    const addListener = (callback, options, consumeEventFn) => {
      if (typeof consumeEventFn !== "function") {
        consumeEventFn = function() {
          return true;
        };
      }
      listeners.push({
        callback,
        position: options.scrollDepth,
        measureType: options.measureType,
        repeat: "once",
        consumeEventFn
      });
      updateMaxScrolledPosition();
      processListeners();
    };
    const clearMaxScrolledPosition = () => {
      maxScrolledPosition = 0;
      maxScrollDepth = 0;
      maxDocumentHeight = 0;
    };
    const removeListeners = () => {
      listeners = [];
    };
    const updateMaxScrolledPosition = () => {
      var currentScroll = jqUtils2.scrollTop();
      if (currentScroll > maxScrolledPosition) {
        maxScrolledPosition = currentScroll;
      }
    };
    const onScroll = () => {
      updateMaxScrolledPosition();
      processListeners();
    };
    const listenerShouldFire = (listener) => {
      if (!listener.consumeEventFn()) {
        return;
      }
      if (listener.measureType === "pixels") {
        return listener.position <= maxScrolledPosition;
      } else if (listener.measureType === "percentage") {
        return maxScrolledPosition / (maxDocumentHeight - jqUtils2.winSize().height) >= listener.position / 100;
      }
    };
    const processListeners = () => {
      var execute = [];
      var noExecute = [];
      var listener;
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i];
        if (listenerShouldFire(listener)) {
          execute.push(listener);
        } else {
          noExecute.push(listener);
        }
      }
      listeners = noExecute;
      for (var i = 0; i < execute.length; i++) {
        execute[i].callback();
      }
    };
    return {
      name: name3,
      initialize,
      getMaxScrollDepth,
      getMaxDocumentHeight,
      addListener,
      removeListeners,
      clearMaxScrolledPosition
    };
  })();
  pn.container.register("scrollDepth", {
    useValue: scrollDepth
  });
  pn.scrollDepth = pn.container.resolve("scrollDepth");

  // ../src/lib/idle.ts
  var idle = (() => {
    const util2 = pn.container.resolve("util");
    const jqUtils2 = pn.container.resolve("jqUtils");
    const name3 = "idle";
    let initialized = false;
    let listeners = [];
    let _timer;
    const interval = 200;
    function initialize() {
      if (initialized)
        return;
      initialized = true;
      jqUtils2.on(document, "mousemove", () => resetTimer());
      jqUtils2.on(document, "keypress", () => resetTimer());
      jqUtils2.on(window, "scroll", () => resetTimer());
    }
    function updateInactiveTime() {
      if (listeners.length) {
        fire();
      }
      if (_timer) {
        clearTimeout(_timer);
      }
      if (listeners.length) {
        _timer = setTimeout(() => updateInactiveTime(), interval);
      }
    }
    function resetTimer() {
      var currentTime = Date.now();
      for (var i = 0; i < listeners.length; i++) {
        listeners[i].startTime = currentTime;
      }
      clearTimeout(_timer);
      if (listeners.length) {
        _timer = setTimeout(() => updateInactiveTime(), interval);
      }
    }
    function fire() {
      var listener;
      var execute = [];
      var noExecute = [];
      var waitingTime;
      var isEventConsumed;
      var currentTime = Date.now();
      for (var i = 0; i < listeners.length; i++) {
        listener = listeners[i];
        waitingTime = currentTime - listener.startTime;
        isEventConsumed = false;
        if (waitingTime >= listener.idleTime) {
          if (listener.consumeEventFn()) {
            isEventConsumed = true;
          } else {
            listener.startTime = currentTime;
          }
        }
        if (isEventConsumed) {
          execute.push(listener);
        } else {
          noExecute.push(listener);
        }
      }
      if (execute.length) {
        util2.debug("idle: run fire");
      }
      listeners = noExecute;
      for (var i = 0; i < execute.length; i++) {
        listener = execute[i];
        listener.callback();
      }
    }
    function addListener(callback, idleTimeInSeconds, consumeEventFn) {
      initialize();
      if (typeof consumeEventFn !== "function") {
        consumeEventFn = function() {
          return true;
        };
      }
      listeners.push({
        callback,
        idleTime: idleTimeInSeconds * 1e3,
        startTime: Date.now(),
        consumeEventFn
      });
      if (!_timer) {
        _timer = setTimeout(() => updateInactiveTime(), interval);
      }
    }
    function removeListeners() {
      listeners = [];
    }
    return {
      name: name3,
      initialize,
      addListener,
      removeListeners
    };
  })();
  pn.container.register("idle", {
    useValue: idle
  });
  pn.idle = pn.container.resolve("idle");

  // ../src/lib/interaction.ts
  var interaction = (() => {
    const util2 = pn.container.resolve("util");
    const jqUtils2 = pn.container.resolve("jqUtils");
    const name3 = "interaction";
    let boundInteractions = [];
    const bind = (callback, interactions, consumeEventFn) => {
      var actionsToJqueryEvents = (actions2) => {
        var actionToEvents = {
          "click": "click",
          "doubleClick": "dblclick",
          "rightClick": "contextmenu",
          "mouseOut": "mouseout",
          "mouseIn": "mouseover"
        };
        var events = [];
        for (var i = 0; i < actions2.length; i++) {
          var action = actions2[i];
          events.push(actionToEvents[action]);
        }
        return events;
      };
      if (typeof consumeEventFn !== "function") {
        consumeEventFn = function() {
          return true;
        };
      }
      util2.__protected__.documentReady(() => {
        for (var i = 0; i < interactions.length; i++) {
          var interaction2 = interactions[i];
          var actionsString = actionsToJqueryEvents(interaction2.elementActions).join(" ");
          var elementSelector = interaction2.elementSelector;
          var isRepetitive = interaction2.repetitive;
          if (actionsString.trim().length) {
            ((selector, action, isRepetitive2) => {
              var interactionEventHandler = () => {
                if (!consumeEventFn()) {
                  return;
                }
                if (!isRepetitive2) {
                  jqUtils2.undelegate(document.body, selector);
                }
                callback();
              };
              jqUtils2.delegate(document.body, selector, action, interactionEventHandler);
              boundInteractions.push({
                action: actionsString,
                selector: elementSelector,
                func: interactionEventHandler
              });
            })(elementSelector, actionsString, isRepetitive);
          }
        }
      });
    };
    const unbindAll = () => {
      boundInteractions.forEach((value) => {
        jqUtils2.undelegate(document.body, value.selector);
      });
      boundInteractions = [];
    };
    return {
      name: name3,
      bind,
      unbindAll
    };
  })();
  pn.container.register("interaction", {
    useValue: interaction
  });
  pn.interaction = pn.container.resolve("interaction");

  // ../src/lib/recWidgetService.ts
  var recWidgetService = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const containerUtils2 = pn.container.resolve("containerUtils");
    const name3 = "recWidgetService";
    const isInline = (config) => {
      return config.displayMode === "inline";
    };
    const isModal = (config) => {
      return config.displayMode === "modal";
    };
    const configureWidget = (widgetConfig) => {
      var wrapper = jqUtils2.queryEl(widgetConfig.containerSelector);
      var uuid = "widget-id-" + util2.randomString();
      var config = {
        singleContainer: wrapper ? wrapper : void 0,
        displayMode: widgetConfig.displayMode || "modal",
        showCloseButton: widgetConfig.showCloseButton,
        iframeParams: {
          iframeId: uuid,
          containerSelector: widgetConfig.containerSelector,
          width: widgetConfig.width,
          height: widgetConfig.height
        }
      };
      return {
        uuid,
        widgetId: widgetConfig.widgetId,
        placeholder: widgetConfig.placeholder,
        trackingId: widgetConfig.trackingId,
        config
      };
    };
    const getWidgetContainer = (iframeConfig, closeCallback) => {
      var container;
      if (isInline(iframeConfig)) {
        var inlineContainer = containerUtils2.initInlineContainer(iframeConfig);
        container = inlineContainer.container;
      } else if (isModal(iframeConfig)) {
        container = containerUtils2.getModalContainer(iframeConfig, function() {
          closeCallback instanceof Function && closeCallback();
        });
      }
      return container;
    };
    const setWidgetCallbacks = (widget, callbacks = {}) => {
      Object.keys(callbacks).forEach((callbackKey) => {
        if (jqUtils2.isFunction(callbacks[callbackKey])) {
          widget[callbackKey] = callbacks[callbackKey](widget);
        }
      });
    };
    function getInstance() {
      var widgets = [];
      var modalWidget;
      function _showRecommendation(recConfig) {
        var widgetConfig = recConfig.widgetConfig || {};
        var createPlaceholderFn = recConfig.createPlaceholderFn;
        var widgetId = widgetConfig.widgetId;
        if (!widgetId) {
          throw new Error("widgetId should be specified");
        }
        if (_findWidget(widgetId)) {
          util2.log("widget with id " + widgetConfig.widgetId + " already initialize");
          return;
        }
        if (isModal(widgetConfig) && modalWidget) {
          util2.log("modal widget already shown");
          return;
        }
        var widget = configureWidget(widgetConfig);
        var iframeConfig = widget.config;
        var element = createPlaceholderFn();
        widget.container = getWidgetContainer(iframeConfig, function() {
          _closeWidget({
            widget,
            experienceId: widgetConfig.experienceId,
            experienceActionId: widgetConfig.experienceActionId
          });
        });
        if (widget.container) {
          jqUtils2.append(widget.container, element);
        } else {
          util2.log(`widget has invalid selector "${iframeConfig.iframeParams.containerSelector}"`);
          return;
        }
        widget.element = element;
        if (isModal(iframeConfig)) {
          modalWidget = widget;
        }
        setWidgetCallbacks(widget, recConfig.widgetCallbacks);
        widgets.push(widget);
        return widget;
      }
      ;
      function _fireWidgetCallback(eventName, widgetId, eventData) {
        widgets.forEach((widget) => {
          if (widget.widgetId !== widgetId.toString()) {
            return;
          }
          var eventCallback = widget["on" + eventName];
          if (jqUtils2.isFunction(eventCallback)) {
            eventCallback(eventData);
          }
        });
      }
      ;
      function _closeWidget(closeConfig) {
        var config = closeConfig || {};
        var widget = config.widget || {};
        if (isInline(widget.config)) {
          jqUtils2.empty(widget.container);
        } else if (isModal(widget.config)) {
          _closeModalContainer(widget);
          jqUtils2.remove(widget.container);
        }
        if (!config.skipOnclose && jqUtils2.isFunction(widget.onclose)) {
          widget.onclose();
        }
        if (config.experienceActionId && config.experienceId) {
          window.postMessage(JSON.stringify({
            event_name: "piano_frequency_event",
            event_type: "close_click",
            experience_Id: config.experienceId,
            experience_action_Id: config.experienceActionId
          }), "*");
        }
        widgets = widgets.filter(function(_widget) {
          return _widget.uuid !== widget.uuid;
        });
      }
      ;
      function _clearWidgets() {
        widgets = [];
        modalWidget = null;
      }
      ;
      function _findWidget(widgetId) {
        return widgets.filter(function(widget) {
          return widgetId === widget.widgetId;
        })[0];
      }
      ;
      function _closeModalContainer(widget) {
        if (!modalWidget) {
          return;
        }
        containerUtils2.closeModal(modalWidget);
        jqUtils2.empty(modalWidget.container);
        var mobileModalFix = containerUtils2.__private__.mobileModalFix;
        if (mobileModalFix.isIphoneCaretFixed) {
          mobileModalFix.modalClosed();
        }
        modalWidget = null;
      }
      ;
      function _fixWidgetModalWidth(widget, hasIframe) {
        if (widget && !isModal(widget.config)) {
          return;
        }
        var container = widget.container;
        var widgetPlaceholder = hasIframe ? jqUtils2.queryEl("iframe", container) : jqUtils2.queryEl(".tp-widget-placeholder", container);
        containerUtils2.checkBackdropAndContainer(widget, true, true);
        setTimeout(function() {
          if (widgetPlaceholder) {
            containerUtils2.__protected__.setElementSizes(container, {
              width: jqUtils2.getWidth(widgetPlaceholder)
            });
          }
        }, 100);
      }
      ;
      return {
        showRecommendation: _showRecommendation,
        fireWidgetCallback: _fireWidgetCallback,
        findWidget: _findWidget,
        clearWidgets: _clearWidgets,
        closeWidget: _closeWidget,
        fixWidgetModalWidth: _fixWidgetModalWidth
      };
    }
    ;
    const insertWidgetLib = (config) => {
      var documentScript = document.getElementsByTagName("script")[0];
      var scriptElement = document.createElement("script");
      if (config.id) {
        scriptElement.setAttribute("id", config.id);
      }
      if (jqUtils2.isFunction(config.onerror)) {
        scriptElement.onerror = config.onerror;
      }
      if (jqUtils2.isFunction(config.onload)) {
        scriptElement.onload = config.onload;
      }
      if (config.defer) {
        scriptElement.defer = true;
      }
      scriptElement.type = "text/javascript";
      scriptElement.src = config.src;
      if (documentScript && documentScript.parentNode) {
        documentScript.parentNode.insertBefore(scriptElement, documentScript);
      }
    };
    return {
      name: name3,
      __protected__: {
        getInstance,
        insertWidgetLib
      }
    };
  })();
  pn.container.register("recWidgetService", {
    useValue: recWidgetService
  });
  pn.recWidgetService = pn.container.resolve("recWidgetService");

  // ../src/lib/piano.ts
  var piano = (() => {
    const predefinedOptions = pn.container.resolve("predefinedOptions");
    let testPianoOption = "";
    return {
      testPianoOption
    };
  })();
  pn.container.register("piano", {
    useValue: piano
  });
  var pianoInst = pn.container.resolve("piano");
  for (let keyField in pianoInst) {
    pn[keyField] = pianoInst[keyField];
  }

  // ../src/lib/pianoEsp.ts
  var pianoEsp = (container = pn.container) => {
    const util2 = container.resolve("util");
    const user2 = container.resolve("user");
    const api2 = container.resolve("api");
    const jqUtils2 = container.resolve("jqUtils");
    const consent4 = container.resolve("consent");
    const analytics2 = container.resolve("analytics");
    const recWidgetService2 = container.resolve("recWidgetService");
    const name3 = "pianoEsp";
    const MAILING_LIST_KEY = "__pnml";
    const NOTIFICATION_PERMISSION_DENIED = "_pnpd";
    let initPromise;
    const USER_PROVIDERS_INIT_TIMEOUT = 300;
    const NOTIFICATION_STATUS = {
      granted: "ALLOWED",
      default: "UNKNOWN",
      denied: "FORBIDDEN"
    };
    const recWidget = recWidgetService2.__protected__.getInstance();
    setTimeout(() => {
      pn.addHandler("logout", () => {
        saveCompleteMailingLists([]);
      });
      var provider = user2.getProvider();
      if (provider.registerCallback) {
        provider.registerCallback("logout", () => {
          saveCompleteMailingLists([]);
        });
      }
    }, USER_PROVIDERS_INIT_TIMEOUT);
    function requestPianoEspSdk() {
      return new Promise((resolve, reject) => {
        window.PianoESPConfig = __spreadProps(__spreadValues({}, window.PianoESPConfig || {}), {
          onload: resolve,
          widget_init_on_event: {
            "rec": true,
            "opt-in": false
          },
          onclick: (data) => {
            recWidget.fireWidgetCallback("click", data.widgetId, data);
          },
          onwidgetinit: (data) => {
            recWidget.fireWidgetCallback("init", data.widgetId, data);
          },
          onrecsloaded: (data) => {
            recWidget.fireWidgetCallback("recsloaded", data.widgetId, data);
          }
        });
        util2.debug("pianoESP: loading PianoESP with config:", window.PianoESPConfig);
        recWidgetService2.__protected__.insertWidgetLib({
          id: "pnesplucidsdksel",
          src: _getRootEndpoint() + "/public/sdk/v04/sdk.js?v=" + (localStorage && localStorage.lucidsdkver || "xxx"),
          onerror: reject
        });
      });
    }
    function init() {
      if (initPromise) {
        return initPromise;
      }
      initPromise = new Promise((resolve, reject) => {
        var _a;
        const onLoad = () => resolve(null);
        if ((_a = window.PianoESPConfig) == null ? void 0 : _a.id) {
          requestPianoEspSdk().then(onLoad, reject);
        } else {
          const MAX_WAITING_TIME_FOR_FUSION_ID = 5e3;
          const INTERVAL_FOR_FUSION_ID_CHECK = 500;
          let counter = 0;
          const intervalId = setInterval(() => {
            var _a2;
            if ((_a2 = window.PianoESPConfig) == null ? void 0 : _a2.id) {
              requestPianoEspSdk().then(onLoad, reject);
              clearInterval(intervalId);
              return;
            }
            if (counter >= MAX_WAITING_TIME_FOR_FUSION_ID) {
              clearInterval(intervalId);
              reject();
              return;
            }
            counter += INTERVAL_FOR_FUSION_ID_CHECK;
          }, INTERVAL_FOR_FUSION_ID_CHECK);
        }
      });
      return initPromise;
    }
    const setVisitorId = (visitorId) => {
      window.PianoESPConfig = Object.assign({}, window.PianoESPConfig, {
        visitor: visitorId
      });
    };
    const _getRootEndpoint = () => {
      var rootEndpoint = "//api-esp.piano.io";
      if (pn.espEndpoint) {
        rootEndpoint = pn.espEndpoint.replace(/^http[s]*:/, "");
      } else if (pn.isSandbox()) {
        rootEndpoint = "//sandbox-api-esp.piano.io";
      }
      return (window.location.protocol === "https:" ? "https:" : "http:") + rootEndpoint;
    };
    const showRecommendation = (widgetConfig) => {
      var widgetCallbacks = getWidgetCallbacks();
      recWidget.showRecommendation({
        widgetConfig,
        widgetCallbacks,
        createPlaceholderFn: getPlaceholderFn(widgetConfig.placeholder)
      });
      return init().then(() => {
        window.PianoESP.initWidget(parseInt(widgetConfig.widgetId));
      });
    };
    const _requestPushNotifyPermission = (pushListId, trackingId) => {
      init().then(() => {
        window.PianoESP.getCurrentPushState().then((state) => {
          if (state === "prompt") {
            analytics2.log.event({
              eventType: "logMicroConversion" /* LOG_MICRO_CONVERSION */,
              payload: {
                trackingId,
                eventGroupId: "showPrompt"
              }
            });
          }
        });
        window.PianoESP.subscribeToPushSquads([pushListId]).then((response) => {
          var resp = response || {};
          if (resp.result === true) {
            util2.setPushListsCookie(pushListId);
            util2.debug("pianoESP: Push notification was set:", resp);
            analytics2.log.event({
              eventType: "logMicroConversion" /* LOG_MICRO_CONVERSION */,
              payload: {
                trackingId,
                eventGroupId: "enrollPushCampaign"
              }
            });
          } else if (resp.result === false) {
            if (resp.reason === "closed") {
              analytics2.log.event({
                eventType: "logMicroConversion" /* LOG_MICRO_CONVERSION */,
                payload: {
                  trackingId,
                  eventGroupId: "closePrompt"
                }
              });
            } else {
              analytics2.log.event({
                eventType: "logMicroConversion" /* LOG_MICRO_CONVERSION */,
                payload: {
                  trackingId,
                  eventGroupId: "declineEnrollPushCampaign"
                }
              });
            }
          }
        }).catch((err) => {
          util2.log("pianoESP: Push notification error:", err);
        });
      });
    };
    const composerNotification = (() => {
      const _getCookieOptions = () => {
        const options = {
          expires: 730,
          path: "/"
        };
        if (pn.cookieDomain) {
          options.domain = pn.cookieDomain;
        }
        if (pn.cookiePath) {
          options.path = pn.cookiePath;
        }
        return options;
      };
      const _reset = () => util2.deleteCookie(NOTIFICATION_PERMISSION_DENIED, pn.cookieDomain, pn.cookiePath);
      const _block = () => {
        const windowPermission = getWindowNotificationPermission();
        if (windowPermission !== "denied") {
          util2.__protected__.setCookieConsent("composer", NOTIFICATION_PERMISSION_DENIED, windowPermission, _getCookieOptions());
        } else {
          _reset();
        }
      };
      const _get = () => util2.__protected__.getCookie(NOTIFICATION_PERMISSION_DENIED) || null;
      setTimeout(() => {
        const prevPermission = _get();
        if (!prevPermission) {
          return;
        }
        if (getWindowNotificationPermission() !== prevPermission) {
          _reset();
        }
      }, 100);
      return {
        block: _block,
        reset: _reset,
        get: _get
      };
    })();
    const showPushSignup = (pushSignupConfig) => {
      var config = pushSignupConfig || {};
      if (config.templateId) {
        analytics2.log.event({
          eventType: "logCustomFormImpression" /* LOG_CUSTOM_FORM_IMPRESSION */,
          payload: {
            trackingId: config.trackingId,
            formName: "pushSignup",
            source: "show_form"
          }
        });
        pn.template.show(__spreadProps(__spreadValues({}, config), {
          customEvent: (event) => {
            switch (event.eventName) {
              case "push-allow":
                analytics2.log.event({
                  eventType: "logMicroConversion" /* LOG_MICRO_CONVERSION */,
                  payload: {
                    trackingId: config.trackingId,
                    eventGroupId: "allowSoftEnrollPushCampaign"
                  }
                });
                composerNotification.reset();
                _requestPushNotifyPermission(config.pushListId, config.trackingId);
                break;
              case "push-dont-allow":
                analytics2.log.event({
                  eventType: "logMicroConversion" /* LOG_MICRO_CONVERSION */,
                  payload: {
                    trackingId: config.trackingId,
                    eventGroupId: "declineSoftEnrollPushCampaign"
                  }
                });
                composerNotification.block();
                break;
              case "push-close":
                analytics2.log.event({
                  eventType: "logMicroConversion" /* LOG_MICRO_CONVERSION */,
                  payload: {
                    trackingId: config.trackingId,
                    eventGroupId: "close"
                  }
                });
                composerNotification.block();
                break;
            }
          }
        }));
      } else {
        _requestPushNotifyPermission(config.pushListId, config.trackingId);
      }
    };
    const getWindowNotificationPermission = () => {
      if (!window.Notification) {
        return "default";
      }
      return window.Notification.permission;
    };
    const getNotificationStatus = () => {
      const customStatus = composerNotification.get() ? NOTIFICATION_STATUS.denied : null;
      const permission = getWindowNotificationPermission();
      return customStatus || NOTIFICATION_STATUS[permission];
    };
    const saveCompleteMailingLists = (mailingLists) => {
      try {
        var data = JSON.stringify(mailingLists);
        if (consent4.composer) {
          consent4.composer.localStorage.set(MAILING_LIST_KEY, data);
        } else {
          localStorage.setItem(MAILING_LIST_KEY, data);
        }
      } catch (e) {
        util2.debug("can't save mailing lists to storage", e);
      }
    };
    const loadCompleteMailingLists = () => {
      var data = [];
      try {
        const strMailingListKey = localStorage.getItem(MAILING_LIST_KEY);
        if (!strMailingListKey) {
          return [];
        }
        data = JSON.parse(strMailingListKey);
        if (!Array.isArray(data)) {
          throw new Error("MAINLING_LIST should be array");
        }
      } catch (e) {
        util2.debug("can't load mailing lists from storage", e);
      }
      return data || [];
    };
    const showNewsletterSignup = (config) => {
      if (!config || !config.mailingListIds) {
        util2.log("mailingListIds should be specified");
        return;
      }
      var storedMailingLists = loadCompleteMailingLists();
      var IfFilled = storedMailingLists.indexOf(config.mailingListIds) > -1;
      if (config.notShowIfFilled && IfFilled) {
        util2.log("Mailing list with ids " + config.mailingListIds + " already shown");
      } else {
        pn.template.show(config);
      }
    };
    function offerMessageReceiver(message) {
      switch (message.event) {
        case "newsletterSignupSubmission":
          var storedMailingLists = loadCompleteMailingLists();
          if (storedMailingLists.indexOf(message.params.mailingListIds) === -1) {
            storedMailingLists.push(message.params.mailingListIds);
            saveCompleteMailingLists(storedMailingLists);
          }
          break;
      }
    }
    ;
    const getPlaceholderFn = (holdername) => {
      return () => {
        const pnespwgtplaceholder = document.createElement("pnespwgtplaceholder");
        jqUtils2.setAttr("holdername", holdername, pnespwgtplaceholder);
        return pnespwgtplaceholder;
      };
    };
    function getWidgetCallbacks() {
      return {
        onrecsloaded: function(widget) {
          return function(data) {
            if (data.countOfRecs === 0) {
              recWidget.closeWidget({ widget, skipOnclose: true });
              return;
            }
            recWidget.fixWidgetModalWidth(widget, true);
            analytics2.log.event({
              eventType: "logEspMicroConversion" /* LOG_ESP_MICRO_CONVERSION */,
              payload: {
                trackingId: widget.trackingId,
                espWidgetId: widget.widgetId,
                eventGroupId: "init",
                eventType: "EXTERNAL_EVENT" /* EXTERNAL_EVENT */
              }
            });
            util2.debug("creating recommendation widget: ", widget.config);
          };
        },
        onclick: function(widget) {
          return function(data) {
            var event_params = {
              href: data.url
            };
            analytics2.log.event({
              eventType: "logEspMicroConversion" /* LOG_ESP_MICRO_CONVERSION */,
              payload: {
                trackingId: widget.trackingId,
                espWidgetId: widget.widgetId,
                eventGroupId: "click",
                eventType: "EXTERNAL_LINK" /* EXTERNAL_LINK */,
                customParams: event_params
              }
            });
          };
        },
        onclose: function(widget) {
          return () => {
            var event_params = {
              event: "widgetClosed"
            };
            analytics2.log.event({
              eventType: "logEspMicroConversion" /* LOG_ESP_MICRO_CONVERSION */,
              payload: {
                trackingId: widget.trackingId,
                espWidgetId: widget.widgetId,
                eventGroupId: "close",
                eventType: "EXTERNAL_EVENT" /* EXTERNAL_EVENT */,
                customParams: event_params
              }
            });
          };
        }
      };
    }
    function removeWidgetsAndSdk() {
      recWidget.clearWidgets();
      initPromise = null;
      delete window.PianoESP;
    }
    ;
    function onInit(callback) {
      if (!initPromise) {
        return;
      }
      if (typeof callback === "function") {
        initPromise.then(callback);
      }
    }
    ;
    return {
      name: name3,
      __protected__: {
        init,
        setVisitorId,
        showRecommendation,
        showPushSignup,
        getNotificationStatus,
        showNewsletterSignup,
        offerMessageReceiver,
        loadCompleteMailingLists
      },
      __private__: {
        removeWidgetsAndSdk,
        getWidgetCallbacks,
        onInit
      }
    };
  };
  pn.container.register("pianoEsp", {
    useValue: pianoEsp()
  });
  pn.pianoEsp = pn.container.resolve("pianoEsp");

  // ../src/lib/swg.ts
  var swg = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const user2 = pn.container.resolve("user");
    const util2 = pn.container.resolve("util");
    const eventUtils2 = pn.container.resolve("eventUtils");
    const containerUtils2 = pn.container.resolve("containerUtils");
    const name3 = "swg";
    const EXTERNAL_CHECKOUT_COMPLETE_EVENT = "externalCheckoutComplete";
    const SwgUiFlows = {
      LOGIN_PROMPT: "loginPrompt",
      DEFERRED_ACCOUNT_CREATION: "deferredAccountCreation",
      BUY: "buy"
    };
    const eventManager = eventUtils2.createEventManager([
      EXTERNAL_CHECKOUT_COMPLETE_EVENT
    ]);
    const modalOpenCookieName = "__gom";
    let entitlementsLoaded = false;
    let onPaymentResponseTriggered = false;
    let swgTermId;
    let saveSubscriptionProcessStarted = false;
    let allEntitlements = [];
    window.SWG = window.SWG || [];
    window.SWG.push((subscriptions) => {
      subscriptions.setOnPaymentResponse((subscriptionPromise) => {
        if (onPaymentResponseTriggered) {
          return;
        }
        util2.debug("swg: onPaymentResponse is triggered");
        onPaymentResponseTriggered = true;
        subscriptionPromise.then((response) => {
          util2.debug("swg: onPaymentResponse", response);
          if (!swgTermId) {
            return;
          }
          completeSubscribeResponse(response, response.purchaseData, response.userData, subscriptions, swgTermId, SwgUiFlows.BUY);
        }).catch(function(e) {
          util2.log("swg: onPaymentResponse failed", e);
        });
      });
    });
    postmessage2.subscribe("swgCheckoutStart", (event) => {
      if (!entitlementsLoaded) {
        util2.log("swg: incorrect SwG configuration. Please make sure that Experience user segment is configured properly. Details at https://docs.piano.io/subscribe-with-google/#SwGscript");
      }
      var sku = event.params.sku;
      swgTermId = event.params.termId;
      window.SWG.push(function(subscriptions) {
        subscriptions.subscribe(sku);
      });
    });
    const setOpenedModalCookie = (eventType) => {
      util2.__protected__.setCookieConsent("vx", modalOpenCookieName, eventType, {
        expires: 30,
        path: "/"
      });
    };
    const isModalCookieSet = (eventType) => {
      return util2.__protected__.getCookie(modalOpenCookieName) && util2.__protected__.getCookie(modalOpenCookieName).includes(eventType);
    };
    const initSwgFlow = () => {
      window.SWG.push((subscriptions) => {
        subscriptions.getEntitlements().then((entitlements) => {
          entitlementsLoaded = true;
          util2.debug("swg: getEntitlements", entitlements);
          if (entitlements.enablesThis()) {
            const entitlementInGoogle = entitlements.getEntitlementForSource("google");
            allEntitlements = entitlements.entitlements;
            if (!entitlementInGoogle) {
              if (allEntitlements) {
                checkExternalEntitlement(allEntitlements).then(() => {
                  util2.debug("swg: checkExternalEntitlement");
                  entitlements.ack();
                }, () => {
                  util2.log("swg: checkExternalEntitlement failed");
                });
              }
              return;
            }
            checkSubscription(entitlementInGoogle).then((response) => {
              if (onPaymentResponseTriggered) {
                util2.debug("swg: onPaymentResponse is already triggered. Skipping entitlements flow.");
                return;
              }
              if (!response) {
                return;
              }
              switch (response.type) {
                case "USER_FOUND":
                  if (user2.isUserValid()) {
                    util2.error("swg: user found, but not valid");
                    return;
                  }
                  util2.debug("swg: user found, initiate login prompt");
                  var userToken = response.user_token;
                  if (isModalCookieSet(response.type)) {
                    return;
                  }
                  subscriptions.showLoginPrompt().then(() => {
                    loginByToken(userToken);
                    fireExternalCheckoutCompleteCallback(SwgUiFlows.LOGIN_PROMPT);
                  }).catch((e) => {
                    setOpenedModalCookie(response.type);
                    util2.log("swg: showLoginPrompt failed", e);
                  });
                  break;
                case "TERM_FOUND":
                  util2.debug("swg: term found, initiate deferred account creation");
                  var termId = response.term_id;
                  subscriptions.completeDeferredAccountCreation({
                    entitlements,
                    consent: true
                  }).then((response2) => {
                    util2.debug("swg: completeDeferredAccountCreation", response2);
                    completeSubscribeResponse(response2, response2.purchaseData, response2.userData, subscriptions, termId, SwgUiFlows.DEFERRED_ACCOUNT_CREATION);
                  }).catch((e) => {
                    util2.log("swg: completeDeferredAccountCreation failed", e);
                  });
                  break;
                default:
                  util2.debug("swg: check subscription response type " + response.type + ". Nothing to do");
              }
            }, () => {
              util2.log("swg: checkSubscription failed");
            });
            entitlements.ack();
          }
        }).catch((e) => {
          util2.log("swg: get entitlements failed", e);
        });
      });
      saveSubscriptionOnCheckoutEvents();
    };
    const fireExternalCheckoutCompleteCallback = (uiFlow) => {
      if (eventManager.hasCallback(EXTERNAL_CHECKOUT_COMPLETE_EVENT)) {
        var params = {
          type: "swg",
          flow: uiFlow
        };
        eventManager.fireCallbacks(EXTERNAL_CHECKOUT_COMPLETE_EVENT, params, void 0, true);
      }
    };
    const getPianoSubscriptions = (token) => {
      let method = "/swg/sync";
      if (user2.getProvider().getName() === "piano_id_lite") {
        method += "/external";
      }
      return new Promise((resolve, reject) => {
        pn.api.callApi(method, {
          aid: pn.aid,
          "access_token": token
        }, (response) => {
          var _a;
          if (response.code !== 0) {
            reject();
          }
          resolve((_a = response.SwgResponse) != null ? _a : { products: [] });
        });
      });
    };
    const sendSaveSubscriptionRequest = (token) => {
      window.SWG.push((subscriptions) => {
        subscriptions.saveSubscription(() => ({ token })).then((result) => {
          !result && util2.log("swg: save subscription process was stopped");
        });
      });
    };
    const getProductsInGoogle = () => {
      return allEntitlements.reduce((acc, entitlement) => {
        return acc.concat(entitlement.products);
      }, []);
    };
    const getAccessDiff = (pianoProducts) => {
      let hasDiff = false;
      const productsInGoogle = getProductsInGoogle();
      for (let i = 0; i < pianoProducts.length; i++) {
        if (productsInGoogle.indexOf(pianoProducts[i]) === -1) {
          hasDiff = true;
          break;
        }
      }
      return hasDiff;
    };
    const saveSubscription = (userToken) => {
      if (!entitlementsLoaded || saveSubscriptionProcessStarted) {
        return;
      }
      const token = userToken || user2.getProvider().getToken();
      if (!token) {
        return;
      }
      saveSubscriptionProcessStarted = true;
      getPianoSubscriptions(token).then((accessList) => accessList.products && getAccessDiff(accessList.products)).then((hasAccessDiff) => {
        hasAccessDiff && sendSaveSubscriptionRequest(token);
        saveSubscriptionProcessStarted = false;
      }).catch((error) => {
        util2.log("swg: save subscription flow failed with error - ", error);
        saveSubscriptionProcessStarted = false;
      });
    };
    const saveSubscriptionOnModalClose = () => {
      saveSubscription();
      postmessage2.unsubscribe("purge", saveSubscriptionOnModalClose);
    };
    const saveSubscriptionOnCheckoutEvents = () => {
      postmessage2.subscribe("loginSuccess", (event) => {
        if (containerUtils2.hasModalIframe()) {
          postmessage2.subscribe("purge", saveSubscriptionOnModalClose);
          return;
        }
        const userToken = event.params.token || event.params.user_token;
        saveSubscription(userToken);
      });
      postmessage2.subscribe("purge", (event) => {
        if (event.params && event.params.completePayment) {
          saveSubscription();
        }
      });
    };
    const checkSubscription = (entitlement) => {
      return new Promise((resolve, reject) => {
        pn.api.callApi("/swg/check", {
          entitlement: JSON.stringify(entitlement)
        }, (rspData) => {
          if (rspData.code !== 0) {
            util2.log("swg: check subscription response - " + rspData.message);
            reject();
          }
          resolve(rspData.CheckSubscriptionResponse);
        });
      });
    };
    const checkExternalEntitlement = (entitlements) => {
      return new Promise((resolve, reject) => {
        pn.api.callApi("/swg/check/external", {
          entitlements: JSON.stringify(entitlements)
        }, (rspData) => {
          if (rspData.code !== 0) {
            util2.log("swg: check external entitlement response - " + rspData.message);
            reject();
          }
          var data = rspData.data;
          if (!data) {
            util2.log("swg: check external entitlement empty response");
            reject();
          }
          resolve(data);
        });
      });
    };
    const reloadEntitlements = (subscriptions) => {
      subscriptions.reset().then(() => subscriptions.getEntitlements()).then((entitlements) => {
        util2.debug("swg: reload entitlements - ", entitlements.entitlements);
      }).catch((reason) => {
        util2.debug("swg: entitlements reload failed - ", reason);
      });
    };
    const completeSubscribeResponse = (response, purchaseData, userData, subscriptions, termId, uiFlow) => {
      pn.api.callApi("/swg/subscribe", {
        term_id: termId,
        purchase_data: JSON.stringify(purchaseData),
        user_data: JSON.stringify(userData)
      }, (rspData) => {
        if (!rspData) {
          util2.log("swg: empty response");
        } else if (rspData.code !== 0) {
          reloadEntitlements(subscriptions);
          util2.log("swg: subscribe response - " + rspData.message);
          return;
        } else if (rspData.data) {
          loginByToken(rspData.data);
        }
        postmessage2.broadcast("swgCheckoutComplete");
        response.complete().then(() => {
          fireExternalCheckoutCompleteCallback(uiFlow);
        }).catch((e) => {
          util2.log("swg: complete failed:", e);
        });
      });
    };
    const loginByToken = (token) => {
      if (token && user2.getProvider().loginByToken) {
        user2.getProvider().loginByToken(token);
      }
    };
    let markupIsInjected = false;
    const injectMarkup = (markupData) => {
      var _a;
      if (markupIsInjected) {
        return;
      }
      if (markupData) {
        util2.debug("swg: rendering swg markup with config:", markupData);
        var markup = '{\n   "@context": "http://schema.org",\n   "@type": "CreativeWork",\n   "isAccessibleForFree": ' + markupData.isAccessibleForFree;
        if (markupData.isAccessibleForFree === false && markupData.productId) {
          markup = markup + ',\n   "isPartOf": {\n       "@type": ["CreativeWork", "Product"],\n       "name" : "' + markupData.resourceName + '",\n       "productID": "' + markupData.productId + '"\n   }';
        }
        if (markupData.publisherName) {
          markup += `,
   "publisher": {
       "@type": "Organization",
       "name": "${markupData.publisherName}"
   }`;
        }
        markup = markup + "\n}";
        var markupScriptElement = document.createElement("script");
        markupScriptElement.type = "application/ld+json";
        markupScriptElement.innerHTML = markup;
        (_a = document.getElementsByTagName("script")[0].parentNode) == null ? void 0 : _a.appendChild(markupScriptElement);
        markupIsInjected = true;
      }
    };
    let libraryIsAdded = false;
    const addLibrary = () => {
      var _a;
      if (libraryIsAdded) {
        return;
      }
      util2.debug("swg: adding swg.js library");
      var libraryScriptElement = document.createElement("script");
      libraryScriptElement.type = "text/javascript";
      libraryScriptElement.setAttribute("subscriptions-control", "manual");
      libraryScriptElement.async = true;
      libraryScriptElement.src = "https://news.google.com/swg/js/v1/swg.js";
      (_a = document.getElementsByTagName("script")[0].parentNode) == null ? void 0 : _a.appendChild(libraryScriptElement);
      libraryIsAdded = true;
    };
    const registerCallback = (event, callback) => {
      eventManager.addEvent(event);
      eventManager.registerCallback(event, callback);
    };
    return {
      name: name3,
      __protected__: {
        injectMarkup,
        addLibrary,
        initSwgFlow
      },
      registerCallback
    };
  })();
  pn.container.register("swg", {
    useValue: swg
  });
  pn.swg = pn.container.resolve("swg");

  // ../src/lib/fbsubscriptions.ts
  var fbsubscriptions = (() => {
    const util2 = pn.container.resolve("util");
    const analytics2 = pn.container.resolve("analytics");
    const offer2 = pn.container.resolve("offer");
    const user2 = pn.container.resolve("user");
    const api2 = pn.container.resolve("api");
    const name3 = "fbsubscriptions";
    let _isInitialized = false;
    let signedSubscriptionPayload = "";
    const sentEvents = {};
    const sentCustomEvents = {};
    const init = () => {
      if (_isInitialized) {
        return;
      }
      analytics2.fbpixel.initialize();
      offer2.registerCallback("loaded", () => {
        var surfaceParameter = util2.getQueryParamByName("surface");
        if ((surfaceParameter === "meter_limit_reached" || surfaceParameter === "locked_article") && !pn.inappBrowserReturn) {
          trackCustomEvent("ViewPaywall", { surface: "IA" });
        }
      });
      var loginSuccessCallback = (params) => {
        _generateAndSignSubscriptionPayload().then(() => {
          if (params.registration) {
            trackCustomEvent("CreateAccount");
          } else {
            trackCustomEvent("LogIntoAccount", { is_subscriber: !!signedSubscriptionPayload });
          }
          if (!!signedSubscriptionPayload) {
            setTimeout(() => {
              _redirectToFacebook();
            }, 200);
          }
        });
      };
      var experienceExecuteActionHandler = () => {
        if (user2.isUserValid()) {
          _redirectIfUserHasAccess();
        }
      };
      pn.addHandler("loginSuccess", loginSuccessCallback);
      pn.addHandler("experienceExecute", experienceExecuteActionHandler);
      offer2.registerCallback("alreadyPurchased", (params) => {
        _checkResourceAccess(params.rid);
      });
      offer2.registerCallback("startCheckout", (params) => {
        trackEvent("InitiateCheckout", {
          offer_code: params.offerId,
          campaign_code: params.termId
        });
      });
      offer2.registerCallback("complete", (params) => {
        if (params.hasOwnProperty("chargeCurrency") && params.hasOwnProperty("chargeAmount")) {
          trackEvent("Purchase", {
            currency: params.chargeCurrency,
            value: params.chargeAmount,
            offer_code: params.offerId,
            campaign_code: params.termId
          });
        }
        _checkResourceAccess(params.rid);
      });
      offer2.registerCallback("close", () => {
        _redirectToFacebook();
      });
      _isInitialized = true;
    };
    function resolveTimeout() {
      return new Promise(function(resolve) {
        setTimeout(function() {
          resolve(null);
        }, pn.redirectToFbTimeout * 1e3);
      });
    }
    function _generateAndSignSubscriptionPayload(rid) {
      return new Promise(function(resolve) {
        var requestParams = {
          aid: pn.aid,
          rid: "",
          account_linking_token: util2.getQueryParamByName("account_linking_token"),
          user_token: user2.getProvider().getToken(),
          user_provider: user2.getProvider().getName()
        };
        if (rid) {
          requestParams.rid = rid;
        }
        api2.callApi("/fbia/subscriptionPayload/generate", requestParams, function(response) {
          if (response && response.data) {
            signedSubscriptionPayload = response.data;
          }
          resolve(null);
        });
      });
    }
    const _redirectIfUserHasAccess = () => {
      _generateAndSignSubscriptionPayload().then(() => {
        if (signedSubscriptionPayload) {
          _redirectToFacebook();
        }
      });
    };
    const _checkResourceAccess = (rid) => {
      if (!rid) {
        util2.error("fbsubscriptions: 'rid' could not be empty on generating subscription payload");
        return;
      }
      var timerPromise = resolveTimeout();
      var generatePayloadPromise = _generateAndSignSubscriptionPayload(rid);
      util2.__protected__.waitAllPromises([timerPromise, generatePayloadPromise]).then(() => {
        _redirectToFacebook();
      });
    };
    const _redirectToFacebook = () => {
      var accountLinkingToken = util2.getQueryParamByName("account_linking_token");
      var redirectUri = util2.getQueryParamByName("redirect_uri") + "?account_linking_token=" + encodeURIComponent(accountLinkingToken);
      if (signedSubscriptionPayload) {
        redirectUri += "&subscription_payload=" + encodeURIComponent(signedSubscriptionPayload);
      }
      window.location.href = redirectUri;
    };
    const checkUserAccessAndRedirectToFb = () => {
      _generateAndSignSubscriptionPayload().then(() => {
        _redirectToFacebook();
      });
    };
    const trackEvent = (eventName, eventParams) => {
      if (sentEvents[eventName]) {
        return;
      }
      sentEvents[eventName] = true;
      analytics2.fbpixel.event({ eventType: "track" /* TRACK_EVENT */, payload: { eventName, eventParams } });
    };
    const trackCustomEvent = (eventName, eventParams) => {
      if (sentCustomEvents[eventName]) {
        return;
      }
      sentCustomEvents[eventName] = true;
      analytics2.fbpixel.event({ eventType: "trackCustom" /* TRACK_CUSTOM_EVENT */, payload: { eventName, eventParams } });
    };
    const isInitialized = () => {
      return _isInitialized;
    };
    return {
      name: name3,
      checkUserAccessAndRedirectToFb,
      isInitialized,
      __private__: {
        isInitialized
      },
      __protected__: {
        init
      }
    };
  })();
  pn.container.register("fbsubscriptions", {
    useValue: fbsubscriptions
  });
  pn.fbsubscriptions = pn.container.resolve("fbsubscriptions");

  // ../src/lib/cxense.ts
  var cxense = (container = pn.container) => {
    const jqUtils2 = container.resolve("jqUtils");
    const util2 = container.resolve("util");
    const analytics2 = container.resolve("analytics");
    const recWidgetService2 = container.resolve("recWidgetService");
    const name3 = "cxense";
    const recWidget = recWidgetService2.__protected__.getInstance();
    const alreadyDisplayed = [];
    const setSiteId = () => {
      const siteId = pn.cxenseSiteId;
      util2.debug("c1x: setting siteId: ", siteId);
      window.cX.setSiteId(siteId);
    };
    const getC1XIntegrationVersion = () => {
      if (typeof pn.c1XIntegrationVersion !== "undefined" && pn.cxenseSiteId !== "") {
        return pn.c1XIntegrationVersion;
      } else {
        return "N/A";
      }
    };
    const getCxCdnUrl = () => {
      if (typeof pn.cxCdnUrl !== "undefined" && pn.cxCdnUrl !== "") {
        return pn.cxCdnUrl;
      } else {
        return "https://cdn.cxense.com";
      }
    };
    const isActivated = () => {
      return typeof pn.cxenseSiteId !== "undefined" && pn.cxenseSiteId !== "";
    };
    const _isConfigured = (ignoreCCE) => {
      return typeof window.cX !== "undefined" && typeof window.cX.library !== "undefined" && (ignoreCCE || typeof window.cX.CCE !== "undefined" && typeof window.cX.CCE.library !== "undefined");
    };
    const isCustomerPrefixConfigured = (config) => {
      return typeof config.cxenseCustomerPrefix !== "undefined" && config.cxenseCustomerPrefix !== "";
    };
    const sendPageViewEvent = (config) => {
      let cxAllow = true;
      if (!isActivated() && !isCustomerPrefixConfigured(config)) {
        cxAllow = false;
      }
      if (!isActivated() && isCustomerPrefixConfigured(config)) {
        util2.debug("cxense: can not send pageview because siteId is not configured using `setCxenseSiteId`");
        cxAllow = false;
      }
      if (isActivated() && !isCustomerPrefixConfigured(config)) {
        util2.debug("cxense: can not send pageview because customer prefix is not configured in app settings");
        cxAllow = false;
      }
      sendPageViewEventAndInjectIds(config, cxAllow);
    };
    const sendPageViewEventAndInjectIds = (config, cxAllow) => {
      var _a, _b;
      let userState2 = "anon";
      let debug = (...args) => {
        if (cxAllow) {
          util2.debug.apply(util2, args);
        }
      };
      if (config.uid && config.uid !== "anon" && config.uid !== "") {
        const hasActiveAccess = !!((_b = (_a = config.eventExecutionContext) == null ? void 0 : _a.accessList) == null ? void 0 : _b.length);
        userState2 = hasActiveAccess ? "hasActiveAccess" : "registered";
        debug("c1x: adding externalId", { uid: config.uid, prefix: config.cxenseCustomerPrefix });
      }
      debug("c1x: adding CustomParameters userState", { userState: userState2 });
      debug("c1x: sending pageview event");
      if (userState2 !== "anon") {
        util2.__protected__.setVxUsersToDataLayer({
          [config.uid]: {
            prefix: config.cxenseCustomerPrefix || "",
            type: "VX"
          }
        });
      } else {
        util2.__protected__.setVxUsersToDataLayer(null);
      }
      dataLayer.set("userStatus", userState2);
      if (cxAllow) {
        dataLayer.set("siteId", pn.cxenseSiteId);
        const cX = window.cX = window.cX || {};
        cX.callQueue = cX.callQueue || [];
        cX.callQueue.push(["sendPageViewEvent", { location: pn.customPageUrl || void 0 }]);
      }
    };
    const loadCxLibIfNeeded = () => {
      const callName = "cxLibLoading";
      util2.waitCall(callName, () => {
        var _a;
        if (isActivated() && _isConfigured(true)) {
          return;
        }
        util2.startCall(callName);
        var onLoadTimer;
        var documentScript = document.getElementsByTagName("script")[0];
        var scriptElement = document.createElement("script");
        scriptElement.onerror = (e) => {
          if (onLoadTimer) {
            clearTimeout(onLoadTimer);
          }
          util2.doneCall(callName);
          util2.debug("c1x: error during load of cx.js. ", e);
        };
        scriptElement.onload = () => {
          onLoadTimer = setTimeout(() => {
            util2.doneCall(callName);
          }, 500);
          util2.debug("c1x: cx.js has been successfully loaded");
        };
        scriptElement.async = true;
        scriptElement.type = "text/javascript";
        if (pn.c1XLoadCce) {
          scriptElement.src = getCxCdnUrl() + "/cx.cce.js";
        } else {
          scriptElement.src = getCxCdnUrl() + "/cx.js";
        }
        util2.debug("c1x: start loading cx.js on the page...");
        (_a = documentScript.parentNode) == null ? void 0 : _a.insertBefore(scriptElement, documentScript);
      });
    };
    const _collector = function(fn) {
      let timer = null;
      let batch = [];
      function exec() {
        if (timer) {
          clearTimeout(timer);
        }
        timer = null;
        fn(batch);
        batch = [];
      }
      return function collect(config) {
        if (!timer) {
          timer = setTimeout(exec, 10);
        }
        batch.push(config);
      };
    };
    const _showRecommendation = (configs) => {
      if (!isActivated()) {
        util2.debug("c1x: can not show recommendation because siteId is not configured using `setCxenseSiteId`");
        return;
      }
      const widgets = [];
      for (var index = 0; index < configs.length; index++) {
        const widgetConfig = configs[index] || {};
        const widgetResult = recWidget.showRecommendation({
          widgetConfig,
          createPlaceholderFn: getPlaceholderFn(widgetConfig.widgetId, widgetConfig.displayMode)
        });
        widgetResult && widgets.push({
          widgetParams: {
            widgetId: widgetConfig.widgetId,
            targetElementId: "cxense-" + widgetConfig.widgetId,
            experienceId: widgetConfig.experienceId,
            experienceActionId: widgetConfig.experienceActionId,
            trackingId: widgetConfig.trackingId
          },
          widgetCallback: (cxenseHttpResponse) => {
            var response = cxenseHttpResponse && cxenseHttpResponse.response;
            if (response && !cxenseHttpResponse.response.error) {
              if (widgetConfig.displayMode === "modal") {
                recWidget.fixWidgetModalWidth(recWidget.findWidget(widgetConfig.widgetId));
              }
              for (var index2 = 0; index2 < response.items.length; index2++) {
                const element = response.items[index2].id;
                if (alreadyDisplayed.indexOf(element) === -1) {
                  alreadyDisplayed.push(element);
                }
              }
              analytics2.log.event({
                eventType: "logAutoMicroConversion" /* LOG_AUTO_MICRO_CONVERSION */,
                payload: {
                  trackingId: widgetConfig.trackingId,
                  eventGroupId: "init",
                  eventType: "EXTERNAL_EVENT" /* EXTERNAL_EVENT */,
                  customParams: {
                    source: "CX"
                  }
                }
              });
            }
          }
        });
      }
      invokeCxenseFn(() => {
        setSiteId();
        window.cX.CCE.runMulti(widgets, ["id"], alreadyDisplayed);
      });
    };
    const showRecommendation = _collector(_showRecommendation);
    const clearWidgets = () => {
      recWidget.clearWidgets();
    };
    const getPlaceholderFn = (widgetId, displayMode) => {
      return () => {
        const sxensePlaceholder = document.createElement("div");
        jqUtils2.addClass(`tp-cxense-placeholder-${displayMode}`, sxensePlaceholder);
        jqUtils2.addClass("tp-widget-placeholder", sxensePlaceholder);
        const cxenseWidget = document.createElement("div");
        cxenseWidget.id = `cxense-${widgetId}`;
        sxensePlaceholder.appendChild(cxenseWidget);
        return sxensePlaceholder;
      };
    };
    const invokeCxenseFn = (fn) => {
      window.cX = window.cX || {};
      window.cX.CCE = window.cX.CCE || {};
      window.cX.CCE.callQueue = window.cX.CCE.callQueue || [];
      window.cX.CCE.callQueue.push(["invoke", fn]);
    };
    const isConfiguredSync = (ignoreCCE) => {
      return _isConfigured(ignoreCCE);
    };
    const isConfiguredPollingAsync = (ignoreCCE, pollingInterval, retryCount) => {
      pollingInterval = pollingInterval || 0;
      retryCount = retryCount || 0;
      var retries = 0;
      return new Promise((resolve, reject) => {
        const pollingFunc = () => {
          if (isConfiguredSync(ignoreCCE)) {
            resolve(true);
          } else {
            if (retries >= retryCount) {
              reject(ignoreCCE ? "c1x: cX object is not found after " + retryCount + " retries with " + pollingInterval + "ms interval" : "c1x: cX and cX.CCE objects are not found after " + retryCount + " retries with " + pollingInterval + "ms interval");
            } else {
              retries++;
              setTimeout(pollingFunc, pollingInterval);
            }
          }
        };
        if (isConfiguredSync(ignoreCCE)) {
          resolve(true);
        } else {
          setTimeout(pollingFunc, pollingInterval);
        }
      });
    };
    return {
      name: name3,
      __protected__: {
        showRecommendation,
        clearWidgets,
        sendPageViewEvent,
        isActivated,
        isCustomerPrefixConfigured,
        isConfiguredPollingAsync,
        invokeCxenseFn,
        getC1XIntegrationVersion,
        loadCxLibIfNeeded
      }
    };
  };
  pn.container.register("cxense", {
    useValue: cxense()
  });
  pn.cxense = pn.container.resolve("cxense");

  // ../src/lib/templateInteraction/types.ts
  var FormEventTypeMap = {
    5: "customFormSubmitted",
    6: "customFormSubmitted",
    7: "customFormClosed"
  };
  var EventTypeMap = __spreadValues({
    1: "autoRenewalDisabled",
    2: "subscriptionCancellation",
    3: "dismissTemplate",
    4: "customEvent"
  }, FormEventTypeMap);
  var TEMPLATE_INTERACTION_EVENT = "templateInteractionEvent";
  var FORM_INTERACTION_EVENT = "formInteractionEvent";
  var INTERACTION_METHOD_NAME = "executeTemplateInteraction";
  var INTERACTION_END_POINT = "/xbuilder/experience/" + INTERACTION_METHOD_NAME;
  var FinalConfirmation = "finalConfirmation";
  var TemplateTypesMap = [1];

  // ../src/lib/templateInteraction/utils.ts
  var createCbsById = () => {
    let map = {};
    const add = (id, name3, cb) => {
      if (!map[id]) {
        map[id] = {};
      }
      if (!map[id][name3]) {
        map[id][name3] = [];
      }
      map[id][name3].push(cb);
    };
    const get = (id, name3) => {
      var _a;
      return ((_a = map[id]) == null ? void 0 : _a[name3]) || null;
    };
    const clear = () => {
      map = {};
    };
    return {
      add,
      get,
      clear
    };
  };
  var createCustomRegister = (registerCallback) => {
    let cbsByName = {};
    const cbsById = createCbsById();
    const getCbName = (type2) => EventTypeMap[type2] || type2;
    const on = (type2, id, registeredCb, verifyCb = () => true, skipFirstCall = false) => {
      const cbName = getCbName(type2);
      const cb = {
        cb: registeredCb,
        check: verifyCb,
        skip: skipFirstCall
      };
      if (!cbsByName[cbName]) {
        cbsByName[cbName] = [];
        registerCallback(cbName, (...args) => {
          cbsByName[cbName].forEach((cbWrapper) => cbWrapper.res = null);
          cbsByName[cbName].forEach((cbWrapper) => {
            var _a;
            const { cb: cb2, check, skip } = cbWrapper;
            if (check(...args)) {
              if (skip) {
                cbWrapper.skip = false;
              } else {
                cbWrapper.res = (_a = cb2(...args)) != null ? _a : null;
              }
            }
          });
        });
      }
      if (id) {
        cbsById.add(id, cbName, cb);
      }
      cbsByName[cbName].push(cb);
    };
    const skipOne = (id, type2) => {
      const cbName = getCbName(type2);
      const cbs = cbsById.get(id, cbName);
      cbs == null ? void 0 : cbs.forEach((cb) => {
        cb.skip = true;
      });
      return !!cbs;
    };
    const get = (id, type2) => cbsById.get(id, getCbName(type2));
    const has = (id, type2) => !!get(id, type2);
    return {
      clear: () => {
        Object.keys(cbsByName).forEach((cbName) => {
          cbsByName[cbName] = [];
        });
        cbsById.clear();
      },
      on,
      has,
      get,
      skipOne
    };
  };
  var closeModalWrapper = (closeModal, closeInline) => (selector) => selector !== null ? closeInline(selector) : closeModal();
  var getContinuationFromArg = (args) => (args || {}).continuation || null;
  var getTrackingIdFromArg = (args) => (args || {}).trackingId || null;
  var getExperienceActionIdFromArg = (args) => (args || {}).experienceActionId || null;
  var interactionEvents = [TEMPLATE_INTERACTION_EVENT, FORM_INTERACTION_EVENT];
  var isInteractionEvent = (name3) => interactionEvents.includes(name3);
  var isRootEventType = (eventLocal) => eventLocal.eventType === 1 || eventLocal.eventType === 2;
  var isRootEvent = (eventLocal) => isInteractionEvent(eventLocal.type) && isRootEventType(eventLocal);
  var getRootEvent = (events) => events && events.find(isRootEvent) || null;

  // ../src/lib/templateInteraction/custom-fields.types.ts
  var DataType = /* @__PURE__ */ ((DataType2) => {
    DataType2["TEXT"] = "TEXT";
    DataType2["ISO_DATE"] = "ISO_DATE";
    DataType2["BOOLEAN"] = "BOOLEAN";
    DataType2["NUMBER"] = "NUMBER";
    DataType2["SINGLE_SELECT_LIST"] = "SINGLE_SELECT_LIST";
    DataType2["MULTI_SELECT_LIST"] = "MULTI_SELECT_LIST";
    return DataType2;
  })(DataType || {});

  // ../src/lib/templateInteraction/custom-fields.util.ts
  var getYear = (d) => d.getFullYear();
  var getMonth = (d) => d.getMonth();
  var getDay = (d) => d.getDate();
  var setYear = (d, year) => d.setFullYear(year);
  var number = (v) => Number(v);
  var yearsBetween = (date1, date2) => {
    const oneYear = 1e3 * 60 * 60 * 24 * 365;
    const diff = date1.getTime() - date2.getTime();
    return Math.floor(diff / oneYear);
  };
  var getFirstDateOfYear = (date) => new Date(getYear(date), 0, 1);
  var getLastDateOfYear = (date) => new Date(getYear(date), 11, 31);
  var checkInRangeWithinYear = (fromDate, toDate2, userDate) => {
    const year = getYear(userDate);
    const fromDateWithYear = new Date(fromDate);
    setYear(fromDateWithYear, year);
    const toDateWithYear = new Date(toDate2);
    setYear(toDateWithYear, year);
    return userDate <= toDateWithYear && userDate >= fromDateWithYear;
  };
  var inRangeRegardlessOfYears = (fromDate, toDate2, userDate) => {
    if (fromDate > toDate2) {
      return false;
    }
    if (yearsBetween(fromDate, toDate2) >= 1) {
      return true;
    }
    if (getYear(fromDate) == getYear(toDate2)) {
      return checkInRangeWithinYear(fromDate, toDate2, userDate);
    } else {
      let firstDay = getFirstDateOfYear(toDate2);
      let lastDay = getLastDateOfYear(fromDate);
      let checkRange1 = checkInRangeWithinYear(fromDate, lastDay, userDate);
      let checkRange2 = checkInRangeWithinYear(firstDay, toDate2, userDate);
      return checkRange1 || checkRange2;
    }
  };
  var equalsRegardlessOfYear = (d1, d2) => {
    const year = getYear(d1);
    const fromDateWithYear = new Date(d1);
    setYear(fromDateWithYear, year);
    const toDateWithYear = new Date(d2);
    setYear(toDateWithYear, year);
    return fromDateWithYear.getTime() === toDateWithYear.getTime();
  };
  var timeUnitPlus = (timeUnit, d, units) => {
    if (!timeUnit) {
      return null;
    }
    const date = new Date(d);
    switch (timeUnit) {
      case "days" /* DAYS */:
        date.setDate(getDay(date) + units);
        break;
      case "months" /* MONTHS */:
        date.setMonth(getMonth(date) + units);
        break;
      case "years" /* YEARS */:
        date.setFullYear(getYear(date) + units);
        break;
      case "weeks" /* WEEKS */:
        date.setDate(getDay(date) + units * 7);
        break;
      default:
        break;
    }
    return date;
  };
  var DATE = /^(\d{4})(?:-(\d{2}))?(?:-(\d{2}))?$/;
  var parseDateISO = (date, defaultValue) => {
    if (!date) {
      return defaultValue ? new Date(defaultValue) : null;
    }
    let result;
    if (DATE.test(date)) {
      const [, year, month = "1", day = "1"] = date.match(DATE) || [];
      result = new Date(number(year), number(month) - 1, number(day));
    } else {
      result = new Date(date);
    }
    if (isNaN(result.getTime())) {
      return null;
    }
    return result;
  };
  var getDateNowWithoutTZ = () => {
    const localDate = new Date();
    return new Date(getYear(localDate), getMonth(localDate), getDay(localDate));
  };

  // ../src/lib/templateInteraction/custom-fields.ts
  var notSupported = (operator, type2) => `Not supported operator '${operator}' for ${type2}`;
  var checkCustomFields = (userCustomFields, rules, debug = () => {
  }) => rules.every((rule) => {
    let filteredCustomFields = filterCustomFields(rule, userCustomFields);
    if (!filteredCustomFields.length) {
      debug(`Values of custom fields ${rule.fieldName} is not found`);
      return false;
    } else {
      const ruleResult = filteredCustomFields.some((customField) => checkRule(rule, customField, debug));
      if (!ruleResult) {
        const fieldName = rule.fieldName;
        const fieldValues = filteredCustomFields.map((field) => field.value).join(", ");
        const ruleMath = `"${rule.operator}": ${JSON.stringify(rule.ruleValue)}`;
        debug(`field "${fieldName}":[${fieldValues}] does not match a rule ${ruleMath}`);
        return false;
      }
    }
    return true;
  });
  var typeCheckerMap = {
    ["TEXT" /* TEXT */]: createTextFieldRuleChecker(),
    ["NUMBER" /* NUMBER */]: createNumberFieldRuleChecker(),
    ["ISO_DATE" /* ISO_DATE */]: createDateFieldRuleChecker(),
    ["BOOLEAN" /* BOOLEAN */]: createBooleanValueFieldRuleChecker(),
    ["SINGLE_SELECT_LIST" /* SINGLE_SELECT_LIST */]: createSingleSelectListValueFieldRuleChecker(),
    ["MULTI_SELECT_LIST" /* MULTI_SELECT_LIST */]: createMultiSelectListValueFieldRuleChecker()
  };
  function checkRule(rule, customField, debug) {
    if (!(customField.dataType in DataType)) {
      return false;
    }
    const dataType = customField.dataType;
    const typeChecker = typeCheckerMap[dataType];
    if (!typeChecker) {
      debug(`dataType: ${dataType} is not supported`);
      return false;
    }
    let fieldValue = "";
    try {
      fieldValue = JSON.parse(customField.value || "");
    } catch (e) {
      fieldValue = customField.value || null;
    }
    try {
      return typeChecker(rule, fieldValue, debug);
    } catch (e) {
      return false;
    }
  }
  function filterCustomFields(rule, customFields) {
    try {
      return customFields.filter((field) => field.fieldName === rule.fieldName);
    } catch (e) {
      return [];
    }
  }
  function logIncorrectValueTypeIfNeed(rule, allowedTypes, debug) {
    var _a;
    if (allowedTypes.some((type2) => {
      var _a2;
      return type2 === ((_a2 = rule.ruleValue) == null ? void 0 : _a2.valueType);
    })) {
      return;
    }
    debug(`Incorrect value type '${(_a = rule.ruleValue) == null ? void 0 : _a.valueType}' for operator '${rule.operator}'`);
  }
  var createEmptinessResult = (valueIsEmpty, operator) => {
    const createResult = (result, proceed) => ({
      result,
      proceed
    });
    if (operator === "empty" /* EMPTY */) {
      return createResult(valueIsEmpty, false);
    } else if (operator === "notEmpty" /* NOT_EMPTY */) {
      return createResult(!valueIsEmpty, false);
    } else if (valueIsEmpty) {
      return createResult(valueIsEmpty, true);
    } else {
      return createResult(valueIsEmpty, true);
    }
  };
  function checkEmptiness(value, operator) {
    const valueIsEmpty = typeof value === "string" ? !value.trim() : value === null;
    return createEmptinessResult(valueIsEmpty, operator);
  }
  function checkEmptinessForArray(value, operator) {
    const valueIsEmpty = !value || value.length === 0;
    return createEmptinessResult(valueIsEmpty, operator);
  }
  function createTextFieldRuleChecker() {
    return (rule, value, debug) => {
      var _a, _b;
      const operator = rule.operator;
      const empty2 = checkEmptiness(value, operator);
      if (!empty2.proceed) {
        return empty2.result;
      }
      const userValue = String(value).trim().toLowerCase();
      logIncorrectValueTypeIfNeed(rule, ["stringList" /* STRING_LIST */], debug);
      const ruleValues = (_b = (_a = rule.ruleValue.value) == null ? void 0 : _a.map((it) => {
        return it.trim().toLowerCase();
      })) != null ? _b : [];
      switch (operator) {
        case "matches" /* MATCHES */:
          return ruleValues.some((it) => {
            return userValue === it;
          });
        case "contains" /* CONTAINS */:
          return ruleValues.some((it) => {
            return userValue.includes(it);
          });
        case "notContains" /* NOT_CONTAINS */:
          return ruleValues.every((it) => {
            return !userValue.includes(it);
          });
        default:
          debug(notSupported(operator, "TEXT" /* TEXT */));
          return false;
      }
    };
  }
  function createNumberFieldRuleChecker() {
    return (rule, value, debug) => {
      const operator = rule.operator;
      const empty2 = checkEmptiness(value, operator);
      if (!empty2.proceed) {
        return empty2.result;
      }
      let userValue = parseInt(value, 10);
      if (isNaN(userValue)) {
        debug(`${value} is not a number`);
        return false;
      }
      logIncorrectValueTypeIfNeed(rule, ["number" /* NUMBER */], debug);
      const ruleValue = rule.ruleValue.value;
      switch (operator) {
        case "equals" /* EQUALS */:
          return userValue === ruleValue;
        case "notEquals" /* NOT_EQUALS */:
          return userValue !== ruleValue;
        case "greater" /* GREATER */:
          return userValue > ruleValue;
        case "less" /* LESS */:
          return userValue < ruleValue;
        default:
          debug(notSupported(operator, "TEXT" /* TEXT */));
          return false;
      }
    };
  }
  function createBooleanValueFieldRuleChecker() {
    return (rule, value, debug) => {
      const operator = rule.operator;
      const empty2 = checkEmptiness(value, operator);
      if (!empty2.proceed) {
        return empty2.result;
      }
      logIncorrectValueTypeIfNeed(rule, ["boolean" /* BOOLEAN */], debug);
      const ruleValue = rule.ruleValue.value;
      const userValue = Boolean(value);
      switch (operator) {
        case "equals" /* EQUALS */:
          return userValue === ruleValue;
        default:
          debug(notSupported(operator, "BOOLEAN" /* BOOLEAN */));
          return false;
      }
    };
  }
  function createSingleSelectListValueFieldRuleChecker() {
    return (rule, value, debug) => {
      const operator = rule.operator;
      const userValues = !value ? [] : value;
      if (!Array.isArray(userValues)) {
        debug(`${value} is not an array of string`);
        return false;
      }
      const empty2 = checkEmptinessForArray(userValues, operator);
      if (!empty2.proceed) {
        return empty2.result;
      }
      logIncorrectValueTypeIfNeed(rule, ["stringList" /* STRING_LIST */], debug);
      const ruleValues = rule.ruleValue.value;
      switch (operator) {
        case "equals" /* EQUALS */:
          return (ruleValues == null ? void 0 : ruleValues.length) === 1 && userValues.length === 1 && userValues[0] === ruleValues[0];
        case "notEquals" /* NOT_EQUALS */:
          return userValues.length !== 0 && (!ruleValues || ruleValues.length !== 1 || userValues.length !== 1 || userValues[0] !== ruleValues[0]);
        case "anyOf" /* ANY_OF */:
          return userValues.length !== 0 && (ruleValues ? ruleValues.some((rv) => rv === userValues[0]) : false);
        default:
          debug(notSupported(operator, "SINGLE_SELECT_LIST" /* SINGLE_SELECT_LIST */));
          return false;
      }
    };
  }
  function createMultiSelectListValueFieldRuleChecker() {
    return (rule, value, debug) => {
      const operator = rule.operator;
      let userValues = !value ? [] : value;
      if (!Array.isArray(userValues)) {
        debug(`${value} is not an array of string`);
        return false;
      }
      const emptinessResult = checkEmptinessForArray(userValues, operator);
      if (!emptinessResult.proceed) {
        return emptinessResult.result;
      }
      logIncorrectValueTypeIfNeed(rule, ["stringList" /* STRING_LIST */], debug);
      const ruleValues = rule.ruleValue.value;
      switch (operator) {
        case "equals" /* EQUALS */:
          return (userValues == null ? void 0 : userValues.length) > 0 && userValues.length === (ruleValues == null ? void 0 : ruleValues.length) && userValues.every((val) => ruleValues.includes(val));
        case "notEquals" /* NOT_EQUALS */:
          return userValues.length > 0 && (userValues.length !== (ruleValues == null ? void 0 : ruleValues.length) || !userValues.every((val) => ruleValues.includes(val)));
        case "anyOf" /* ANY_OF */:
          return ruleValues ? userValues.some((val) => ruleValues.includes(val)) : false;
        default:
          debug(notSupported(operator, "MULTI_SELECT_LIST" /* MULTI_SELECT_LIST */));
          return false;
      }
    };
  }
  function createDateFieldRuleChecker() {
    return (rule, value, debug) => {
      var _a, _b;
      const operator = rule.operator;
      const empty2 = checkEmptiness(value, operator);
      if (!empty2.proceed) {
        return empty2.result;
      }
      const userValue = parseDateISO(value, null);
      if (!userValue) {
        debug(`${value} is not an ISO date`);
        return false;
      }
      const now = getDateNowWithoutTZ();
      let singleDate = null;
      let fromDate = null;
      let toDate2 = null;
      let regardlessOfYear = false;
      if (operator === "occursBefore" /* OCCURS_BEFORE */ || operator === "occursAfter" /* OCCURS_AFTER */) {
        logIncorrectValueTypeIfNeed(rule, ["date" /* DATE */], debug);
        singleDate = parseDateISO((_a = rule.ruleValue) == null ? void 0 : _a.value, now);
      }
      if (operator === "occursOn" /* OCCURS_ON */) {
        logIncorrectValueTypeIfNeed(rule, ["date" /* DATE */, "relativeDate" /* RELATIVE_DATE */], debug);
        const relativeDateValue = rule.ruleValue;
        const dateValue = rule.ruleValue;
        if (relativeDateValue.timeUnit || relativeDateValue.regardlessOfYears) {
          regardlessOfYear = (_b = relativeDateValue.regardlessOfYears) != null ? _b : false;
          singleDate = timeUnitPlus(relativeDateValue.timeUnit, now, relativeDateValue.timeType === "ago" /* AGO */ ? -relativeDateValue.timeUnitNumber : +relativeDateValue.timeUnitNumber);
        } else {
          singleDate = parseDateISO(dateValue == null ? void 0 : dateValue.value, now);
        }
      }
      if (operator === "occursWithin" /* OCCURS_WITHIN */ || operator === "notOccurWithin" /* NOT_OCCURS_WITHIN */) {
        logIncorrectValueTypeIfNeed(rule, ["dateRange" /* DATE_RANGE */, "relativeDateRange" /* RELATIVE_DATE_RANGE */], debug);
        const relativeDateRangeValue = rule.ruleValue;
        if (relativeDateRangeValue.fromTimeType || relativeDateRangeValue.toTimeUnit) {
          regardlessOfYear = relativeDateRangeValue.regardlessOfYears;
          fromDate = timeUnitPlus(relativeDateRangeValue.fromTimeUnit, now, relativeDateRangeValue.fromTimeType === "ago" /* AGO */ ? -relativeDateRangeValue.fromTimeUnitNumber : +relativeDateRangeValue.fromTimeUnitNumber);
          toDate2 = timeUnitPlus(relativeDateRangeValue.toTimeUnit, now, relativeDateRangeValue.toTimeType === "ago" /* AGO */ ? -relativeDateRangeValue.toTimeUnitNumber : +relativeDateRangeValue.toTimeUnitNumber);
        } else {
          const dateRangeValue = rule.ruleValue;
          fromDate = parseDateISO(dateRangeValue == null ? void 0 : dateRangeValue.from, now);
          toDate2 = parseDateISO(dateRangeValue == null ? void 0 : dateRangeValue.to, now);
        }
      }
      switch (operator) {
        case "occursBefore" /* OCCURS_BEFORE */:
          return userValue < singleDate;
        case "occursAfter" /* OCCURS_AFTER */:
          return userValue > singleDate;
        case "occursOn" /* OCCURS_ON */:
          if (regardlessOfYear) {
            return equalsRegardlessOfYear(userValue, singleDate);
          } else {
            return userValue.getTime() === (singleDate == null ? void 0 : singleDate.getTime());
          }
        case "occursWithin" /* OCCURS_WITHIN */:
          if (regardlessOfYear) {
            return inRangeRegardlessOfYears(fromDate, toDate2, userValue);
          } else {
            return !(userValue < fromDate || userValue > toDate2);
          }
        case "notOccurWithin" /* NOT_OCCURS_WITHIN */:
          if (regardlessOfYear) {
            return !inRangeRegardlessOfYears(fromDate, toDate2, userValue);
          } else {
            return userValue < fromDate || userValue > toDate2;
          }
        default: {
          debug(notSupported(operator, "ISO_DATE" /* ISO_DATE */));
          return false;
        }
      }
    };
  }
  var onCustomFormSubmitted = (event, onDebug, params) => {
    var _a;
    const { submittedFields = null } = params || {};
    const { fieldRules } = event;
    const targetResult = submittedFields && checkCustomFields(submittedFields, fieldRules.targetRules || [], onDebug);
    const ignoreResult = submittedFields && !!((_a = fieldRules.ignoreRules) == null ? void 0 : _a.length) && checkCustomFields(submittedFields, fieldRules.ignoreRules || [], onDebug);
    if (!submittedFields || !targetResult || ignoreResult) {
      onDebug("submitted fields are not equal provided rules");
      return false;
    }
    return true;
  };

  // ../src/lib/templateInteraction/register.ts
  var myAccountRegister = createCustomRegister(pn.myaccount.registerCallback);
  var offerRegister = createCustomRegister(pn.offer.registerCallback);
  var templateRegister = createCustomRegister(pn.template.registerCallback);
  var formRegister = createCustomRegister(pn.pianoId.registerCallback);
  var offerClose = closeModalWrapper(pn.offer.close, pn.offer.closeInline);
  var templateClose = closeModalWrapper(pn.template.close, pn.template.closeInline);
  var PURCHASE_OFFER_TYPE = "purchase";
  var DOWN_GRADE_OFFER = "upgrade";
  var isFinalState = (currentState) => currentState === "receipt";
  var isAlreadyHasAccess = (currentState) => currentState === "alreadyHasAccess";
  var finalConfirmationSubscribe = () => {
    const onConfirm = (firstArg) => {
      const continuation = getContinuationFromArg(firstArg);
      const trackingId = getTrackingIdFromArg(firstArg) || void 0;
      const { confirm = null } = firstArg;
      if (continuation) {
        const templateInteractionParam = confirm ? trackingId : new Error("Final confirmation: confirm is false");
        continuation.apply(void 0, [templateInteractionParam]);
        continuation.done = true;
      }
    };
    offerRegister.on(FinalConfirmation, null, onConfirm);
    templateRegister.on(FinalConfirmation, null, onConfirm);
  };
  var dismissTemplateSubscribe = () => {
    const getContinuation = (firstArg) => {
      const continuation = getContinuationFromArg(firstArg);
      const experienceActionId = getExperienceActionIdFromArg(firstArg);
      const trackingId = getTrackingIdFromArg(firstArg);
      if (!experienceActionId || !continuation) {
        return;
      }
      return {
        id: experienceActionId,
        run: () => {
          if (!continuation.done) {
            continuation.done = true;
            return continuation(trackingId);
          }
        }
      };
    };
    const onConfirm = (register, firstArg) => {
      const conObj = getContinuation(firstArg);
      if (conObj && !register.has(conObj.id, 3)) {
        conObj.run();
      }
    };
    const onFormConfirm = (first) => {
      const { config, reason } = first;
      const conObj = getContinuation(config);
      if (!conObj) {
        return;
      }
      if (reason === "customFormSubmitted") {
        const registeredCB = formRegister.get(conObj.id, 6);
        if (!registeredCB || registeredCB.every((cb) => !cb.res)) {
          conObj.run();
        }
        return;
      }
      if (!formRegister.has(conObj.id, 7)) {
        conObj.run();
      }
    };
    offerRegister.on(EventTypeMap[3], null, onConfirm.bind(offerRegister));
    templateRegister.on(EventTypeMap[3], null, onConfirm.bind(templateRegister));
    formRegister.on(EventTypeMap[7], null, onFormConfirm);
  };
  var clearTemplateInteractionCallback = () => {
    myAccountRegister.clear();
    offerRegister.clear();
    templateRegister.clear();
    formRegister.clear();
  };
  var registerInteractionCallback = (event, onEvent, onError) => {
    const { eventType, parentId, autoClose } = event;
    const debugError = (err) => onError(`ExpInt: eventType=${eventType}: ${err}`);
    const checkExperienceActionId = (config) => {
      const experienceActionId = getExperienceActionIdFromArg(config || {});
      return experienceActionId === parentId;
    };
    const onCallContinuation = (firstArg) => {
      const continuation = getContinuationFromArg(firstArg);
      const trackingId = getTrackingIdFromArg(firstArg) || void 0;
      if (continuation && !continuation.done) {
        continuation(trackingId);
        continuation.done = true;
      }
    };
    const onContinuation = (firstArg) => {
      const continuation = getContinuationFromArg(firstArg);
      onEvent(continuation);
    };
    const onDismissTemplate = (firstArg) => {
      const { offerType, currentState } = firstArg;
      const continuation = getContinuationFromArg(firstArg);
      const trackingId = getTrackingIdFromArg(firstArg) || void 0;
      if (!continuation) {
        return onContinuation(firstArg);
      }
      if (offerType === DOWN_GRADE_OFFER && isFinalState(currentState)) {
        continuation.done = true;
        return continuation(new Error("Subscription was upgraded"));
      }
      if (offerType === PURCHASE_OFFER_TYPE) {
        if (isFinalState(currentState)) {
          continuation.done = true;
          return continuation(trackingId);
        }
        if (isAlreadyHasAccess(currentState)) {
          continuation.done = true;
          return continuation(new Error("Subscription already has access"));
        }
      }
      onContinuation(firstArg);
    };
    const onContinuationForm = (firstArg) => {
      onContinuation(firstArg.config);
      return true;
    };
    const checkCustomEvent = (close, firstArg) => {
      const { customEventName = null, containerSelector = null } = firstArg || {};
      const result = checkExperienceActionId(firstArg) && (event.customEventNames || []).includes(customEventName);
      if (!result) {
        return false;
      }
      if (autoClose) {
        if (!offerRegister.skipOne(parentId, 3)) {
          offerRegister.on(3, parentId, onCallContinuation, checkExperienceActionId, true);
        }
        if (!templateRegister.skipOne(parentId, 3)) {
          templateRegister.on(3, parentId, onCallContinuation, checkExperienceActionId, true);
        }
        close(containerSelector);
      }
      return result;
    };
    const onRootContinuation = (firstArg) => {
      const continuation = getContinuationFromArg(firstArg);
      const { subscriptionId = null } = firstArg || {};
      if (continuation && subscriptionId) {
        continuation.subscriptionId = subscriptionId;
      }
      if (continuation) {
        continuation.forceTrackStat = true;
      }
      onEvent(continuation);
    };
    const checkCustomFromEvents = ({ config, reason }) => {
      return checkExperienceActionId(config) && reason !== "customFormSubmitted";
    };
    const onCustomFormSubmittedCb = (params) => {
      const continuation = getContinuationFromArg(params.config);
      if (onCustomFormSubmitted(event, debugError, params)) {
        onEvent(continuation);
        return true;
      }
      return false;
    };
    switch (Number(eventType)) {
      case 1:
      case 2:
        myAccountRegister.on(eventType, parentId, onRootContinuation);
        break;
      case 3:
        offerRegister.on(eventType, parentId, onDismissTemplate, checkExperienceActionId);
        templateRegister.on(eventType, parentId, onDismissTemplate, checkExperienceActionId);
        break;
      case 4:
        offerRegister.on(eventType, parentId, onContinuation, checkCustomEvent.bind(null, offerClose));
        templateRegister.on(eventType, parentId, onContinuation, checkCustomEvent.bind(null, templateClose));
        break;
      case 5:
      case 7:
        formRegister.on(eventType, parentId, onContinuationForm, checkCustomFromEvents);
        break;
      case 6:
        formRegister.on(eventType, parentId, onCustomFormSubmittedCb, checkCustomFromEvents);
        break;
      default:
        debugError(eventType + "is not supported");
        return;
    }
  };

  // ../src/lib/templateInteraction/continuation.ts
  var useSegmentNodesArray = [
    "userSegmentTrue",
    "userSegmentFalse"
  ];
  var interactionEventTypes = /* @__PURE__ */ new Set([
    "showForm",
    "showOffer",
    "showTemplate",
    "showRecommendations",
    "showZuoraOffer",
    "showNewscycleOffer",
    ...useSegmentNodesArray
  ]);
  var useSegmentNodes = new Set(useSegmentNodesArray);
  var eventContinuationName = "continuation";
  var bindContinuationToEvent = (e, continuation) => continuation ? __spreadProps(__spreadValues({}, e), {
    [eventContinuationName]: continuation
  }) : e;
  var getContinuationFromEvent = (e) => e[eventContinuationName] || null;
  var getSubscriptionIdFromEvent = (e) => {
    const continuation = getContinuationFromEvent(e);
    return continuation && continuation.subscriptionId;
  };
  var getForceTrackStatFlagFromEvent = (e) => {
    const continuation = getContinuationFromEvent(e);
    return continuation == null ? void 0 : continuation.forceTrackStat;
  };
  var callContinuationForNonInteractiveNodes = (module, continuation, chainLength, interactionContext) => {
    const { eventType, eventConditions } = module;
    const trackingId = module.eventExecutionContext.trackingId;
    const nonInteractive = !interactionEventTypes.has(eventType);
    const isBranchDeadEnd = useSegmentNodes.has(eventType) && (chainLength || 0) < 2;
    const invokeContinuationForNonInteractive = (() => {
      var _a;
      if (!nonInteractive) {
        return false;
      }
      const rootEvent = getRootEvent(eventConditions);
      const hasOnlyRootEvent = eventConditions.length < 2 && eventConditions[0] === rootEvent;
      const hasOtherRegisteredEvents = !!((_a = interactionContext == null ? void 0 : interactionContext.getEventsByModelId(rootEvent == null ? void 0 : rootEvent.moduleId)) == null ? void 0 : _a.length);
      return hasOnlyRootEvent && !hasOtherRegisteredEvents || !hasOnlyRootEvent;
    })();
    const shouldInvokeContinuation = isBranchDeadEnd || invokeContinuationForNonInteractive;
    if (continuation && !continuation.done && shouldInvokeContinuation) {
      continuation(trackingId);
    }
  };

  // ../src/lib/templateInteraction/index.ts
  var getEventTypeName = (eventType) => EventTypeMap[eventType] || null;
  var isTemplateType = (val) => !!(val && TemplateTypesMap.includes(val));
  var getInteractionEventName = (eventLocal) => {
    const name3 = getEventTypeName(eventLocal.eventType || -1);
    return isInteractionEvent(eventLocal.type) ? name3 : null;
  };
  var createEventContext = () => {
    const registeredEvents = {};
    const registeredEventsMap = {};
    return {
      endpoint: INTERACTION_END_POINT,
      name: INTERACTION_METHOD_NAME,
      isDenied: () => {
        var _a;
        return !!((_a = pn.composerControlPolicy) == null ? void 0 : _a.denyTI);
      },
      add: (event, events) => {
        const currentEventName = getInteractionEventName(event);
        const rootEvent = getRootEvent(events);
        const rootEventModuleId = rootEvent ? rootEvent.moduleId : null;
        if (currentEventName) {
          registeredEvents[currentEventName] = true;
        }
        if (rootEventModuleId) {
          registeredEventsMap[rootEventModuleId] = registeredEventsMap[rootEventModuleId] || {};
          events.forEach((eventItem) => {
            const eventName = getInteractionEventName(eventItem);
            if (eventName && !isRootEventType(eventItem)) {
              registeredEventsMap[rootEventModuleId][eventItem.moduleId] = eventName;
            }
          });
        }
      },
      get: () => Object.keys(registeredEvents),
      getEventsByModelId: (moduleId) => {
        const mapData = registeredEventsMap[moduleId || ""];
        if (!mapData) {
          return [];
        }
        return Object.keys(mapData);
      }
    };
  };
  var executeInteraction = (templateType, _executePromise) => __async(void 0, null, function* () {
    if (!isTemplateType(templateType)) {
      throw { code: 1 };
    }
    const eventContext = createEventContext();
    yield _executePromise(eventContext);
    finalConfirmationSubscribe();
    dismissTemplateSubscribe();
    return {
      registeredEvents: eventContext.get()
    };
  });
  var interactionScope = (() => {
    let linkedNodes = {};
    let executedNodes = [];
    let executedHandlers = {};
    return {
      linkedNodes,
      executedNodes,
      executedHandlers
    };
  })();
  var getInteractionExecutedNodes = () => interactionScope.executedNodes;
  var clearInteractionExecutedNodes = () => {
    interactionScope.executedNodes = [];
  };
  var resetInteractionScope = () => {
    clearTemplateInteractionCallback();
    clearInteractionExecutedNodes();
    interactionScope.linkedNodes = {};
    interactionScope.executedHandlers = {};
  };

  // ../src/lib/experience.ts
  var experience = (container = pn.container) => {
    const jqUtils2 = container.resolve("jqUtils");
    const util2 = container.resolve("util");
    const consent4 = container.resolve("consent");
    const api2 = container.resolve("api");
    const eventUtils2 = container.resolve("eventUtils");
    const scrollDepth2 = container.resolve("scrollDepth");
    const ajax3 = container.resolve("ajax");
    const viewportExit2 = container.resolve("viewportExit");
    const idle2 = container.resolve("idle");
    const interaction2 = container.resolve("interaction");
    const pianoEsp2 = container.resolve("pianoEsp");
    const swg2 = container.resolve("swg");
    const fbsubscriptions2 = container.resolve("fbsubscriptions");
    const user2 = container.resolve("user");
    const cxense2 = container.resolve("cxense");
    const logging2 = container.resolve("logging");
    const composerControlPolicy2 = container.resolve("composerControlPolicy");
    const analytics2 = container.resolve("analytics");
    const gaCollectingService2 = container.resolve("gaCollectingService");
    const frequencyEvent2 = container.resolve("frequencyEvent");
    const name3 = "experience";
    let executedNodes = [];
    let linkedNodes = {};
    let lastExecutionStatsContext = "";
    let smallExpereinceMode = false;
    const READER_ID = "reader_id";
    const loggedBrowserEvents = {};
    let initialized = false;
    let executedHandlers = {};
    const handlers = buildHandlers({
      "applyCss": {
        fn: _applyCssHandler,
        isAction: true,
        shouldFireCallback: true
      },
      "runJs": {
        fn: _runJsHandler,
        isAction: true,
        shouldFireCallback: true
      },
      "setCookie": {
        fn: _setCookieHandler,
        isAction: true,
        shouldFireCallback: true
      },
      "nonSite": {
        fn: _nonSiteHandler,
        isAction: true,
        shouldFireCallback: true
      },
      "showForm": {
        fn: _showFormHandler,
        isAction: true,
        shouldFireCallback: true
      },
      "showRecommendations": {
        fn: _showRecommendationsHandler,
        isAction: true,
        shouldFireCallback: true
      },
      "showOffer": {
        fn: _showOfferHandler,
        isAction: true,
        shouldFireCallback: false
      },
      "showTemplate": {
        fn: _showTemplateHandler,
        isAction: true,
        shouldFireCallback: false
      },
      "showZuoraOffer": {
        fn: _showTemplateHandler,
        isAction: true,
        shouldFireCallback: false
      },
      "showNewscycleOffer": {
        fn: _showTemplateHandler,
        isAction: true,
        shouldFireCallback: false
      },
      "showNewsletterSignup": {
        fn: _showNewsletterSignupHandler,
        isAction: true,
        shouldFireCallback: false
      },
      "showPushSignUp": {
        fn: _showPushSignupHandler,
        isAction: true,
        shouldFireCallback: false
      },
      "showLogin": {
        fn: _showLoginHandler,
        isAction: true,
        shouldFireCallback: true
      },
      "continueExecution": {
        fn: _continueExecutionHandler,
        shouldFireCallback: true
      },
      "continueExecutionCompleted": {
        fn: buildEmptyHandler,
        shouldFireCallback: true
      },
      "meterActive": {
        fn: buildEmptyHandler,
        shouldFireCallback: true,
        ga: (event) => ({
          eventCategory: "meterActive",
          eventLabel: "Meter active",
          experienceId: event.eventExecutionContext.experienceId,
          meterName: event.eventExecutionContext.currentMeterName
        })
      },
      "meterExpired": {
        fn: buildEmptyHandler,
        shouldFireCallback: true,
        ga: (event) => ({
          eventCategory: "meterExpired",
          eventLabel: "Meter expired",
          experienceId: event.eventExecutionContext.experienceId,
          meterName: event.eventExecutionContext.currentMeterName
        })
      },
      "userSegmentTrue": {
        fn: _logIfAfterConditionsHandler,
        shouldFireCallback: true
      },
      "userSegmentFalse": {
        fn: _logIfAfterConditionsHandler,
        shouldFireCallback: true
      },
      "experienceExecutionFailed": {
        fn: buildEmptyHandler,
        shouldFireCallback: true
      },
      "log": {
        fn: _logHandler,
        shouldFireCallback: false
      },
      "experienceExecute": {
        fn: _experienceExecuteHandler,
        shouldFireCallback: true,
        ga: (event) => ({
          eventCategory: "experienceExecute",
          eventLabel: "Experience execute",
          experienceId: event.eventExecutionContext.experienceId
        })
      },
      "setResponseVariable": {
        fn: _setResponseVariableHandler,
        isAction: true,
        shouldFireCallback: true,
        ga: (event) => __spreadValues({
          eventCategory: "setResponseVariable",
          eventLabel: "Set response variable",
          experienceId: event.eventExecutionContext.experienceId,
          setResponseVariableId: event.eventModuleParams.moduleId
        }, event.eventParams.responseVariables)
      },
      "creditRedeemed": {
        fn: _creditRedeemedHandler,
        isAction: true,
        shouldFireCallback: true
      }
    });
    const preloadHandlers = {
      showOffer: _deferredShowOfferHandler,
      showTemplate: _deferredShowTemplateHandler,
      showZuoraOffer: _deferredShowTemplateHandler,
      showNewscycleOffer: _deferredShowTemplateHandler
    };
    const executeTemplateInteraction = (interactionConfig = {
      templateType: 1
    }) => executeInteraction(interactionConfig.templateType || 1, (interactionContext) => _executePromise("manual", {
      template_type: interactionConfig.templateType || 1
    }, false, {
      interactionContext
    }));
    const execute = util2.profile((config, handlers2) => {
      composerControlPolicy2.__private__.checkLS();
      _executePromise("manual", config, false, {
        overrides: config,
        handlers: handlers2
      });
    });
    const registerCallback = (event, callback) => {
      eventManager.addEvent(event);
      eventManager.registerCallback(event, callback);
    };
    const _getLastExecutionResult = () => {
      return _lastExecutionResult;
    };
    const XB_COOKIE = "xbc";
    const EDGE_RESULT_COOKIE = "_pcer";
    let _lastExecutionResult = {};
    let browserId2 = "";
    let issuerId = "";
    let itemId = "";
    let timers = [];
    const linkedNodeTypes = {
      "HANDLER": "handler",
      "EVENT_CONDITION": "eventCondition",
      "INNER_EVENT_CONDITION": "innerEventCondition",
      "PRELOAD": "preload"
    };
    const eventManager = eventUtils2.createEventManager([]);
    const eventTypesWithPreload = ["showOffer", "showZuoraOffer", "showNewscycleOffer", "showTemplate"];
    function buildHandlers(conf) {
      var result = {};
      const buildHandler = (config, name4) => {
        return (e, requestParams, result2, executionConfig) => {
          const isInteractionExecute = isInteraction(executionConfig);
          if (config.isAction) {
            var shouldBeConsumed = checkPreActionHandlers(e);
            if (!shouldBeConsumed) {
              return;
            }
            var eventConditionsCount = getEventConditionsCount(e);
            var inCardCondition = getConditionInPreloadCard(e);
            if (eventConditionsCount || inCardCondition) {
              addModuleToExecuted(e.eventModuleParams.moduleId, e, isInteractionExecute);
            }
          }
          var moduleId = e.eventModuleParams.moduleId;
          const executed = (executionConfig == null ? void 0 : executionConfig.interactionContext) ? interactionScope.executedHandlers : executedHandlers;
          if (!executed[moduleId] && moduleId !== "N/A") {
            executed[moduleId] = {
              experienceId: e.eventExecutionContext.experienceId,
              moduleName: e.eventModuleParams.moduleName
            };
          }
          const handlers2 = (executionConfig == null ? void 0 : executionConfig.handlers) || {};
          const handlerName = `on${name4[0].toUpperCase()}${name4.slice(1)}`;
          if (typeof (handlers2 == null ? void 0 : handlers2[handlerName]) === "function") {
            handlers2[handlerName](e, requestParams);
          }
          const eventCopy = Object.assign({}, e);
          if (eventCopy.eventParams)
            eventCopy.eventParams = Object.assign({}, e.eventParams);
          config.fn(eventCopy, requestParams, result2, executionConfig);
          if (config.ga) {
            _sendGAEvent(config.ga(eventCopy));
          }
          if (config.shouldFireCallback) {
            _buildCallbackEventHandler(name4)(eventCopy);
          }
        };
      };
      Object.keys(conf).forEach((key2) => {
        if (typeof conf[key2].fn === "function") {
          result[key2] = buildHandler(conf[key2], key2);
        } else {
          throw new Error("Unsupported config for " + key2 + " handler");
        }
      });
      return result;
    }
    function init() {
      if (initialized || util2.__protected__.isCxenseBot()) {
        return;
      }
      initialized = true;
      var continueInitialization = true;
      if (pn.customPreChecks && pn.customPreChecks.length) {
        var _tempPreCheckRes = null;
        for (var j = pn.customPreChecks.length; j--; ) {
          try {
            _tempPreCheckRes = pn.customPreChecks[j]();
            if (_tempPreCheckRes !== 1 && _tempPreCheckRes !== true) {
              continueInitialization = false;
            }
          } catch (err) {
          }
        }
      }
      if (continueInitialization) {
        _executePromise("auto").then(() => {
          logging2.setTime("expExec", Math.floor(performance.now() - window.pnInitPerformance));
        });
      }
    }
    const getExecutedNodes = (isInteraction2 = false) => {
      return isInteraction2 ? getInteractionExecutedNodes() : executedNodes;
    };
    const addEventToExecutedNodes = (eventInfo, isInteraction2 = false) => {
      (isInteraction2 ? getInteractionExecutedNodes() : executedNodes).push(eventInfo);
    };
    const clearExecutedNodes = (isInteraction2 = false) => {
      if (isInteraction2) {
        clearInteractionExecutedNodes();
      } else {
        executedNodes = [];
      }
    };
    const getTrackingEndpoint = () => {
      return pn.getExperienceEndpoint(false) + "/api/v3";
    };
    const getComposerUrl = (predefinedUrl, controlPolicyDenied) => {
      var endpointPath = predefinedUrl || null;
      if (controlPolicyDenied) {
        return null;
      }
      if (!endpointPath) {
        if (util2.__protected__.cameFromFbSubscriptions()) {
          if (!composerControlPolicy2.denyFbia) {
            endpointPath = "/xbuilder/experience/executeFbia";
            initializeFbSubscriptions();
          }
        } else if (!composerControlPolicy2.denyWeb) {
          endpointPath = "/xbuilder/experience/execute";
        }
      }
      return endpointPath && pn.getExperienceEndpoint(false) + endpointPath;
    };
    const setPianoEspVisitorId = (composerResponse) => {
      pianoEsp2.__protected__.setVisitorId(composerResponse.bid);
    };
    const sendCxensePageViewEvent = (composerResponse) => {
      return cxense2.__protected__.sendPageViewEvent({
        browserId: composerResponse.bid,
        uid: composerResponse.uid,
        cxenseCustomerPrefix: composerResponse.cxenseCustomerPrefix,
        pageViewId: pn.main.fetchPageViewId(),
        eventExecutionContext: createExperienceExecutionContext(composerResponse.result)
      });
    };
    const isCxenseActivated = () => {
      return cxense2.__protected__.isActivated();
    };
    const loadCxLibIfNeeded = () => {
      return cxense2.__protected__.loadCxLibIfNeeded();
    };
    const initBrowserId = (composerResponse) => {
      browserId2 = composerResponse.bid;
    };
    const initIssuerId = (composerResponse) => {
      if (composerResponse.iss) {
        issuerId = composerResponse.iss;
      }
    };
    const initItemId = (composerResponse) => {
      itemId = composerResponse.itemId;
    };
    const onContentRestrictedFallback = (composerResponse) => {
      var _a;
      if (!!((_a = composerResponse.result) == null ? void 0 : _a.onContentRestrictedFallback)) {
        util2.debug("exp: fire event: contentRestrictedFallback");
        eventManager.fireCallbacks("contentRestrictedFallback", void 0, "experience", true);
      }
    };
    const injectSwgMarkup = (swgMarkupData) => {
      swg2.__protected__.injectMarkup(swgMarkupData);
    };
    const addSwgLibrary = () => {
      swg2.__protected__.addLibrary();
    };
    const initSwgFlow = () => {
      swg2.__protected__.initSwgFlow();
    };
    const initializeFbSubscriptions = () => {
      fbsubscriptions2.__protected__.init();
    };
    const statisticsRequestInterval = 2e3;
    let sendStatisticsTimerId;
    const sendStatisticsExecutedNodes = (source, isInteraction2 = false) => {
      var executedNodes2 = getExecutedNodes(isInteraction2);
      if (executedNodes2.length) {
        analytics2.log.event({
          eventType: "logBeaconRequest" /* LOG_BEACON_REQUEST */,
          payload: {
            url: getTrackingEndpoint() + "/composer/logExecutionStats",
            params: {
              aid: pn.aid,
              items: JSON.stringify(executedNodes2),
              execution_stats_context: lastExecutionStatsContext,
              ts: new Date().getTime(),
              source
            }
          }
        });
        clearExecutedNodes(isInteraction2);
      }
      window.clearTimeout(sendStatisticsTimerId);
      sendStatisticsTimerId = window.setTimeout(() => {
        sendStatisticsExecutedNodes("timer" + sendStatisticsTimerId, isInteraction2);
      }, statisticsRequestInterval);
    };
    const consentNotProvided = () => {
      const pdlConfig = () => window.pdl || {};
      return Boolean(pdlConfig().requireConsent && !pn.consent.get());
    };
    const _executePromise = (submitType, executionConfig, isContinueExecution, executionConfigs) => {
      if (consentNotProvided()) {
        util2.debug("WARNING: The RequireConsent feature is enabled. The Piano services might be working unstable until user consent provided");
      }
      if (pn.main.appHasApplePay() === void 0) {
        eventManager.fireCallbacks("experienceFlow", null, "experience", true);
      }
      const isInteractionExecute = !!(executionConfigs == null ? void 0 : executionConfigs.interactionContext);
      var maxAllowedTimeout = 3e4;
      const timeoutPromise = new Promise((resolve) => {
        setTimeout(() => {
          resolve({});
        }, maxAllowedTimeout);
      });
      return Promise.race([
        pn.main.externalResourcesDelay(),
        timeoutPromise
      ]).then((additionalConfig) => {
        if (!jqUtils2.isPlainObject(additionalConfig)) {
          util2.error("exp: error get external resources ", additionalConfig);
          additionalConfig = {};
        }
        const newBid = {
          new_bid: dataLayer.get("browserId")
        };
        const callExecute = isInteractionExecute ? _executeAsync : _execute;
        if (isCxenseActivated()) {
          util2.debug("c1x: integration is activated");
          loadCxLibIfNeeded();
          const executeConfig = jqUtils2.deepExtend({}, executionConfig, additionalConfig, newBid, {
            c1x_integration_version: "v2"
          });
          return callExecute(submitType, executeConfig, isContinueExecution, executionConfigs);
        } else {
          return callExecute(submitType, jqUtils2.deepExtend({}, executionConfig, additionalConfig, newBid), isContinueExecution, executionConfigs);
        }
      }).catch((err) => {
        if (isInteractionExecute) {
          throw err;
        }
      });
    };
    const _executeAsync = (submitType, executionConfig, isContinueExecution, executionOverrides) => new Promise((resolve, reject) => _execute(submitType, executionConfig, isContinueExecution, executionOverrides, resolve, reject));
    const _execute = (submitType, executionConfig, isContinueExecution, executionOverrides, resolve, reject) => {
      const interactionContext = executionOverrides == null ? void 0 : executionOverrides.interactionContext;
      executionConfig = executionConfig || {};
      var params = jqUtils2.deepExtend({}, { protocol_version: 1 }, executionConfig);
      _applyCookieParameters(params);
      _applyPushNotificationParams(params);
      _applyEspMailingListParams(params);
      _applyUserSegmentsParams(params);
      if (util2.hasQueryParamByName(READER_ID)) {
        params[READER_ID] = util2.getQueryParamByName(READER_ID);
      }
      util2.waitCall("refreshUserToken", () => {
        if (!isContinueExecution) {
          pn.main.trackPageUnloadIfNecessary.skipLog();
          _applyTpConfigurationParameters(params);
          api2.getCallParams(params, user2.getProvider());
          util2.removeAffiliateToken();
          var pageTrackConfig = {
            url: window.location.href,
            tags: pn.tags,
            submitType,
            skipPageViewTrack: shouldSkipAction(!!interactionContext)
          };
          pn.main.buildPageTrackParams(params, pageTrackConfig);
        } else {
          const executed = interactionContext ? interactionScope.executedHandlers : executedHandlers;
          params["executed_nodes"] = JSON.stringify(executed);
        }
        consent4.__protected__.addConsentsToParams(params);
        frequencyEvent2.__protected__.applyToParams(params);
        util2.debug("exp: Experience initialized with params:", params);
        util2.waitCall("refreshAccessTokenList", () => {
          util2.startCall((interactionContext == null ? void 0 : interactionContext.name) || "experienceExecute");
          var url = getComposerUrl(interactionContext == null ? void 0 : interactionContext.endpoint, interactionContext == null ? void 0 : interactionContext.isDenied());
          if (!url) {
            util2.doneCall((interactionContext == null ? void 0 : interactionContext.name) || "experienceExecute");
            if (!isContinueExecution) {
              resetExperienceState(!!interactionContext);
            }
            const debugErr = "execute is denied";
            util2.debug(debugErr);
            reject == null ? void 0 : reject({
              code: 424,
              message: "Error: " + debugErr
            });
            return;
          }
          var ie9 = navigator.appVersion.indexOf("MSIE 9") !== -1;
          var ajaxSettings;
          if (ie9) {
            ajaxSettings = {
              dataType: "jsonp",
              url: url + "?" + jqUtils2.param(params)
            };
          } else {
            var queryString = "?" + jqUtils2.param({
              "aid": params.aid
            });
            ajaxSettings = {
              type: "post",
              url: url + queryString,
              data: jqUtils2.deepExtend({}, params, (executionOverrides == null ? void 0 : executionOverrides.overrides) || {}),
              xhrFields: {
                withCredentials: true
              }
            };
          }
          ajaxSettings.success = (result) => {
            util2.doneCall((interactionContext == null ? void 0 : interactionContext.name) || "experienceExecute");
            var requestParams = jqUtils2.deepExtend({}, params);
            if (!isContinueExecution) {
              resetExperienceState(!!interactionContext);
              pn.main.registerTrackUnload.skipLog();
            }
            processErrors(result.errors);
            processResult(result.models, requestParams, executionOverrides);
            resolve == null ? void 0 : resolve({ code: 0 });
          };
          ajaxSettings.error = (request) => {
            composerControlPolicy2.__private__.setPolicyByRequest(request);
            util2.doneCall((interactionContext == null ? void 0 : interactionContext.name) || "experienceExecute");
            if (!isContinueExecution) {
              resetExperienceState(!!interactionContext);
            }
            var response = {
              code: 503,
              message: "Error: Received error when requesting API response from URL: " + url
            };
            util2.debug(response.message);
            reject == null ? void 0 : reject(response);
          };
          ajax3.request(ajaxSettings);
        });
      });
    };
    const _applyCookieParameters = (params) => {
      var xbc = util2.__protected__.getCookie(XB_COOKIE);
      if (xbc) {
        params.xbc = xbc;
      }
      var tbc = util2.getTbcCookie();
      if (tbc && tbc.length > 0) {
        params.tbc = tbc;
      }
      var pcer = util2.__protected__.getCookie(EDGE_RESULT_COOKIE);
      if (pcer) {
        params.edge_result = pcer;
      }
      util2.getCampaigns(params);
      params.custom_cookies = JSON.stringify(util2.getCustomCookies());
    };
    const _applyPushNotificationParams = (params) => {
      var pushListSubscriptions = util2.getPushListsCookie();
      var notificationStatus = pianoEsp2.__protected__.getNotificationStatus();
      if (pushListSubscriptions && pushListSubscriptions.length > 0) {
        params.push_list_subscriptions = JSON.stringify(pushListSubscriptions);
      }
      if (notificationStatus) {
        params.push_notification_settings = notificationStatus;
      }
    };
    const _applyEspMailingListParams = (params) => {
      params.mailing_lists = JSON.stringify(pianoEsp2.__protected__.loadCompleteMailingLists());
    };
    const _applyTpConfigurationParameters = (params) => {
      var propsToCopy = [
        { property: "debug", parameter: "debug", skipFalse: true },
        { property: "trackPageView", parameter: "increment_pageview_meter" }
      ];
      propsToCopy.forEach((value) => {
        if (pn[value.property] !== void 0 && (!value.skipFalse || pn[value.property])) {
          params[value.parameter] = pn[value.property];
        }
      });
      return params;
    };
    const _applyUserSegmentsParams = (params) => {
      const segments = dataLayer.get("userSegments");
      if (segments) {
        params["previous_user_segments"] = JSON.stringify(segments);
      }
    };
    const processErrors = (errors) => {
      if (Array.isArray(errors)) {
        if (errors.length) {
          util2.debug("exp: composer execution has been failed with errors");
        }
        errors.forEach((value) => {
          util2.debug("exp: " + value.msg);
        });
      }
    };
    const addModuleToExecuted = (moduleId, e, isInteraction2 = false) => {
      addEventToExecutedNodes({
        mId: moduleId,
        eId: e.eventExecutionContext.experienceId,
        eV: e.eventExecutionContext.experienceVersion,
        eeId: e.eventExecutionContext.executionId
      }, isInteraction2);
    };
    function createLinkedNodeHandler(handler, e, requestParams, result, executionConfig) {
      return function() {
        return {
          type: linkedNodeTypes.HANDLER,
          eventType: e.eventType,
          children: [],
          run: function(continuation, chainLength, interactionContext) {
            const copyEvent = bindContinuationToEvent(e, continuation);
            handler.bind(this, copyEvent, requestParams, result, executionConfig)();
            callContinuationForNonInteractiveNodes(e, continuation, chainLength, interactionContext);
          }
        };
      }();
    }
    const getConditionInPreloadCard = (e) => {
      var delayBy = e.eventParams.delayBy || {};
      var condition;
      if (delayBy.value) {
        if (delayBy.type === "time") {
          condition = { type: "timer", timer: delayBy.value };
        } else if (delayBy.type === "scroll") {
          condition = { type: "scrollDepth", scrollDepth: delayBy.value, measureType: "pixels" };
        }
      }
      return condition;
    };
    const getEventConditionsCount = (e) => {
      return e.eventConditions && Array.isArray(e.eventConditions) ? e.eventConditions.length : 0;
    };
    const createLinkedNodeForPreloadHandler = (preloadHandler, e) => {
      return (() => {
        var wasExecuted = false;
        var preloadResult;
        return {
          type: linkedNodeTypes.PRELOAD,
          eventType: e.eventType,
          children: [],
          run: () => {
            if (wasExecuted === false) {
              preloadResult = preloadHandler(e);
              wasExecuted = true;
            }
          },
          getPreloadResult: () => {
            return preloadResult;
          }
        };
      })();
    };
    function sendAnalyticForBrowserEvents(eventCondition) {
      if (loggedBrowserEvents[eventCondition.type]) {
        return;
      }
      _sendGAEvent(__spreadValues({
        eventCategory: "beforeBrowserEvent",
        eventLabel: "Before browser event"
      }, eventCondition));
      loggedBrowserEvents[eventCondition.type] = true;
    }
    function subscribeToEventListener(eventCondition, executeFollowChain) {
      const consumeEventFn = () => {
        sendAnalyticForBrowserEvents(eventCondition);
        return eventManager.fireCallbacksAndStopOnFirstFalse("beforeBrowserEvent", eventCondition);
      };
      switch (eventCondition.type) {
        case TEMPLATE_INTERACTION_EVENT:
        case FORM_INTERACTION_EVENT:
          registerInteractionCallback(eventCondition, (continuation) => consumeEventFn() && executeFollowChain(continuation), (err) => util2.debug(err));
          break;
        case "viewportExit": {
          viewportExit2.addListener(executeFollowChain, {
            detectExitMode: eventCondition.detectExitMode,
            detectBackButtonForMobile: eventCondition.detectBackButtonForMobile,
            clientDevice: eventCondition.clientDevice
          }, consumeEventFn);
          break;
        }
        case "scrollDepth": {
          scrollDepth2.addListener(executeFollowChain, {
            scrollDepth: eventCondition.scrollDepth,
            measureType: eventCondition.measureType
          }, consumeEventFn);
          break;
        }
        case "timer": {
          var newTimer = setTimeout(() => {
            if (consumeEventFn()) {
              executeFollowChain();
            }
          }, 1e3 * eventCondition.timer);
          timers.push(newTimer);
          break;
        }
        case "interaction": {
          interaction2.bind(executeFollowChain, eventCondition.interactions, consumeEventFn);
          break;
        }
        case "idle": {
          idle2.addListener(executeFollowChain, eventCondition.idleTime, consumeEventFn);
          break;
        }
      }
    }
    const canUseNodeInLoop = (node) => {
      var handlersRunningOnce = ["continueExecution", "meterActive", "meterExpired"];
      return node.type === linkedNodeTypes.HANDLER && handlersRunningOnce.indexOf(node.eventType) === -1;
    };
    function createLinkedNodeEventCondition(eventCondition, e, interactionContext) {
      return function() {
        var wasExecuted = false;
        const isInteraction2 = !!interactionContext;
        const nodes = interactionContext ? interactionScope.linkedNodes : linkedNodes;
        var executeFollowChain = function(continuation) {
          addModuleToExecuted(eventCondition.moduleId, e, isInteraction2);
          var chainConditions = nodes[eventCondition.moduleId].children;
          for (var index = 0; index < chainConditions.length; index++) {
            var chainConditionId = chainConditions[index];
            var chainCondition = nodes[chainConditionId];
            if (wasExecuted === false || canUseNodeInLoop(chainCondition)) {
              try {
                chainCondition.run(continuation, chainConditions.length, interactionContext);
              } catch (ex) {
                util2.error("exp: error execute chain event", chainCondition, ex);
              }
            }
          }
          wasExecuted = true;
          if (smallExpereinceMode) {
            sendStatisticsExecutedNodes("chain", isInteraction2);
          }
        };
        interactionContext == null ? void 0 : interactionContext.add(eventCondition, e.eventConditions || []);
        return {
          type: linkedNodeTypes.EVENT_CONDITION,
          children: [],
          run: function() {
            subscribeToEventListener(eventCondition, executeFollowChain);
          }
        };
      }();
    }
    function createLinkedNodeForInnerEventCondition(inCardCondition, handlerId, interactionContext) {
      return function() {
        var wasExecuted = false;
        const nodes = interactionContext ? interactionScope.linkedNodes : linkedNodes;
        var executeFollowChain = () => {
          var chainConditions = nodes[handlerId + linkedNodeTypes.INNER_EVENT_CONDITION].children;
          for (var index = 0; index < chainConditions.length; index++) {
            var chainConditionId = chainConditions[index];
            var chainCondition = nodes[chainConditionId];
            if (wasExecuted === false || canUseNodeInLoop(chainCondition)) {
              try {
                chainCondition.run();
              } catch (ex) {
                util2.error("exp: error execute chain event", chainCondition, ex);
              }
            }
          }
          wasExecuted = true;
        };
        return {
          type: linkedNodeTypes.INNER_EVENT_CONDITION,
          children: [handlerId],
          run: function() {
            subscribeToEventListener(inCardCondition, executeFollowChain);
          }
        };
      }();
    }
    const initSwgIfNeeded = (result) => {
      if (result.swgMarkupData) {
        util2.debug("exp: swg markup data :", result.swgMarkupData);
        injectSwgMarkup(result.swgMarkupData);
        if (!result.swgMarkupData.isAccessibleForFree) {
          addSwgLibrary();
        }
      }
      if (result.swgEnabled) {
        initSwgFlow();
      }
    };
    const createExperienceExecutionContext = (result) => {
      if (!result) {
        util2.debug("exp: no composer execution result");
        return;
      }
      var executionResult = {};
      for (var index = 0; index < result.events.length; index++) {
        var e = result.events[index];
        try {
          var eventType = e.eventType;
          if (eventType === "experienceExecute") {
            executionResult = jqUtils2.deepExtend({}, e.eventExecutionContext);
            executionResult.result = jqUtils2.deepExtend({}, result);
          }
        } catch (ex) {
          util2.error("exp: error on execute event: ", e, ex);
        }
      }
      return executionResult;
    };
    const shouldSkipAction = (isInteraction2) => {
      return isInteraction2 && (initialized || execute.invokeCount !== 0);
    };
    const processResult = (data, requestParams, executionConfig) => {
      if (!data) {
        return;
      }
      const interactionContext = executionConfig == null ? void 0 : executionConfig.interactionContext;
      const isInteraction2 = !!interactionContext;
      const nodes = interactionContext ? interactionScope.linkedNodes : linkedNodes;
      util2.setTbcCookieFromResponse(data);
      util2.setTacCookieFromResponse(data);
      util2.setAppTimezoneOffsetFromResponse(data);
      util2.setCurrentDomainFromResponse(data);
      if (!shouldSkipAction(isInteraction2)) {
        sendCxensePageViewEvent(data);
      }
      setPianoEspVisitorId(data);
      initBrowserId(data);
      initIssuerId(data);
      initItemId(data);
      onContentRestrictedFallback(data);
      frequencyEvent2.__protected__.registerEvent(data);
      util2.setXbcCookieFromResponse(data);
      var result = data.result;
      var executionResult = {};
      if (!result) {
        util2.debug("exp: no composer execution result");
        return;
      }
      initSwgIfNeeded(result);
      util2.debug("exp: processed experiences :", result.experiences);
      lastExecutionStatsContext = data.executionStatsContext;
      result.debugMessages.forEach((message) => {
        util2.debug("exp: execute :", message);
      });
      var addEventConditions = function(e2, handlerId, rootEventConditions2) {
        var eventConditions = e2.eventConditions;
        for (var index2 = 0; index2 < eventConditions.length; index2++) {
          var eventCondition = eventConditions[index2];
          var moduleId2 = eventCondition.moduleId;
          var previousCondition = eventConditions[index2 - 1];
          var isLastEventCondition = !eventConditions[index2 + 1];
          if (!nodes[moduleId2]) {
            nodes[moduleId2] = createLinkedNodeEventCondition(eventCondition, e2, executionConfig == null ? void 0 : executionConfig.interactionContext);
          }
          if (isLastEventCondition) {
            nodes[moduleId2].children.push(handlerId);
            var isEventWithPreload = eventTypesWithPreload.indexOf(e2.eventType) !== -1;
            if (isEventWithPreload) {
              if (eventCondition.type === "viewportExit" && !getConditionInPreloadCard(e2)) {
                var preloadHandler = preloadHandlers[e2.eventType];
                if (!preloadHandler) {
                  util2.error("exp: not found preload handler for event: ", e2);
                  continue;
                }
                var preloadHandlerId = handlerId + linkedNodeTypes.PRELOAD;
                nodes[preloadHandlerId] = createLinkedNodeForPreloadHandler(preloadHandler, e2);
                if (previousCondition) {
                  nodes[previousCondition.moduleId].children.push(preloadHandlerId);
                } else {
                  rootEventConditions2.push(preloadHandlerId);
                }
              }
            }
          }
          if (previousCondition && nodes[previousCondition.moduleId].children.indexOf(moduleId2) === -1) {
            nodes[previousCondition.moduleId].children.push(moduleId2);
          }
        }
      };
      var rootEventConditions = [];
      var moduleId;
      var eventsWithConditions = 0;
      for (var index = 0; index < result.events.length; index++) {
        var e = result.events[index];
        try {
          var eventType = e.eventType;
          var eventModuleParams = e.eventModuleParams || {};
          util2.debug("exp: process event '" + eventType + "' (" + eventModuleParams.moduleId + ")");
          if (eventType === "experienceExecute") {
            executionResult = jqUtils2.deepExtend({}, e.eventExecutionContext);
            executionResult.result = jqUtils2.deepExtend({}, result);
            util2.setUserSegments(executionResult);
          }
          moduleId = eventModuleParams.moduleId;
          if (!moduleId) {
            util2.error("exp: not found moduleId for linked node event: ", e);
            continue;
          }
          var handler = handlers[eventType];
          if (!handler) {
            util2.error("exp: not found handler for event: ", e);
            continue;
          }
          nodes[moduleId] = createLinkedNodeHandler(handler, e, requestParams, result, executionConfig);
          var eventConditionsCount = getEventConditionsCount(e);
          var inCardCondition = getConditionInPreloadCard(e);
          if (eventConditionsCount || inCardCondition) {
            var moduleIdToBindConditions = moduleId;
            if (inCardCondition) {
              var innerEventConditionLinkedNode = createLinkedNodeForInnerEventCondition(inCardCondition, moduleId, interactionContext);
              moduleIdToBindConditions = moduleId + linkedNodeTypes.INNER_EVENT_CONDITION;
              nodes[moduleIdToBindConditions] = innerEventConditionLinkedNode;
            }
            if (eventConditionsCount) {
              if (rootEventConditions.indexOf(e.eventConditions[0].moduleId) === -1) {
                rootEventConditions.push(e.eventConditions[0].moduleId);
              }
            } else if (inCardCondition) {
              rootEventConditions.push(moduleIdToBindConditions);
            }
            addEventConditions(e, moduleIdToBindConditions, rootEventConditions);
            eventsWithConditions++;
          } else {
            rootEventConditions.push(moduleId);
          }
        } catch (ex) {
          util2.error("exp: error on execute event: ", e, ex);
        }
      }
      if (eventsWithConditions <= 3) {
        smallExpereinceMode = true;
      }
      for (var i = 0; i < rootEventConditions.length; i++) {
        moduleId = rootEventConditions[i];
        if (nodes[moduleId]) {
          nodes[moduleId].run();
        }
      }
      window.clearTimeout(sendStatisticsTimerId);
      sendStatisticsTimerId = window.setTimeout(() => {
        sendStatisticsExecutedNodes("rootTimer" + sendStatisticsTimerId, !!interactionContext);
      }, statisticsRequestInterval);
      _lastExecutionResult = executionResult;
    };
    const _dumpElementWithChildren = function(dumpElement) {
      var linkedNode = linkedNodes[dumpElement.moduleId];
      dumpElement.type = linkedNode.type;
      for (var i = 0; i < linkedNode.children.length; i++) {
        dumpElement.children.push(_dumpElementWithChildren({
          moduleId: linkedNode.children[i],
          children: []
        }));
      }
      return dumpElement;
    };
    const _dumpRootEventConditions = (rootEventConditions) => {
      var dump = [];
      for (var i = 0; i < rootEventConditions.length; i++) {
        dump.push(_dumpElementWithChildren({
          moduleId: rootEventConditions[i],
          children: []
        }));
      }
      util2.debug("exp: root event conditions ", dump);
    };
    function _setCookieHandler(e) {
      var eventParams = e.eventParams;
      if (eventParams && typeof eventParams.cookieName !== "undefined" && typeof eventParams.cookieValue !== "undefined") {
        util2.debug("exp: set cookie with parameters:", eventParams);
        var cookieName = (eventParams.isReadableCookie ? "_pc_" : "") + eventParams.cookieName;
        var options = {
          domain: eventParams.cookieDomain,
          path: eventParams.cookiePath
        };
        if (!eventParams.isSessionCookie) {
          var expirationDate = new Date();
          switch (eventParams.expirationUnit) {
            case "seconds":
              expirationDate.setSeconds(expirationDate.getSeconds() + eventParams.expirationValue);
              break;
            case "minutes":
              expirationDate.setMinutes(expirationDate.getMinutes() + eventParams.expirationValue);
              break;
            case "hours":
              expirationDate.setHours(expirationDate.getHours() + eventParams.expirationValue);
              break;
            case "days":
              expirationDate.setDate(expirationDate.getDate() + eventParams.expirationValue);
              break;
            case "months":
              expirationDate.setMonth(expirationDate.getMonth() + eventParams.expirationValue);
              break;
            case "years":
              expirationDate.setFullYear(expirationDate.getFullYear() + eventParams.expirationValue);
              break;
            default:
              util2.log("Wrong eventParams.expirationUnit : ", eventParams.expirationUnit);
          }
          options.expires = expirationDate;
        }
        util2.__protected__.setCookieConsent("composer", cookieName, eventParams.cookieValue, options);
      }
    }
    function _sendGAEvent(params) {
      analytics2.ga.event({
        eventType: "emitGAEvent" /* EMIT_GA_EVENT */,
        payload: __spreadValues({
          aid: pn.aid
        }, params)
      });
    }
    function _runJsHandler(e) {
      if (e.eventParams && e.eventParams.snippet) {
        var snippet = e.eventParams.snippet;
        util2.debug("exp: run js with snippet:", snippet);
        var context = e.eventExecutionContext;
        util2.debug("exp: set publisher's context and custom:", context);
        var text = "var context = " + JSON.stringify(context) + ";\nvar custom = " + JSON.stringify(pn.customVariables) + ";\n" + snippet;
        _runScript(text);
      }
    }
    function _nonSiteHandler(e) {
      util2.debug("exp: non-site action:", e);
    }
    function _creditRedeemedHandler(e) {
      util2.debug("exp: credit redeemed action:", e);
    }
    function _logHandler(e, reqParam, res, executionConfig) {
      var executeInteraction2 = isInteraction(executionConfig);
      addModuleToExecuted(e.eventModuleParams.moduleId, e, executeInteraction2);
    }
    function _logIfAfterConditionsHandler(e, reqParam, res, executionConfig) {
      var eventConditionsCount = getEventConditionsCount(e);
      var executeInteraction2 = isInteraction(executionConfig);
      if (eventConditionsCount) {
        addModuleToExecuted(e.eventModuleParams.moduleId, e, executeInteraction2);
      }
    }
    function _continueExecutionHandler(e, requestParams, _, executionConfigs) {
      util2.debug("exp: continue execution action:", e, "with requestParameters", requestParams);
      var config = requestParams || {};
      config.experience_id = e.eventExecutionContext.experienceId;
      config.experience_version = e.eventExecutionContext.experienceVersion;
      config.context_data = e.eventParams.contextData;
      _executePromise("auto", config, true, executionConfigs);
    }
    function _runScript(snippet) {
      try {
        eval.call(window, "(function () {" + snippet + "\n})();");
      } catch (e) {
        util2.log("Error occurred in RunJS\n", e);
      }
    }
    function _applyCssHandler(e) {
      e.eventParams.ruleList.forEach((rule) => {
        let classes = rule.classes;
        const elements = rule.elements;
        if (classes) {
          classes = classes.replace(/[,.]/g, " ").split(" ").filter((el) => el !== "");
          if (rule.type === "add") {
            const htmlElList = jqUtils2.qa(elements);
            if (htmlElList && htmlElList.length) {
              htmlElList.forEach((el) => {
                classes.forEach((cl) => {
                  jqUtils2.addClass(cl, el);
                });
              });
            }
          }
          if (rule.type === "remove") {
            const htmlElList = jqUtils2.qa(elements);
            if (htmlElList && htmlElList.length) {
              htmlElList.forEach((el) => {
                classes.forEach((cl) => {
                  jqUtils2.removeClass(cl, el);
                });
              });
            }
          }
        }
        util2.debug("exp: css applied with rule:", rule);
      });
    }
    function _showHandler(e, showFn, isInteraction2 = false) {
      const nodes = isInteraction2 ? interactionScope.linkedNodes : linkedNodes;
      var preloadHandler = nodes[e.eventModuleParams.moduleId + linkedNodeTypes.PRELOAD];
      if (preloadHandler && preloadHandler.getPreloadResult) {
        return preloadHandler.getPreloadResult().show();
      } else {
        return show(e, showFn);
      }
    }
    function isInteraction(executionConfigs) {
      return !!(executionConfigs == null ? void 0 : executionConfigs.interactionContext);
    }
    function _showOfferHandler(e, requestParams, _, executionConfigs) {
      return _showHandler(e, (params) => pn.offer.show(params), isInteraction(executionConfigs));
    }
    function _showTemplateHandler(e, requestParams, _, executionConfigs) {
      return _showHandler(e, (params) => pn.template.show(params), isInteraction(executionConfigs));
    }
    function _showNewsletterSignupHandler(e, requestParams, _, executionConfigs) {
      return _showHandler(e, (params) => pianoEsp2.__protected__.showNewsletterSignup(params), isInteraction(executionConfigs));
    }
    function _showPushSignupHandler(e, requestParams, _, executionConfigs) {
      return _showHandler(e, (params) => pianoEsp2.__protected__.showPushSignup(params), isInteraction(executionConfigs));
    }
    function _showLoginHandler(e) {
      user2.showLogin({
        trackingId: e.eventExecutionContext.trackingId
      });
    }
    function _deferredShowHandler(e, deferredShowFn) {
      util2.debug("exp: run preloading for:", e);
      return show(e, (params) => deferredShowFn(params));
    }
    function _deferredShowOfferHandler(e) {
      return _deferredShowHandler(e, (params) => pn.offer.deferredShow(params));
    }
    function _deferredShowTemplateHandler(e) {
      return _deferredShowHandler(e, (params) => pn.template.deferredShow(params));
    }
    function resetExperienceState(isInteraction2 = false) {
      sendStatisticsExecutedNodes("reset", isInteraction2);
      if (isInteraction2) {
        resetInteractionScope();
      } else {
        removeEventListeners();
        linkedNodes = {};
        executedHandlers = {};
      }
    }
    function removeEventListeners() {
      timers.forEach((value) => {
        clearTimeout(value);
      });
      timers = [];
      viewportExit2.removeListeners();
      idle2.removeListeners();
      scrollDepth2.removeListeners();
      interaction2.unbindAll();
    }
    function show(e, showFn) {
      var params = jqUtils2.deepExtend({}, e.eventParams), splitTests = e.eventExecutionContext.splitTests, activeMeters = e.eventExecutionContext.activeMeters, formNameByTermId = e.eventParams.formNameByTermId, hideCompletedFields = e.eventParams.hideCompletedFields, affiliateState = getAffiliateState(e.eventExecutionContext);
      const continuation = getContinuationFromEvent(e);
      const subscriptionId = getSubscriptionIdFromEvent(e);
      const forceTrackStat = getForceTrackStatFlagFromEvent(e);
      params.trackingId = e.eventExecutionContext.trackingId;
      params.experienceId = e.eventExecutionContext.experienceId;
      params.experienceExecutionId = e.eventExecutionContext.executionId;
      params.experienceActionId = e.eventModuleParams.moduleId;
      params.experienceConditions = e.eventConditions;
      if (e.eventParams.offerType === "upgrade_or_downgrade") {
        params.offerType = "upgradeOffer";
      }
      if (continuation) {
        params.continuation = continuation;
        params.subscriptionId = subscriptionId;
        params.forceTrackStat = forceTrackStat;
      }
      params.browserId = browserId2;
      params.onStartCreditRedemption = (params2) => {
        const creditParams = jqUtils2.deepExtend({}, params2);
        const isPianoId = issuerId === "https://www.piano.io";
        const isNonAnon = e.eventExecutionContext.user && e.eventExecutionContext.uid !== "anon";
        creditParams.trackingId = e.eventExecutionContext.trackingId || void 0;
        if (isPianoId && isNonAnon) {
          creditParams.uid = e.eventExecutionContext.user.uid || void 0;
        }
        return pn.credit.redeem(creditParams);
      };
      if (splitTests && splitTests.length > 0) {
        var splitTestIdsArray = splitTests.map((e2) => {
          return e2.variantId;
        });
        params.splitTestIds = JSON.stringify(splitTestIdsArray);
      }
      params.additionalParamNames = [];
      if (activeMeters && activeMeters.length > 0) {
        params.activeMeters = JSON.stringify(activeMeters);
      }
      if (e.eventType === "showZuoraOffer") {
        var ratePlanIds = e.eventParams.ratePlanIds;
        if (ratePlanIds && ratePlanIds.length > 0) {
          params.zuoraSelectedRatePlanIds = JSON.stringify(ratePlanIds);
          params.additionalParamNames.push("zuoraSelectedRatePlanIds");
        }
      }
      if (e.eventType === "showNewscycleOffer") {
        var ids = e.eventParams.ids;
        if (ids && ids.length > 0) {
          params.newscycleSelectedIds = JSON.stringify(ids);
          params.additionalParamNames.push("newscycleSelectedIds", "campaignCode", "campaignGroupId");
        }
      }
      if (e.eventType === "showNewsletterSignup") {
        var mailingListIds = e.eventParams.mailingListIds;
        var siteId = e.eventParams.siteId;
        if (mailingListIds && mailingListIds.length > 0) {
          params.mailingListIds = JSON.stringify(mailingListIds);
          params.siteId = siteId;
          params.additionalParamNames.push("mailingListIds", "siteId");
        }
      }
      if (e.eventType === "showRecommendations") {
        params.widgetId = e.eventParams.widgetId;
        params.placeholder = e.eventParams.placeholder;
      }
      if (formNameByTermId) {
        params.formNameByTermId = JSON.stringify(formNameByTermId);
        params.hideCompletedFields = hideCompletedFields;
      }
      if (affiliateState) {
        params.affiliateState = affiliateState;
      }
      util2.debug("exp: show with params:", params);
      gaCollectingService2.setParam("splitTestIds", params.splitTestIds);
      return showFn(params);
    }
    function _showRecommendationsHandler(e, requestParams, _, executionConfigs) {
      return _showHandler(e, _getShowRecommendationHandler(e.eventParams.type), isInteraction(executionConfigs));
    }
    function _getShowRecommendationHandler(type2) {
      const showRecommendationMap = {
        ESP: pianoEsp2.__protected__.showRecommendation.bind(pianoEsp2),
        CXENSE: cxense2.__protected__.showRecommendation.bind(cxense2)
      };
      return showRecommendationMap[type2] || buildEmptyHandler();
    }
    function _showFormHandler(e) {
      var eventParams = e.eventParams;
      if (eventParams && eventParams.formName) {
        var config = {
          formName: eventParams.formName,
          hideIfComplete: eventParams.hideCompletedFields,
          trackingId: e.eventExecutionContext.trackingId,
          displayMode: eventParams.displayMode,
          containerSelector: eventParams.containerSelector,
          showCloseButton: eventParams.showCloseButton,
          templateId: eventParams.templateId,
          variantId: eventParams.templateVariantId,
          accessToken: user2.getProvider().getToken(),
          experienceActionId: e.eventModuleParams.moduleId,
          continuation: getContinuationFromEvent(e),
          subscriptionId: getSubscriptionIdFromEvent(e)
        };
        if (eventParams.formWidth && eventParams.formWidth.enabled) {
          config = jqUtils2.deepExtend({}, { width: eventParams.formWidth.width }, config);
        }
        util2.debug("exp: show form with params:", eventParams);
        pn.pianoId.showForm(config);
      }
    }
    function _experienceExecuteHandler(e, requestParams, result) {
      var params = e.eventParams;
      params.result = result;
    }
    function _setResponseVariableHandler(e) {
      return e.eventParams;
    }
    function _buildCallbackEventHandler(eventName) {
      return (e) => {
        var callback = e.eventParams.callback, eventParams = e.eventParams, cardParams = e.eventModuleParams, contextParams = e.eventExecutionContext;
        util2.debug("exp: fire event ", eventName, " with eventParams:", eventParams, ", moduleParams:", cardParams, ", context:", contextParams);
        eventManager.fire("experience", eventName, true, eventParams, cardParams, contextParams);
        if (callback) {
          if (eventName !== callback) {
            util2.debug("exp: execute event ", eventName, " with callback: ", callback);
            _runScript(callback);
          }
        }
      };
    }
    function buildEmptyHandler() {
      return () => {
      };
    }
    function checkPreActionHandlers(e) {
      var eventParams = e.eventParams;
      var cardParams = e.eventModuleParams;
      var contextParams = e.eventExecutionContext;
      util2.debug("exp: fire event 'beforeComposerAction' with eventParams:", eventParams, ", moduleParams:", cardParams, ", context:", contextParams);
      return eventManager.fireCallbacksAndStopOnFirstFalse("beforeComposerAction", eventParams, cardParams, contextParams);
    }
    function getAffiliateState(eventExecutionContext) {
      var _a;
      if (!issuerId) {
        return null;
      }
      var context = eventExecutionContext || {};
      return {
        issuerId,
        premium: context.user && context.user.premium || null,
        redemptionCandidateItemId: itemId || null,
        creditStates: context.creditStates || null,
        userId: ((_a = context.user) == null ? void 0 : _a.uid) || null,
        targetGroups: {
          "l1": "target",
          "l2": null
        }
      };
    }
    return {
      name: name3,
      init,
      execute,
      executeTemplateInteraction,
      _getLastExecutionResult,
      registerCallback,
      __private__: {
        handlers,
        executedNodes,
        linkedNodes,
        processResult,
        processErrors,
        show,
        getTrackingEndpoint,
        initialized,
        registerCallback
      },
      __protected__: {
        sendStatisticsExecutedNodes
      }
    };
  };
  pn.container.register("experience", {
    useValue: experience()
  });
  pn.experience = pn.container.resolve("experience");

  // ../src/lib/ifvisible.ts
  var ifvisible = (() => {
    let hidden;
    let idleStartedTime = 0;
    let visibilityChange;
    const doc = document;
    let initialized = false;
    let status = "active";
    let idleTime = 6e4;
    const customEvent = function() {
      let S4;
      let addCustomEvent;
      let cgid;
      let fireCustomEvent;
      let guid;
      let listeners;
      let removeCustomEvent;
      S4 = function() {
        return ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
      };
      guid = function() {
        return S4() + S4() + "-" + S4() + "-" + S4() + "-" + S4() + "-" + S4() + S4() + S4();
      };
      listeners = {};
      cgid = "__ceGUID";
      addCustomEvent = function(obj, event, callback) {
        obj[cgid] = void 0;
        if (!obj[cgid]) {
          obj[cgid] = "ifvisible.object.event.identifier";
        }
        if (!listeners[obj[cgid]]) {
          listeners[obj[cgid]] = {};
        }
        if (!listeners[obj[cgid]][event]) {
          listeners[obj[cgid]][event] = [];
        }
        return listeners[obj[cgid]][event].push(callback);
      };
      fireCustomEvent = function(obj, event, memo2) {
        var ev, j, len, ref, results;
        if (obj[cgid] && listeners[obj[cgid]] && listeners[obj[cgid]][event]) {
          ref = listeners[obj[cgid]][event];
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            ev = ref[j];
            results.push(ev(memo2 || {}));
          }
          return results;
        }
      };
      removeCustomEvent = function(obj, event, callback) {
        var cl, i, j, len, ref;
        if (callback) {
          if (obj[cgid] && listeners[obj[cgid]] && listeners[obj[cgid]][event]) {
            ref = listeners[obj[cgid]][event];
            for (i = j = 0, len = ref.length; j < len; i = ++j) {
              cl = ref[i];
              if (cl === callback) {
                listeners[obj[cgid]][event].splice(i, 1);
                return cl;
              }
            }
          }
        } else {
          if (obj[cgid] && listeners[obj[cgid]] && listeners[obj[cgid]][event]) {
            return delete listeners[obj[cgid]][event];
          }
        }
      };
      return {
        add: addCustomEvent,
        remove: removeCustomEvent,
        fire: fireCustomEvent
      };
    }();
    const addEvent = function() {
      let setListener;
      return function(el, ev, fn) {
        if (!setListener) {
          if (el.addEventListener) {
            setListener = function(el2, ev2, fn2) {
              return el2.addEventListener(ev2, fn2.bind(ifvisible), false);
            };
          } else if (el.attachEvent) {
            setListener = function(el2, ev2, fn2) {
              return el2.attachEvent("on" + ev2, fn2, false);
            };
          } else {
            setListener = function(el2, ev2, fn2) {
              return el2["on" + ev2] = fn2;
            };
          }
        }
        return setListener(el, ev, fn);
      };
    }();
    const ie = function() {
      let check;
      let div = doc.createElement("div");
      let all = div.getElementsByTagName("i");
      let undef = void 0;
      let v = 3;
      check = function() {
        return div.innerHTML = "<!--[if gt IE " + ++v + "]><i></i><![endif]-->", all[0];
      };
      while (check()) {
        continue;
      }
      if (v > 4) {
        return v;
      } else {
        return undef;
      }
    }();
    if (typeof doc.hidden !== "undefined") {
      hidden = "hidden";
      visibilityChange = "visibilitychange";
    } else if (typeof doc.mozHidden !== "undefined") {
      hidden = "mozHidden";
      visibilityChange = "mozvisibilitychange";
    } else if (typeof doc.msHidden !== "undefined") {
      hidden = "msHidden";
      visibilityChange = "msvisibilitychange";
    } else if (typeof doc.webkitHidden !== "undefined") {
      hidden = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
    }
    function fireEvent(element, event) {
      var evt;
      if (typeof doc.createEventObject !== "undefined") {
        return element.fireEvent("on" + event, evt);
      } else {
        evt = doc.createEvent("HTMLEvents");
        evt.initEvent(event, true, true);
        return !element.dispatchEvent(evt);
      }
    }
    ;
    function trackIdleStatus() {
      let timer;
      let wakeUp;
      wakeUp = function() {
        clearTimeout(timer);
        if (status !== "active") {
          wakeup();
        }
        idleStartedTime = +new Date();
        return timer = setTimeout(() => {
          if (status === "active") {
            return idle2();
          }
        }, idleTime);
      };
      wakeUp();
      addEvent(doc, "mousemove", wakeUp);
      addEvent(doc, "mouseup", wakeUp);
      addEvent(doc, "keyup", wakeUp);
      addEvent(doc, "touchstart", wakeUp);
      addEvent(window, "scroll", wakeUp);
      addEvent(window, "resize", wakeUp);
      focus(wakeUp);
      return wakeup(wakeUp);
    }
    ;
    function init() {
      var _blur;
      if (initialized) {
        return true;
      }
      if (!hidden) {
        _blur = "blur";
        if (ie && ie < 9) {
          _blur = "focusout";
        }
        addEvent(window, _blur, function() {
          return ifvisible.blur();
        });
        addEvent(window, "focus", function() {
          return ifvisible.focus();
        });
      } else {
        addEvent(doc, visibilityChange, function() {
          if (doc.hidden) {
            return blur();
          } else {
            return focus();
          }
        }, false);
      }
      initialized = true;
      return trackIdleStatus();
    }
    ;
    const name3 = "ifvisible";
    function setIdleDuration(seconds) {
      return idleTime = seconds * 1e3;
    }
    function getIdleDuration() {
      return idleTime;
    }
    function getIdleInfo() {
      let now2;
      let res;
      now2 = +new Date();
      res = {};
      if (status === "idle") {
        res.isIdle = true;
        res.idleFor = now2 - idleStartedTime;
        res.timeLeft = 0;
        res.timeLeftPer = 100;
      } else {
        res.isIdle = false;
        res.idleFor = now2 - idleStartedTime;
        res.timeLeft = idleStartedTime + idleTime - now2;
        res.timeLeftPer = (100 - res.timeLeft * 100 / idleTime).toFixed(2);
      }
      return res;
    }
    function focus(callback) {
      if (typeof callback === "function") {
        on("focus", function(event) {
          callback(event);
        });
      } else {
        status = "active";
        customEvent.fire(ifvisible, "focus");
        customEvent.fire(ifvisible, "wakeup");
        customEvent.fire(ifvisible, "statusChanged", {
          status
        });
      }
      return ifvisible;
    }
    function blur(callback) {
      if (typeof callback === "function") {
        on("blur", function(event) {
          callback(event);
        });
      } else {
        status = "hidden";
        customEvent.fire(ifvisible, "blur");
        customEvent.fire(ifvisible, "idle");
        customEvent.fire(ifvisible, "statusChanged", {
          status
        });
      }
      return ifvisible;
    }
    function idle2(callback) {
      if (typeof callback === "function") {
        on("idle", function(event) {
          callback(event);
        });
      } else {
        status = "idle";
        customEvent.fire(ifvisible, "idle");
        customEvent.fire(ifvisible, "statusChanged", {
          status
        });
      }
      return ifvisible;
    }
    function wakeup(callback) {
      if (typeof callback === "function") {
        on("wakeup", (event) => callback(event));
      } else {
        status = "active";
        customEvent.fire(ifvisible, "wakeup");
        customEvent.fire(ifvisible, "statusChanged", {
          status
        });
      }
      return ifvisible;
    }
    function on(name4, callback) {
      init();
      customEvent.add(ifvisible, name4, callback);
      return ifvisible;
    }
    function off(name4, callback) {
      init();
      customEvent.remove(ifvisible, name4, callback);
      return ifvisible;
    }
    function onEvery(seconds, callback) {
      let paused = false;
      let t;
      init();
      if (callback) {
        t = setInterval(function() {
          if (status === "active" && !paused) {
            return callback();
          }
        }, seconds * 1e3);
      }
      return {
        stop: function() {
          return clearInterval(t);
        },
        pause: function() {
          return paused = true;
        },
        resume: function() {
          return paused = false;
        },
        code: t,
        callback
      };
    }
    function now(check) {
      init();
      return status === (check || "active");
    }
    ;
    return {
      name: name3,
      setIdleDuration,
      getIdleDuration,
      getIdleInfo,
      wakeup,
      idle: idle2,
      focus,
      blur,
      on,
      off,
      onEvery,
      now
    };
  })();
  pn.container.register("ifvisible", {
    useValue: ifvisible
  });
  pn.ifvisible = pn.container.resolve("ifvisible");

  // ../src/lib/activetimer.ts
  var activeTimer = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const ifvisible2 = pn.container.resolve("ifvisible");
    const name3 = "activetimer";
    let minutes = 0;
    let startStopTimes = [];
    let idleTimeout = 60;
    let idleAfterMediaTimeout = 15;
    let isPageActive = true;
    let activeMedia;
    const startTimer = () => {
      resetWaitMediaStopped();
      var latestStartStopEntry = startStopTimes[startStopTimes.length - 1];
      if (latestStartStopEntry !== void 0 && latestStartStopEntry.stopTime === void 0) {
        return;
      }
      startStopTimes.push({
        "startTime": new Date(),
        "startMinute": minutes,
        "stopTime": void 0
      });
    };
    const stopTimer = () => {
      if (startStopTimes.length === 0) {
        return;
      }
      if (isPageActive) {
        return;
      }
      if (isAnyMediaPlayed()) {
        waitMediaStopped();
        return;
      }
      var latestStartStopEntry = startStopTimes[startStopTimes.length - 1];
      if (latestStartStopEntry.stopTime === void 0) {
        latestStartStopEntry.stopTime = new Date();
        latestStartStopEntry.stopMinute = minutes;
      }
    };
    const getActiveTimeInSeconds = () => {
      var timeSpentOnPageInMilliseconds = 0;
      for (var i = 0; i < startStopTimes.length; i++) {
        var startTime = startStopTimes[i].startTime;
        var stopTime = startStopTimes[i].stopTime;
        var startMinute = startStopTimes[i].startMinute;
        var stopMinute = startStopTimes[i].stopMinute;
        if (stopTime === void 0) {
          stopTime = new Date();
          stopMinute = minutes;
        }
        timeSpentOnPageInMilliseconds += getDifference(stopTime, startTime, stopMinute, startMinute);
      }
      return Math.floor(timeSpentOnPageInMilliseconds / 1e3);
    };
    const getTotalTimeInSeconds = () => {
      var timeFromFirstStartInMilliseconds = 0;
      var firstStartStopEntry = startStopTimes[0];
      if (firstStartStopEntry !== void 0) {
        var startTime = firstStartStopEntry.startTime;
        var startMinute = firstStartStopEntry.startMinute;
        var stopTime = new Date();
        var stopMinute = minutes;
        timeFromFirstStartInMilliseconds = getDifference(stopTime, startTime, stopMinute, startMinute);
      }
      return Math.floor(timeFromFirstStartInMilliseconds / 1e3);
    };
    const getDifference = (stopTime, startTime, stopMinute, startMinute) => {
      var correctionMinutes = 10;
      var difference = Math.abs(stopTime.getTime() - startTime.getTime());
      var minutesDifference = stopMinute - startMinute;
      if (difference > (minutesDifference + correctionMinutes) * 6e4) {
        difference = minutesDifference * 6e4;
      }
      return difference;
    };
    const setIdleDurationInSeconds = (duration) => {
      var durationFloat = parseFloat(duration);
      if (!isNaN(durationFloat)) {
        ifvisible2.setIdleDuration(durationFloat);
        idleTimeout = durationFloat;
      } else {
        throw {
          name: "InvalidDurationException",
          message: "An invalid duration time (" + duration + ") was provided."
        };
      }
    };
    const resetRecordedTime = () => {
      startStopTimes = [];
      startTimer();
    };
    const listenForVisibilityEvents = () => {
      ifvisible2.on("blur", () => {
        isPageActive = false;
        stopTimer();
      });
      ifvisible2.on("focus", () => {
        isPageActive = true;
        startTimer();
      });
      ifvisible2.on("idle", () => {
        if (idleTimeout > 0) {
          isPageActive = false;
          stopTimer();
        }
      });
      ifvisible2.on("wakeup", () => {
        if (idleTimeout > 0) {
          isPageActive = true;
          startTimer();
        }
      });
    };
    const isAnyMediaPlayed = () => {
      activeMedia = jqUtils2.filter("video,audio", (el) => {
        return !el.paused;
      });
      return !!activeMedia.length;
    };
    const stopTimerAfterMedia = () => {
      setTimeout(() => {
        stopTimer();
      }, idleAfterMediaTimeout * 1e3);
    };
    const waitMediaStopped = () => {
      if (!activeMedia) {
        return;
      }
      activeMedia.forEach(function(media) {
        jqUtils2.on(media, "pause", stopTimerAfterMedia);
      });
    };
    const resetWaitMediaStopped = () => {
      if (!activeMedia) {
        return;
      }
      activeMedia.forEach(function(media) {
        jqUtils2.off(media, "pause", stopTimerAfterMedia);
      });
    };
    const initialize = (duration) => {
      if (duration) {
        setIdleDurationInSeconds(duration);
      }
      listenForVisibilityEvents();
      startTimer();
      setInterval(() => {
        minutes++;
      }, 6e4);
    };
    return {
      name: name3,
      setIdleDurationInSeconds,
      getActiveTimeInSeconds,
      getTotalTimeInSeconds,
      resetRecordedTime,
      startTimer,
      stopTimer,
      initialize
    };
  })();
  pn.container.register("activetimer", {
    useValue: activeTimer
  });
  pn.activetimer = pn.container.resolve("activetimer");

  // ../src/lib/doubleClickForPublisher.ts
  var doubleClickForPublisher = (() => {
    const name3 = "doubleClickForPublisher";
    let ads = {};
    let adsIdsStack = [];
    let _subscribed = false;
    let _customHandler;
    const EVENT_SOURCE = {
      RENDERED_FOR_CURRENT_UNIT: 1,
      DID_NOT_RENDER_BUT_VIEWED: 2,
      RECIEVED_FROM_GET_SLOTS: 3
    };
    function adSubscribe() {
      if (_subscribed) {
        return false;
      }
      _subscribed = true;
      try {
        var googletag = window.googletag = window.googletag || {};
        googletag.cmd = googletag.cmd || [];
        googletag.cmd.push(() => {
          googletag.pubads().addEventListener("slotRenderEnded", adRendered);
          googletag.pubads().addEventListener("impressionViewable", adViewable);
          googletag.companionAds().addEventListener("slotRenderEnded", adRendered);
          googletag.companionAds().addEventListener("impressionViewable", adViewable);
        });
        if (googletag.apiReady) {
          googletag.cmd.push(() => {
            getAdSlots(googletag.pubads().getSlots());
            getAdSlots(googletag.companionAds().getSlots());
          });
        }
        return true;
      } catch (e) {
        error(e);
        return false;
      }
    }
    function initialize(force) {
      if (force) {
        resetAds();
        _subscribed = false;
      }
      adSubscribe();
    }
    initialize();
    function setCustomHandler(fn) {
      _customHandler = fn;
    }
    function customHandle(ad, id) {
      if (typeof _customHandler === "function") {
        _customHandler(ad, id);
      }
    }
    function getAds(lastAdsCount) {
      var result = [];
      var startIndex = 0;
      var adsIdsStackLength = adsIdsStack.length;
      if (lastAdsCount && isInteger(lastAdsCount) && lastAdsCount > 0 && lastAdsCount < adsIdsStackLength) {
        startIndex = adsIdsStackLength - lastAdsCount;
      }
      for (var i = startIndex; i < adsIdsStackLength; i++) {
        var adsId = adsIdsStack[i];
        if (!hasAdsOwnsProperty(adsId)) {
          continue;
        }
        result.push(ads[adsId]);
      }
      return result;
    }
    function hasAdsOwnsProperty(id) {
      return id && ads[id] !== void 0 && ads[id] !== null && ads.hasOwnProperty(id);
    }
    function resetAds() {
      ads = {};
      adsIdsStack = [];
    }
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function getAdSlots(slots) {
      for (var i = 0; i < slots.length; i++) {
        var slot = slots[i];
        adRendered({
          eventSource: EVENT_SOURCE.RECIEVED_FROM_GET_SLOTS,
          slot
        });
      }
    }
    function getSlotInfo(event) {
      var ad;
      try {
        var serviceName = event.serviceName;
        var slot = event.slot;
        if (!serviceName) {
          var services = event.slot.getServices();
          if (services && services.length) {
            serviceName = services[0].getName();
          }
        }
        var slotInfo = slot.getResponseInformation() || {};
        var slotId = slot.getSlotId ? slot.getSlotId() : {};
        var elementId = slot.getSlotElementId ? slot.getSlotElementId() : slotId.getDomId ? slotId.getDomId() : null;
        ad = {
          companion: serviceName ? serviceName === "companion_ads" : false,
          adUnit: slot.getAdUnitPath ? slot.getAdUnitPath() : 0,
          isEmpty: event.isEmpty,
          elementId,
          advertiserId: event.advertiserId || slotInfo.advertiserId,
          campaignId: event.campaignId || slotInfo.campaignId,
          lineItemId: event.lineItemId || slotInfo.lineItemId,
          creativeId: event.creativeId || slotInfo.creativeId,
          eventSource: event.eventSource || null,
          size: event.size && event.size.slice(0, 2) || null,
          viewed: false,
          position: null
        };
        var element = document.getElementById(elementId);
        if (elementId && element) {
          ad.position = {
            top: element.offsetTop,
            left: element.offsetLeft
          };
          if (event.isEmpty === void 0) {
            ad.isEmpty = element.offsetWidth <= 0 && element.offsetHeight <= 0;
            if (!ad.isEmpty && !ad.size) {
              var sizes = slot.getSizes();
              if (sizes && sizes.length) {
                ad.size = typeof sizes[0] === "object" ? [sizes[0].getWidth(), sizes[0].getHeight()] : sizes[0];
              }
            }
          }
        }
      } catch (e) {
        error(e);
      }
      return ad;
    }
    function adRendered(event) {
      event.eventSource = event.eventSource || EVENT_SOURCE.RENDERED_FOR_CURRENT_UNIT;
      var ad = getSlotInfo(event);
      var id = getAdId(event.slot);
      if (!id) {
        return;
      }
      if (ads[id]) {
        ad.viewed = ads[id].viewed;
      } else {
        adsIdsStack.push(id);
      }
      ads[id] = ad;
      customHandle(ad, id);
    }
    function adViewable(event) {
      var id = getAdId(event.slot);
      if (!id) {
        return;
      }
      var ad = ads[id] || getSlotInfo(event);
      if (!hasAdsOwnsProperty(id)) {
        ads[id] = ad;
        adsIdsStack.push(id);
      }
      if (ad.companion === void 0) {
        ad.companion = event.serviceName === "companion_ads";
      }
      if (!ad.eventSource || ad.eventSource > EVENT_SOURCE.DID_NOT_RENDER_BUT_VIEWED) {
        ad.eventSource = EVENT_SOURCE.DID_NOT_RENDER_BUT_VIEWED;
      }
      ad.viewed = true;
      customHandle(ad, id);
    }
    function getAdId(slot) {
      try {
        var slotId = slot.getSlotId ? slot.getSlotId() : {};
        var elementId = slot.getSlotElementId ? slot.getSlotElementId() : slotId.getDomId ? slotId.getDomId() : null;
        var instance2 = slot.getAdUnitPath ? slot.getAdUnitPath() : 0;
        var id = slotId.getId ? slotId.getId() : 0;
        return [elementId, id, instance2].join(":");
      } catch (e) {
        error(e);
      }
    }
    function error(e) {
      if (pn && pn.util && pn.util.error) {
        pn.util.error("DFP module error: ", e);
      }
    }
    return {
      name: name3,
      initialize,
      setCustomHandler,
      getAds,
      resetAds
    };
  })();
  pn.container.register("doubleClickForPublisher", {
    useValue: doubleClickForPublisher
  });
  pn.doubleClickForPublisher = pn.container.resolve("doubleClickForPublisher");

  // ../src/lib/applePay.ts
  var applePay = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const name3 = "applePay";
    const applePayJsApiVersion = 2;
    let braintreeClientLoaded = false;
    let deviceDataCollectorLoaded = false;
    let braintreeApplePayLoaded = false;
    const clientSrc = "https://js.braintreegateway.com/web/3.79.1/js/client.min.js";
    const applePaySrc = "https://js.braintreegateway.com/web/3.79.1/js/apple-pay.min.js";
    const deviceDataCollectorSrc = "https://js.braintreegateway.com/web/3.79.1/js/data-collector.min.js";
    let session;
    let btApplePayInstance;
    let btClientInstance;
    let deviceDataCollectorInstance;
    let paymentRequest;
    let requestEmail;
    let requestPostalAddress;
    let clientToken;
    let termId = "";
    postmessage2.subscribe("loaded", () => {
      applePayCanMakePayments();
    });
    postmessage2.subscribe("startCheckout", () => {
      applePayCanMakePayments();
    });
    postmessage2.subscribe("applePayBtClientToken", (data) => {
      initPayment(data.params.clientToken);
    });
    postmessage2.subscribe("applePayBtCheckoutFlowProperties", (data) => {
      requestEmail = data.params.requestEmail;
      requestPostalAddress = data.params.requestPostalAddress;
    });
    postmessage2.subscribe("applyTaxFailed", (data) => {
      session.abort();
    });
    postmessage2.subscribe("checkApplePayBtInstance", (data) => {
      if (btApplePayInstance) {
        postmessage2.broadcast("applePayInit", {});
      }
    });
    postmessage2.subscribe("applyTaxCompleted", (data) => {
      completePayment(data.params);
    });
    postmessage2.subscribe("applePayBtBeginSession", (data) => {
      let copiedPostMessageParams = {};
      const postMessageParams = data.params;
      if (postMessageParams.resourceTitle) {
        copiedPostMessageParams = postMessageParams;
      }
      if (postMessageParams.termId) {
        termId = postMessageParams.termId || "";
      }
      var paymentRequestParams = {
        currencyCode: postMessageParams.currencyCode,
        total: {
          label: postMessageParams.resourceTitle,
          amount: postMessageParams.chargeAmount
        }
      };
      requestAdditionalPaymentInfo(paymentRequestParams);
      try {
        paymentRequest = btApplePayInstance.createPaymentRequest(paymentRequestParams);
      } catch (msg) {
        postmessage2.broadcast("payment-error", { errorCode: 101 });
      }
      session = new window.ApplePaySession(applePayJsApiVersion, paymentRequest);
      session.onvalidatemerchant = (event) => {
        btApplePayInstance.performValidation({
          validationURL: event.validationURL,
          displayName: postMessageParams.resourceTitle || copiedPostMessageParams.resourceTitle
        }, (validationErr, merchantSession) => {
          if (validationErr) {
            session.abort();
            postmessage2.broadcast("payment-error", { errorCode: 102 });
            return;
          }
          session.completeMerchantValidation(merchantSession);
        });
      };
      session.onpaymentauthorized = (event) => {
        btApplePayInstance.tokenize({
          token: event.payment.token
        }, (tokenizeErr, payload) => {
          if (tokenizeErr) {
            postmessage2.broadcast("payment-error", { errorCode: 103 });
            session.completePayment(window.ApplePaySession.STATUS_FAILURE);
            return;
          }
          var applePayPayloadData = {
            nonce: payload.nonce,
            cardType: payload.details.cardType
          };
          if (requestEmail || requestPostalAddress) {
            onPaymentAuthorized(event, applePayPayloadData);
          } else {
            completePayment(applePayPayloadData);
          }
        });
      };
      session.begin();
    });
    const applePayCanMakePayments = () => {
      var canMakePayments = util2.__protected__.isApplePayAllowed();
      postmessage2.broadcast("EVENT_APPLE_PAY_CAN_MAKE_PAYMENTS", { canMakePayments });
    };
    const requestAdditionalPaymentInfo = (paymentRequestParams) => {
      if (requestEmail) {
        paymentRequestParams.requiredShippingContactFields = ["email"];
      }
      if (requestPostalAddress) {
        paymentRequestParams.requiredBillingContactFields = ["postalAddress"];
      }
    };
    const onPaymentAuthorized = (event, data) => {
      const billingContact = event.payment.billingContact;
      let params = {
        countryCode: billingContact.countryCode ? billingContact.countryCode.toUpperCase() : billingContact.countryCode,
        zipCode: billingContact.postalCode,
        billingZipCode: billingContact.postalCode,
        nonce: data.nonce,
        cardType: data.cardType
      };
      if (event.payment.shippingContact) {
        params.user = {
          email: event.payment.shippingContact.emailAddress
        };
      }
      postmessage2.broadcast("applePayPaymentAuthorized" + termId, params);
    };
    const completePayment = (data) => {
      session.completePayment(window.ApplePaySession.STATUS_SUCCESS);
      data.deviceData = deviceDataCollectorInstance.deviceData;
      postmessage2.broadcast("applePayNonce" + termId, data);
    };
    const initPayment = (token) => {
      clientToken = token;
      addClientScript();
    };
    const initBraintree = () => {
      window.braintree.client.create({
        authorization: clientToken
      }).then((clientInstance) => {
        btClientInstance = clientInstance;
        return window.braintree.dataCollector.create({
          client: clientInstance,
          kount: true,
          paypal: true
        });
      }).then((dataCollectorInstance) => {
        deviceDataCollectorInstance = dataCollectorInstance;
        return btClientInstance;
      }).then((clientInstance) => {
        window.braintree.applePay.create({
          client: clientInstance
        }, (applePayErr, applePayInstance) => {
          if (applePayErr) {
            postmessage2.broadcast("payment-error", { errorCode: 101 });
            return;
          }
          btApplePayInstance = applePayInstance;
          postmessage2.broadcast("applePayInit", {});
        });
      }).catch((clientErr) => {
        if (clientErr) {
          postmessage2.broadcast("payment-error", { errorCode: 100 });
          util2.error("[TP] Client error: " + clientErr.message);
          return;
        }
      });
    };
    const addClientScript = () => {
      if (isClientScriptAdded()) {
        return;
      }
      addScript(clientSrc, () => {
        braintreeClientLoaded = true;
        addDeviceDataCollectorScript();
      });
    };
    const addDeviceDataCollectorScript = () => {
      if (isDeviceDataCollectorScriptAdded()) {
        return;
      }
      addScript(deviceDataCollectorSrc, () => {
        deviceDataCollectorLoaded = true;
        addApplePayScript();
      });
    };
    const addApplePayScript = () => {
      if (isApplePayScriptAdded()) {
        return;
      }
      addScript(applePaySrc, () => {
        braintreeApplePayLoaded = true;
        initBraintree();
      });
    };
    const addScript = (src, onload) => {
      util2.addScript(src, onload);
    };
    const isClientScriptAdded = () => {
      return util2.isScriptAdded(clientSrc);
    };
    const isDeviceDataCollectorScriptAdded = () => {
      return util2.isScriptAdded(deviceDataCollectorSrc);
    };
    const isApplePayScriptAdded = () => {
      return util2.isScriptAdded(applePaySrc);
    };
    return {
      name: name3
    };
  })();
  pn.container.register("applePay", {
    useValue: applePay
  });
  pn.applePay = pn.container.resolve("applePay");

  // ../src/lib/goCardlessDropin.ts
  var goCardlessDropin = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const name3 = "goCardlessDropin";
    let sender = "";
    let params = {
      environment: "",
      billingRequestFlowId: ""
    };
    let upi = {
      customer: "",
      mandate: "",
      bank_account_ending: "",
      bank_account_holder: "",
      bank_name: "",
      currency: ""
    };
    let billingRequestFlowPromise = null;
    let isGoCardlessLoaded = false;
    const goCardlessDropinSrc = "https://pay.gocardless.com/billing/static/dropin/v2/initialise.js";
    postmessage2.subscribe("LOAD_GOCARDLESS_DROPIN", (data) => {
      sender = data.sender;
      if (isGoCardlessLoaded) {
        postmessage2.send("GOCARDLESS_DROPIN_LOADED", null, sender);
        return;
      }
      addScript(goCardlessDropinSrc, () => {
        isGoCardlessLoaded = true;
        postmessage2.send("GOCARDLESS_DROPIN_LOADED", null, sender);
      });
    });
    postmessage2.subscribe("GOCARDLESS_DROPIN_MANDATE_CREATION_INIT", (data) => {
      params = data.params;
      if (isGoCardlessLoaded) {
        initiatePaymentProcess();
      }
    });
    const initiatePaymentProcess = () => {
      const dropInModalHandler = window.GoCardlessDropin.create({
        billingRequestFlowID: params.billingRequestFlowId,
        environment: params.environment,
        onSuccess: (billingRequest) => {
          const { customer, mandate_request_mandate } = billingRequest.links;
          const { account_number_ending, account_holder_name, bank_name } = billingRequest.resources.customer_bank_account;
          const { currency } = billingRequest.mandate_request;
          upi = {
            customer,
            mandate: mandate_request_mandate,
            bank_account_ending: account_number_ending,
            bank_account_holder: account_holder_name,
            bank_name,
            currency
          };
          billingRequestFlowPromise = null;
          postmessage2.send("GOCARDLESS_DROPIN_MANDATE_CREATION_COMPLETE", upi, sender);
        },
        onExit: (error) => {
          billingRequestFlowPromise = null;
          if (error) {
            postmessage2.send("payment-error", { message: error }, sender);
          } else {
            postmessage2.send("GOCARDLESS_DROPIN_ENABLE_PLUGIN", null, sender);
          }
        }
      });
      dropInModalHandler.open();
    };
    const addScript = (src, onload) => {
      util2.addScript(src, onload);
    };
    return {
      name: name3
    };
  })();
  pn.container.register("goCardlessDropin", {
    useValue: goCardlessDropin
  });
  pn.goCardlessDropin = pn.container.resolve("goCardlessDropin");

  // ../src/lib/braintreeGooglePayIntegrationService.ts
  var braintreeGooglePayIntegrationService = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const name3 = "braintreeGooglePayIntegrationService";
    let isInit = false;
    const clientSrc = "https://js.braintreegateway.com/web/3.76.4/js/client.min.js";
    const googlePaymentSrc = "https://js.braintreegateway.com/web/3.76.4/js/google-payment.min.js";
    const payJsSrc = "https://pay.google.com/gp/p/js/pay.js";
    const deviceDataCollectorSrc = "https://js.braintreegateway.com/web/3.76.4/js/data-collector.min.js";
    let btClientInstance;
    let deviceDataCollectorInstance;
    let paymentsClient;
    let googlePaymentInstance;
    let googlePayConfig;
    const initialize = function() {
      if (isInit) {
        return;
      }
      isInit = true;
      postmessage2.subscribe("braintree-google-pay-initiate-start", initiateStartCallback);
      postmessage2.subscribe("braintree-google-pay-show-pay-window", showPayWindowCallback);
    };
    const initiateStartCallback = (data) => {
      googlePayConfig = data.params;
      loadDynamicScript(clientSrc).then(() => {
        return loadDynamicScript(deviceDataCollectorSrc);
      }).then(() => {
        return loadDynamicScript(googlePaymentSrc);
      }).then(() => {
        return loadDynamicScript(payJsSrc);
      }).then(() => {
        return init();
      }).then((params) => {
        postmessage2.broadcast("braintree-google-pay-initiate-end", params);
      }).catch((error) => {
        util2.error(error);
        postmessage2.broadcast("braintree-google-pay-error", error);
      });
    };
    const showPayWindowCallback = (data) => {
      makePayment(data.params);
    };
    const makePayment = (data) => {
      const { currencyCode, amount } = data;
      let paymentDataRequest = googlePaymentInstance.createPaymentDataRequest({
        transactionInfo: {
          currencyCode,
          totalPriceStatus: "FINAL",
          totalPrice: amount
        }
      });
      let cardPaymentMethod = paymentDataRequest.allowedPaymentMethods[0];
      cardPaymentMethod.parameters.billingAddressRequired = true;
      cardPaymentMethod.parameters.billingAddressParameters = {
        format: "FULL",
        phoneNumberRequired: true
      };
      paymentDataRequest.callbackIntents = ["PAYMENT_AUTHORIZATION"];
      getPaymentsClient().loadPaymentData(paymentDataRequest).then(function(paymentData) {
        return paymentData;
      }).catch(function(error) {
        if (error.statusCode !== "CANCELED") {
          util2.error(error);
          postmessage2.broadcast("braintree-google-pay-error", error.message || error.statusMessage);
        }
      });
    };
    const init = () => {
      return createClientInstance().then(() => {
        return initDeviceDataCollector();
      }).then(() => {
        return initBraintreeGooglePay();
      });
    };
    const createClientInstance = () => {
      return window.braintree.client.create({
        authorization: googlePayConfig.clientToken
      }).then(function(client) {
        btClientInstance = client;
      });
    };
    const initDeviceDataCollector = () => {
      return window.braintree.dataCollector.create({
        client: btClientInstance,
        kount: true,
        paypal: true
      }).then(function(data) {
        deviceDataCollectorInstance = data;
      });
    };
    const initBraintreeGooglePay = () => {
      paymentsClient = null;
      return window.braintree.googlePayment.create({
        client: btClientInstance,
        googlePayVersion: 2,
        googleMerchantId: googlePayConfig.merchantId
      }).then(function(instance2) {
        googlePaymentInstance = instance2;
        return getPaymentsClient().isReadyToPay({
          apiVersion: 2,
          apiVersionMinor: 0,
          allowedPaymentMethods: configureAvailablePaymentMethods(),
          existingPaymentMethodRequired: true
        });
      });
    };
    const getPaymentsClient = () => {
      if (paymentsClient) {
        return paymentsClient;
      }
      paymentsClient = new window.google.payments.api.PaymentsClient({
        environment: googlePayConfig.environment,
        paymentDataCallbacks: {
          onPaymentAuthorized: function(paymentData) {
            const parsedResponse = parseResponse(paymentData);
            return parsedResponse.then(function(parsedResponse2) {
              postmessage2.broadcast("braintree-google-pay-payment-complete", Object.assign({}, parsedResponse2, deviceDataCollectorInstance));
              return {
                transactionState: "SUCCESS"
              };
            }).catch(function(error) {
              util2.error(error);
              postmessage2.broadcast("braintree-google-pay-error", error);
              return {
                transactionState: "ERROR",
                error
              };
            });
          }
        }
      });
      return paymentsClient;
    };
    const parseResponse = (paymentData) => {
      return googlePaymentInstance.parseResponse(paymentData);
    };
    const configureAvailablePaymentMethods = () => {
      let methods = googlePaymentInstance.createPaymentDataRequest().allowedPaymentMethods;
      return methods.filter((m) => m.type !== "PAYPAL");
    };
    const loadDynamicScript = (src) => {
      return new Promise(function(resolve) {
        var _a;
        if (util2.isScriptAdded(src)) {
          resolve(null);
          return;
        }
        var a = document.createElement("script");
        var b = document.getElementsByTagName("script")[0];
        (_a = b.parentNode) == null ? void 0 : _a.insertBefore(a, b);
        a.type = "text/javascript";
        a.async = true;
        a.onload = function() {
          resolve(null);
        };
        a.src = src;
      });
    };
    return {
      name: name3,
      initialize
    };
  })();
  pn.container.register("braintreeGooglePayIntegrationService", {
    useValue: braintreeGooglePayIntegrationService
  });
  pn.braintreeGooglePayIntegrationService = pn.container.resolve("braintreeGooglePayIntegrationService");

  // ../src/lib/applePayIntegrationService.ts
  var applePayIntegrationService = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const name3 = "applePayIntegrationService";
    const applePayJsApiVersion = 3;
    let resourceName;
    let session;
    let canMakePayments = false;
    let termId;
    const initialize = () => {
      const isTermIdEqual = (idOfTerm) => {
        return termId ? termId === idOfTerm : true;
      };
      const createRequest = (postMessageParams) => {
        var request = {
          countryCode: postMessageParams.params.countryCode,
          currencyCode: postMessageParams.params.currencyCode,
          supportedNetworks: ["visa", "masterCard", "amex", "discover"],
          merchantCapabilities: ["supports3DS"],
          requiredShippingContactFields: postMessageParams.params.requiredShippingContactFields || [],
          requiredBillingContactFields: postMessageParams.params.requiredBillingContactFields || [],
          total: {
            label: postMessageParams.params.resourceName,
            amount: postMessageParams.params.chargeAmount
          }
        };
        return request;
      };
      const abortSession = () => {
        try {
          session.abort();
        } catch (e) {
          util2.error(e);
        }
      };
      const validateMerchantAndRequestPaymentSession = (validationUrl, displayedCaption) => {
        var request = {
          validationUrl,
          displayedCaption,
          userToken: null,
          userProvider: null,
          userRef: null,
          janrainCaptureToken: null,
          domainName: window.location.hostname,
          aid: null,
          termId,
          merchantIdentifier: tp.applePayMerchantId
        };
        postmessage2.broadcast("apple-pay-pay-session-request", request);
      };
      const initPwApplePay = () => {
        canMakePayments = util2.__protected__.isApplePayAllowed();
        postmessage2.broadcast("EVENT_APPLE_PAY_CAN_MAKE_PAYMENTS", { canMakePayments });
      };
      postmessage2.subscribe("provider-component-initiated", () => {
        if (canMakePayments) {
          postmessage2.broadcast("apple-pay-init", {});
        }
      });
      postmessage2.subscribe("initPwApplePay", () => {
        initPwApplePay();
      });
      postmessage2.subscribe("startCheckout", () => {
        initPwApplePay();
      });
      postmessage2.subscribe("pay-session-received", (postMessageParams) => {
        try {
          session.completeMerchantValidation(postMessageParams.params.applePaySession);
        } catch (e) {
          postmessage2.broadcast("payment-error", { errorCode: 111, errors: e });
        }
      });
      postmessage2.subscribe("apple-pay-complete-payment", (postMessageParams) => {
        if (!isTermIdEqual(postMessageParams.params.termId)) {
          return;
        }
        session.completePayment(postMessageParams.params.status, postMessageParams.params.errors);
      });
      postmessage2.subscribe("start-purchase", (postMessageParams) => {
        termId = postMessageParams.params.termId || "";
        resourceName = postMessageParams.params.resourceName;
        session = new window.ApplePaySession(applePayJsApiVersion, createRequest(postMessageParams));
        session.onvalidatemerchant = (event) => {
          validateMerchantAndRequestPaymentSession(event.validationURL, resourceName);
        };
        session.onpaymentauthorized = (event) => {
          try {
            postmessage2.broadcast("apple-pay-payment-authorized", {
              paymentData: event.payment,
              termId,
              merchantIdentifier: tp.applePayMerchantId
            });
          } catch (e) {
            postmessage2.broadcast("payment-error", { errorCode: 110, error: e });
          }
        };
        try {
          session.begin();
        } catch (e) {
          postmessage2.broadcast("payment-error", { errorCode: 112, error: e, termId });
        }
      });
      postmessage2.subscribe("abort-apple-pay-session", () => {
        abortSession();
      });
    };
    const applePayCanMakePaymentsWithActiveCard = () => {
      var rejectResult = {
        then: function(callbackFn) {
          return callbackFn(null);
        },
        catch: function() {
        }
      };
      if (!pn.applePayMerchantId) {
        return rejectResult;
      }
      var ifCanMakePayments = util2.__protected__.isApplePayAllowed();
      if (ifCanMakePayments && pn.applePayMerchantId) {
        return window.ApplePaySession.canMakePaymentsWithActiveCard(pn.applePayMerchantId);
      } else {
        return rejectResult;
      }
    };
    return {
      name: name3,
      initialize,
      __protected__: {
        applePayCanMakePaymentsWithActiveCard
      }
    };
  })();
  pn.container.register("applePayIntegrationService", {
    useValue: applePayIntegrationService
  });
  pn.applePayIntegrationService = pn.container.resolve("applePayIntegrationService");

  // ../src/lib/datatransApplePayIntegrationService.ts
  var datatransApplePayIntegrationService = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const ajax3 = pn.container.resolve("ajax");
    const name3 = "datatransApplePayIntegrationService";
    const datatransApplePayButtonId = "datatrans-applepay-button";
    let isInitialized = false;
    let loadScriptPromise = null;
    let getConfigPromise = null;
    let iframeId;
    let initParams;
    let subscribed = false;
    const initialize = function() {
      if (!util2.__protected__.isApplePayAllowed() && isInitialized) {
        return;
      }
      isInitialized = true;
      postmessage2.subscribe("datatrans-applepay-loaded", pianoOnLoaded);
      postmessage2.subscribe("datatrans-applepay-checkout-initiate-purchase", pianoOnCheckoutInitPurchase);
      postmessage2.subscribe("datatrans-applepay-make-purchase", pianoOnApplePayMakePurchase);
    };
    const pianoOnLoaded = function(postMessageParams) {
      iframeId = postMessageParams.sender;
      getConfig().then(loadDynamicScript).then(subscribeToEvents);
    };
    const onError = (payload) => {
      postmessage2.send("datatrans-applepay-service-error", payload, iframeId);
    };
    const pianoOnCheckoutInitPurchase = function(postMessageParams) {
      initParams = postMessageParams.params;
      getConfig().then(loadDynamicScript).then(initPaymentButton).catch(() => {
        onError({
          eventName: "init-error",
          errorCode: 110
        });
      });
    };
    const initPaymentButton = () => {
      PaymentButton.init(initParams.applePayConfig);
    };
    const pianoOnApplePayMakePurchase = () => {
      var buttonContainer = document.getElementById(datatransApplePayButtonId);
      if (buttonContainer === null || buttonContainer.firstElementChild === null) {
        onError({
          eventName: "system-error",
          errorCode: 112
        });
        return;
      }
      buttonContainer.firstElementChild.click();
    };
    const getConfig = () => {
      if (getConfigPromise !== null) {
        return getConfigPromise;
      }
      getConfigPromise = new Promise((resolve) => {
        ajax3.request({
          url: tp.getApiEndpoint() + "/anon/datatrans/applepay/config",
          data: {
            aid: tp.aid
          },
          dataType: "jsonp",
          jsonpCallback: "jsonpCallback",
          success: function(response) {
            const { config } = response;
            resolve(config.url);
          }
        });
      });
      return getConfigPromise;
    };
    const loadDynamicScript = (url) => {
      if (loadScriptPromise !== null) {
        return loadScriptPromise;
      }
      const scriptId = "datatrans-apple-pay";
      let existingScript = document.getElementById(scriptId);
      if (!existingScript) {
        loadScriptPromise = new Promise((resolve) => {
          var script = document.createElement("script");
          script.addEventListener("load", () => resolve(null));
          script.src = url;
          script.id = scriptId;
          document.body.appendChild(script);
        });
        return loadScriptPromise;
      }
    };
    const subscribeToEvents = function() {
      if (subscribed) {
        return;
      }
      PaymentButton.on("init", paymentButtonOnInit);
      PaymentButton.on("create", paymentButtonOnCreate);
      PaymentButton.on("token", paymentButtonOnToken);
      PaymentButton.on("abort", () => {
        onError({
          eventName: "abort",
          errorCode: 0
        });
      });
      PaymentButton.on("unsupported", () => {
        onError({
          eventName: "unsupported",
          errorCode: 113
        });
      });
      PaymentButton.on("error", (payload) => {
        if (payload) {
          util2.error("datatransApplePayIntegrationService. apple pay button error: " + payload);
          onError({
            eventName: "error",
            errorCode: 112
          });
        }
      });
      subscribed = true;
    };
    const paymentButtonOnInit = () => {
      var container = prepareButtonContainer();
      PaymentButton.create(container, initParams.paymentConfig).catch(() => {
        onError({
          eventName: "create-error",
          errorCode: 111
        });
      });
    };
    const paymentButtonOnCreate = () => {
      util2.log("datatransApplePayIntegrationService paymentButtonOnCreate");
      postmessage2.send("datatrans-applepay-service-ready", null, iframeId);
    };
    const paymentButtonOnToken = (response) => {
      util2.log("datatransApplePayIntegrationService paymentButtonOnToken");
      postmessage2.send("datatrans-applepay-service-token", response.token.details.token, iframeId);
    };
    const prepareButtonContainer = () => {
      var container = document.getElementById(datatransApplePayButtonId);
      if (container === null) {
        container = document.createElement("div");
        container.setAttribute("id", datatransApplePayButtonId);
        container.style.display = "none";
        document.body.appendChild(container);
      }
      container.innerHTML = "";
      return container;
    };
    return {
      name: name3,
      initialize
    };
  })();
  pn.container.register("datatransApplePayIntegrationService", {
    useValue: datatransApplePayIntegrationService
  });
  pn.datatransApplePayIntegrationService = pn.container.resolve("datatransApplePayIntegrationService");

  // ../src/lib/stripeApplePayIntegrationService.ts
  var stripeApplePayIntegrationService = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const name3 = "stripeApplePayIntegrationService";
    let loadScriptPromise;
    let stripe = null;
    let paymentRequest = null;
    let canMakePayment = false;
    let termId = "";
    function initPostmessageListeners() {
      postmessage2.subscribe("stripe-applepay-initialized", function() {
        loadDynamicScript();
      });
      postmessage2.subscribe("stripe-applepay-initiate-purchase", function(postMessageParams) {
        loadDynamicScript().then(() => {
          let apiKey = postMessageParams.params.apiKey;
          let accountId = postMessageParams.params.accountId;
          if (stripe === null) {
            if (accountId) {
              stripe = window.Stripe(apiKey, { stripeAccount: accountId });
            } else {
              stripe = window.Stripe(apiKey);
            }
          }
          var paymentRequestPayload = postMessageParams.params.paymentRequestPayload;
          return stripe.paymentRequest(paymentRequestPayload);
        }).then((request) => {
          paymentRequest = request;
          return request.canMakePayment();
        }).then((payload) => {
          canMakePayment = payload && payload.applePay;
          postmessage2.broadcast("stripe-applepay-initiate-purchase-complete", {
            canMakePayment
          });
          if (!canMakePayment) {
            return;
          }
          paymentRequest.on("cancel", () => {
            postmessage2.broadcast("stripe-applepay-start-purchase-complete" + termId, {
              status: "fail"
            });
          });
          paymentRequest.on("paymentmethod", (ev) => {
            var address = ev.paymentMethod.billing_details.address;
            var billingAddress = {
              countryCode: address.country,
              zipCode: address.postal_code,
              billingZipCode: address.postal_code
            };
            var paymentMethodId = ev.paymentMethod.id;
            postmessage2.broadcast("stripe-applepay-start-purchase-complete" + termId, {
              status: "success",
              paymentMethodId,
              payerEmail: ev.payerEmail,
              billingAddress
            });
            ev.complete("success");
          });
        }).catch((error) => {
          util2.error(error);
          postmessage2.broadcast("stripe-applepay-initiate-purchase-complete", {
            canMakePayment: false
          });
        });
      });
      postmessage2.subscribe("stripe-applepay-start-purchase", function(postMessageParams) {
        termId = postMessageParams.params.termId || "";
        var paymentRequestPayload = postMessageParams.params.paymentRequestPayload;
        paymentRequest.update(paymentRequestPayload);
        paymentRequest.show();
      });
      postmessage2.subscribe("stripe-applepay-abort-request", function() {
        paymentRequest && paymentRequest.abort();
        postmessage2.broadcast("stripe-applepay-reopen-request");
      });
    }
    initPostmessageListeners();
    const loadDynamicScript = () => {
      if (loadScriptPromise != null) {
        return loadScriptPromise;
      }
      var existingScript = document.getElementById("stripe.js");
      if (!existingScript) {
        var script = document.createElement("script");
        script.src = "https://js.stripe.com/v3/";
        script.id = "stripe.js";
        document.body.appendChild(script);
        loadScriptPromise = new Promise(function(resolve) {
          script.onload = () => {
            resolve(null);
          };
        });
        return loadScriptPromise;
      }
    };
    return {
      name: name3
    };
  })();
  pn.container.register("stripeApplePayIntegrationService", {
    useValue: stripeApplePayIntegrationService
  });
  pn.stripeApplePayIntegrationService = pn.container.resolve("stripeApplePayIntegrationService");

  // ../src/lib/obi3DSChallenge.ts
  var obi3DSChallenge = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const name3 = "obi3DSChallenge";
    const initPostmessageListeners = () => {
      postmessage2.subscribe("obi-handle-3ds-challenge", (postMessageParams) => {
        var params = postMessageParams.params;
        if (!window.obick) {
          const trustedSources = ["https://jsl.qat.obi.aol.com/obipmservice/obick.umd.js", "https://jsl.prod.obi.aol.com/obipmservice/obick.umd.js"];
          if (trustedSources.indexOf(params.obickUrl) === -1) {
            util2.error("Untrusted obickUrl detected: " + params.obickUrl);
            return;
          }
          var script = document.createElement("script");
          script.src = params.obickUrl;
          script.id = "obick.js";
          document.body.appendChild(script);
          script.onload = () => {
            util2.log(`${script.id} onload`);
            handle3DS(params);
          };
        } else {
          handle3DS(params);
        }
      });
    };
    initPostmessageListeners();
    const handle3DS = (params) => {
      if (params.stepUpUrl && params.stepUpUrl.indexOf("http") !== 0) {
        util2.error("There is no link in params.stepUpUrl for OBI");
        return;
      }
      var data = {
        stepUpUrl: params.stepUpUrl,
        jwt: params.jwt,
        transactionId: params.transactionId,
        zIndex: params.zIndex
      };
      window.obick.handle3dsChallenge(data).then((result) => {
        util2.debug(result);
        postmessage2.broadcast("obi-3ds-challenge-complete", {
          threeDSTransactionId: result.threeDSTransactionId,
          challengeStatus: result.challengeStatus
        });
      }).catch((error) => {
        util2.error(error);
        postmessage2.broadcast("obi-3ds-challenge-complete", {
          error: "challenge-error",
          payload: error
        });
      });
    };
    return {
      name: name3
    };
  })();
  pn.container.register("obi3DSChallenge", {
    useValue: obi3DSChallenge
  });
  pn.obi3DSChallenge = pn.container.resolve("obi3DSChallenge");

  // ../src/lib/amp.ts
  var amp = (() => {
    const jqUtils2 = pn.container.resolve("jqUtils");
    const util2 = pn.container.resolve("util");
    const api2 = pn.container.resolve("api");
    const user2 = pn.container.resolve("user");
    const pianoId2 = pn.container.resolve("pianoId");
    const name3 = "amp";
    const composerOnlyProvider = "publisher_user";
    const globalConfig = {
      displayMode: "inline",
      containerSelector: "body",
      loginSuccess: bindUserWithReaderId
    };
    const READER_ID = "reader_id";
    const RETURN_URL = "return";
    const _getAmpExecutionUrl = () => {
      const aid = pn.aid;
      return "/" + aid + "/execution/amp";
    };
    const _getBindURL = () => {
      return _getAmpExecutionUrl() + "/login";
    };
    const _getUnbindURL = () => {
      return _getAmpExecutionUrl() + "/logout";
    };
    const goToReturnUrl = () => {
      window.location.href = util2.getQueryParamByName(RETURN_URL) + "#success=true";
    };
    const validUserState = (config) => {
      if (config && config.userState && jqUtils2.isPlainObject(config.userState)) {
        var keys2 = Object.keys(config.userState);
        if (keys2.filter(isUserStateNameValid).length !== keys2.length) {
          util2.error("user_state accept only contain letters, numbers and underscore");
          return false;
        }
      }
      return true;
    };
    function showLogin(config) {
      config = config ? config : {};
      var provider = user2.getProvider();
      if (provider.getName() === pianoId2.getName()) {
        var onBindUserWithReaderId;
        if (config.loginSuccess && jqUtils2.isFunction(config.loginSuccess)) {
          onBindUserWithReaderId = config.loginSuccess;
        } else {
          onBindUserWithReaderId = goToReturnUrl;
        }
        var loginSuccess = () => {
          bindUserWithReaderId({}, onBindUserWithReaderId);
        };
        var showConfig = Object.assign({}, globalConfig, config);
        if (user2.isUserValid()) {
          loginSuccess();
          return;
        }
        showConfig.loginSuccess = loginSuccess;
        pianoId2.show(showConfig);
      } else {
        util2.log("Current user provider" + provider.name + " is not allowed for amp");
        return;
      }
    }
    function logout(callback) {
      callback = jqUtils2.isFunction(callback) ? callback : goToReturnUrl;
      const provider = user2.getProvider();
      if (provider.getName() === pianoId2.getName()) {
        pianoId2.logout(() => {
          unbindUserWithReaderId(callback);
        });
      } else {
        unbindUserWithReaderId(callback);
      }
    }
    const isUserStateNameValid = (name4) => {
      return /^\w+$/i.test(name4);
    };
    const login = (config) => {
      var userProvider = user2.getProvider().getName();
      if (userProvider === pianoId2.getName()) {
        if (!config) {
          config = {
            userProvider
          };
        } else {
          config = jqUtils2.deepExtend({}, config, {
            userProvider
          });
        }
      }
      var loginConfig = {
        user_transient: true,
        user_provider: composerOnlyProvider
      };
      if (config && config.readerId) {
        loginConfig.reader_id = config.readerId;
      }
      if (config && config.userToken) {
        loginConfig.user_token = config.userToken;
      }
      if (config && config.userProvider) {
        loginConfig.user_provider = config.userProvider;
        loginConfig.user_transient = false;
      }
      if (!validUserState(config)) {
        return false;
      }
      if (config && config.userState) {
        loginConfig.user_state = JSON.stringify(config.userState);
      }
      var apiCallback = (response) => {
        if (response.code === 0) {
          if (config.loginSuccess && jqUtils2.isFunction(config.loginSuccess)) {
            config.loginSuccess();
          }
        } else {
          if (config.loginFail && jqUtils2.isFunction(config.loginFail)) {
            config.loginFail();
          }
        }
      };
      bindUserWithReaderId(loginConfig, apiCallback);
    };
    const unbindUserWithReaderId = (callback) => {
      var apiConfig = {};
      apiConfig.reader_id = util2.getQueryParamByName(READER_ID);
      if (!apiConfig.reader_id) {
        util2.log("reader_id cannot be empty");
        return;
      }
      var endpoint = pn.getExperienceEndpoint(false);
      api2.callApi(_getUnbindURL(), apiConfig, callback, endpoint, false);
    };
    function bindUserWithReaderId(config, callback) {
      var apiConfig = config || {};
      if (!apiConfig.reader_id) {
        apiConfig.reader_id = util2.getQueryParamByName(READER_ID);
      }
      if (!apiConfig.reader_id) {
        util2.log("reader_id cannot be empty");
        return;
      }
      var endpoint = pn.getExperienceEndpoint(false);
      api2.callApi(_getBindURL(), apiConfig, callback, endpoint, false);
    }
    return {
      name: name3,
      showLogin,
      logout,
      login
    };
  })();
  pn.container.register("amp", {
    useValue: amp
  });
  pn.amp = pn.container.resolve("amp");

  // ../src/lib/performanceMetrics.ts
  var performanceMetrics = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    const name3 = "performanceMetrics";
    const entriesToFollow = [
      {
        resourceRegExp: new RegExp("/checkout/offer/show"),
        label: "showOffer"
      },
      {
        resourceRegExp: new RegExp("tinypass.min.js$"),
        label: "tinypassMinJS"
      },
      {
        resourceRegExp: new RegExp("/xbuilder/experience/execute"),
        label: "experienceExecute"
      }
    ];
    let isLoggerReady = false;
    let loggerIframeId;
    let batch = [];
    const EVENT_TP_PERFORMANCE_DATA = "EVENT_TP_PERFORMANCE_DATA";
    const EVENT_LOGGER_READY = "EVENT_LOGGER_READY";
    function init() {
      if (!window.performance || !window.PerformanceObserver) {
        return;
      }
      if (!(typeof performance.getEntries === "function")) {
        return;
      }
      var observe = window.PerformanceObserver.prototype.observe;
      window.PerformanceObserver.prototype.observe = function(...args) {
        try {
          observe.apply(this, args);
        } catch (e) {
        }
      };
      postmessage2.subscribe(EVENT_LOGGER_READY, function(data) {
        loggerIframeId = data.sender;
        isLoggerReady = true;
        execBatch();
      });
      var existingEntries = performance.getEntries();
      onEntriesArrive(existingEntries);
      var observer2 = new PerformanceObserver((list) => {
        onEntriesArrive(list.getEntries());
      });
      observer2.observe({
        entryTypes: ["measure", "resource"]
      });
    }
    init();
    function onEntriesArrive(entries) {
      entries.forEach((entry) => {
        onEntryArrive(entry);
      });
    }
    function onEntryArrive(entry) {
      if (!shouldWatch(entry)) {
        return;
      }
      emitEntry(entry);
    }
    function isReady() {
      return isLoggerReady && loggerIframeId;
    }
    function emitEntry(entry) {
      if (!isReady()) {
        batch.push(entry);
        return;
      }
      batch.push(entry);
      execBatch();
    }
    function execBatch() {
      if (!isReady()) {
        return;
      }
      batch.forEach((_entry) => {
        postmessage2.send(EVENT_TP_PERFORMANCE_DATA, {
          entry: _entry
        }, loggerIframeId);
      });
      batch = [];
    }
    function shouldWatch(entry) {
      return entriesToFollow.some((_entryToFollow) => {
        return entry.name.match(_entryToFollow.resourceRegExp);
      });
    }
    return {
      name: name3
    };
  })();
  pn.container.register("performanceMetrics", {
    useValue: performanceMetrics
  });
  pn.performanceMetrics = pn.container.resolve("performanceMetrics");

  // ../src/lib/doubleOptIn.ts
  var doubleOptIn = (() => {
    const api2 = pn.container.resolve("api");
    const pianoId2 = pn.container.resolve("pianoId");
    const name3 = "doubleOptIn";
    const EMAIL_CONFIRMATION_CHECK_URL = "/email/confirmation/check";
    const checkEmailConfirmed = () => {
      return new Promise((resolve) => {
        api2.callApi(EMAIL_CONFIRMATION_CHECK_URL, {}, (response) => {
          resolve(response);
        });
      });
    };
    const check = () => {
      if (!pn.user.isUserValid()) {
        return;
      }
      checkEmailConfirmed().then((response) => {
        if (response && response.data === false) {
          pianoId2.showEmailConfirmationRequired();
        }
      });
    };
    return {
      name: name3,
      check
    };
  })();
  pn.container.register("doubleOptIn", {
    useValue: doubleOptIn
  });
  pn.doubleOptIn = pn.container.resolve("doubleOptIn");

  // ../src/lib/newscycle.ts
  var newscycle = (() => {
    const api2 = pn.container.resolve("api");
    const postmessage2 = pn.container.resolve("postmessage");
    const util2 = pn.container.resolve("util");
    const name3 = "newscycle";
    const syncSubscriptions = util2.debounce(_syncSubscriptions, 1500);
    const SYNCHRONIZE_SUBSCRIPTIONS_URL = "/externalVerification/synchronizeSubscriptions";
    const callSynchronization = () => {
      return new Promise((resolve, reject) => {
        var requestParams = {
          "aid": pn.aid
        };
        api2.callApi(SYNCHRONIZE_SUBSCRIPTIONS_URL, requestParams, (response) => {
          if (response && response.data) {
            resolve(response.data);
          }
          reject(response.message);
        });
      });
    };
    const subscriptionsHasBeenSynchronize = (data) => {
      postmessage2.broadcast("NEWSCYCLE_HAS_BEEN_SYNCHRONIZED_SUCCESS", { data });
    };
    const subscriptionsHasNotBeenSynchronize = (errorMessage) => {
      util2.error("newscycle module: sync request failed with error: " + errorMessage);
    };
    function _syncSubscriptions() {
      callSynchronization().then(subscriptionsHasBeenSynchronize, subscriptionsHasNotBeenSynchronize);
    }
    return {
      name: name3,
      syncSubscriptions
    };
  })();
  pn.container.register("newscycle", {
    useValue: newscycle
  });
  pn.newscycle = pn.container.resolve("newscycle");

  // ../src/lib/captchaV3.ts
  var captchaV3 = (() => {
    const postmessage2 = pn.container.resolve("postmessage");
    let config = {
      enabled: false,
      captcha3SiteKey: "",
      aid: ""
    };
    const name3 = "captchaV3";
    const onCaptchaConfigReceive = (captchaConfig) => {
      if (captchaConfig && captchaConfig.enabled) {
        config = captchaConfig;
        appendCaptchaScript();
      }
    };
    function onloadCallback() {
      window.grecaptcha.ready(render);
    }
    const render = () => {
      const widget = document.createElement("div");
      widget.id = "tp-recaptcha";
      document.body.appendChild(widget);
      window.grecaptcha.render("tp-recaptcha", {
        sitekey: config.captcha3SiteKey,
        size: "invisible",
        "error-callback": () => {
          widget.style.display = "none";
        }
      });
    };
    const appendCaptchaScript = () => {
      window.onCaptchaV3Load = onloadCallback;
      const scriptUrl = "https://www.google.com/recaptcha/api.js?onload=onCaptchaV3Load&render=explicit";
      const script = document.createElement("script");
      script.src = scriptUrl;
      script.type = "text/javascript";
      script.async = true;
      script.defer = true;
      document.head.appendChild(script);
    };
    const initMessageListener = () => {
      postmessage2.subscribe("set-captcha-v3-config", (messageParams) => {
        onCaptchaConfigReceive(messageParams.params.config);
      });
      postmessage2.subscribe("get-captcha-v3-config", () => {
        postmessage2.broadcast("get-captcha-v3-config-value", { config });
      });
    };
    postmessage2.subscribe("get-captcha-v3-token", (messageParams) => {
      window.grecaptcha.ready(() => getToken(messageParams.params.action));
    });
    const getToken = (action) => {
      window.grecaptcha.execute({ action }).then((token) => {
        postmessage2.broadcast("captcha-v3-token", { token });
      }).catch(() => {
        postmessage2.broadcast("captcha-v3-token", { token: "" });
      });
    };
    function addCaptchaV3() {
      initMessageListener();
    }
    return {
      name: name3,
      addCaptchaV3
    };
  })();
  pn.container.register("captchaV3", {
    useValue: captchaV3
  });
  pn.captchaV3 = pn.container.resolve("captchaV3");

  // ../src/lib/tinypassErrorHandler.ts
  var tinypassErrorHandler = (container = pn.container) => {
    const postmessage2 = container.resolve("postmessage");
    const api2 = container.resolve("api");
    const util2 = container.resolve("util");
    const analytics2 = container.resolve("analytics");
    const versionService2 = container.resolve("versionService");
    const name3 = "tinypassErrorHandler";
    const EVENT_TP_ERROR_HANDLER = "EVENT_TP_ERROR_HANDLER";
    const ANON_LOG_ENDPOINT = "/anon/error/log";
    const RANDOM_SENDER_CHANCE = 1e3;
    const SEND_ERRORS_INTERVAL = 15e3;
    const WDGT_ERROR_TAG = "wgt_err";
    const SDK_TAG = "sdk";
    const INIT_ERROR_TAG = "initError";
    const errors = [];
    let isFirstSending = true;
    const apiEndpoint = () => {
      return api2.getEndpoint() + ANON_LOG_ENDPOINT;
    };
    const initialize = () => {
      try {
        if (!pn.isSandbox()) {
          startErrorsListeners();
          startErrorsSendingWithInterval();
        }
      } catch (e) {
        console.warn("Cannot start watching errors", e);
      }
    };
    const addError = (error, place) => {
      try {
        const details = {
          place,
          tags: [SDK_TAG]
        };
        if (error instanceof Error) {
          details.stack = error.stack;
          details.message = error.message;
        } else {
          details.stack = JSON.stringify(error);
        }
        if (isFirstSending) {
          details.tags = addTag(details.tags, INIT_ERROR_TAG);
        }
        addErrorDetails(details);
      } catch (e) {
      }
    };
    const addErrorDetails = (errorDetails) => {
      if (!isGotChanceToAddError(errorDetails)) {
        return;
      }
      if (isDuplicateError(errors, errorDetails)) {
        return;
      }
      if (!errorDetails.tags) {
        errorDetails.tags = ["unknown"];
      }
      errorDetails.aid = pn.aid;
      errorDetails.v = versionService2.getTinypassVersion();
      const errorWrapper = { details: errorDetails };
      errors.push(errorWrapper);
    };
    function startErrorsListeners() {
      var _a;
      postmessage2.subscribe(EVENT_TP_ERROR_HANDLER, handleErrorFromPostMessage);
      (_a = window.addEventListener) == null ? void 0 : _a.call(window, "error", handleUnhandledError);
    }
    const handleErrorFromPostMessage = (data) => {
      const errors2 = data.params;
      if (Array.isArray(errors2)) {
        errors2.forEach((e) => {
          e.tags.push(pn.aid);
          addErrorDetails(e);
        });
      }
    };
    function handleUnhandledError(event) {
      var _a, _b;
      const message = event.message.toLowerCase();
      const isScriptError = message.indexOf("script error") > -1;
      if (isScriptError) {
        addErrorDetails({
          message: "Probably that is Piano error.",
          url: window.location.href,
          tags: [SDK_TAG]
        });
      } else {
        const error = event == null ? void 0 : event.error;
        if (isNotTinypassError(error == null ? void 0 : error.stack))
          return false;
        addErrorDetails({
          stack: (_a = error == null ? void 0 : error.stack) != null ? _a : "n/a",
          message: (_b = error == null ? void 0 : error.message) != null ? _b : "n/a",
          userAgent: navigator.userAgent,
          tags: [SDK_TAG]
        });
      }
      return false;
    }
    const startErrorsSendingWithInterval = () => {
      setInterval(() => {
        sendErrors();
        isFirstSending = false;
      }, SEND_ERRORS_INTERVAL);
    };
    const sendErrors = () => {
      const unsentErrors = errors.filter((e) => !e.send);
      if (unsentErrors.length === 0) {
        return;
      }
      const errorsDetails = unsentErrors.map((e) => e.details);
      const errorsInfo = {
        type: "console-error-message",
        srcType: "ts",
        log_message: JSON.stringify(errorsDetails)
      };
      analytics2.log.event({
        eventType: "logBeaconRequest" /* LOG_BEACON_REQUEST */,
        payload: {
          url: apiEndpoint(),
          params: errorsInfo
        }
      });
      unsentErrors.forEach((errorWrapper) => errorWrapper.send = true);
    };
    const isDuplicateError = (errors2, error) => {
      const existErrorsAsStrings = errors2.map((e) => JSON.stringify(e.details));
      const errorAsString = JSON.stringify(error);
      return existErrorsAsStrings.indexOf(errorAsString) !== -1;
    };
    const isNotTinypassError = (stack) => {
      return (stack == null ? void 0 : stack.indexOf("tinypass")) === -1;
    };
    const isGotChanceToAddError = (errorDetails) => {
      const isTestingMode = !!util2.__protected__.getLocalStorageItem("tinypassErrorHandlerTestMode");
      return errorDetails.tags.indexOf(WDGT_ERROR_TAG) >= 0 || isTestingMode || getRandomInteger(0, RANDOM_SENDER_CHANCE) === 0;
    };
    const getRandomInteger = (min, max) => {
      const rand = min - 0.5 + Math.random() * (max - min + 1);
      return Math.round(rand);
    };
    const addTag = (tags = [], tag) => {
      return tag ? tags.concat(tag) : tags;
    };
    return {
      name: name3,
      addError,
      initialize
    };
  };
  pn.container.register("tinypassErrorHandler", {
    useValue: tinypassErrorHandler()
  });
  pn.tinypassErrorHandler = pn.container.resolve("tinypassErrorHandler");

  // ../src/lib/main.ts
  var main = (container = pn.container) => {
    const api2 = container.resolve("api");
    const cookie3 = container.resolve("cookie");
    const jqUtils2 = container.resolve("jqUtils");
    const util2 = container.resolve("util");
    const logging2 = container.resolve("logging");
    const fingerprint2 = container.resolve("fingerprint");
    const user2 = container.resolve("user");
    const sha12 = container.resolve("sha1");
    const activetimer = container.resolve("activetimer");
    const scrollDepth2 = container.resolve("scrollDepth");
    const doubleClickForPublisher2 = container.resolve("doubleClickForPublisher");
    const offer2 = container.resolve("offer");
    const viewportExit2 = container.resolve("viewportExit");
    const idle2 = container.resolve("idle");
    const experience2 = container.resolve("experience");
    const pianoId2 = container.resolve("pianoId");
    const pianoEsp2 = container.resolve("pianoEsp");
    const applePayIntegrationService2 = container.resolve("applePayIntegrationService");
    const datatransApplePayIntegrationService2 = container.resolve("datatransApplePayIntegrationService");
    const braintreeGooglePayIntegrationService2 = container.resolve("braintreeGooglePayIntegrationService");
    const cxense2 = container.resolve("cxense");
    const tinypassErrorHandler2 = container.resolve("tinypassErrorHandler");
    const captchaV32 = container.resolve("captchaV3");
    const postmessage2 = pn.container.resolve("postmessage");
    const composerControlPolicy2 = container.resolve("composerControlPolicy");
    const analytics2 = container.resolve("analytics");
    const consent4 = container.resolve("consent");
    const name3 = "main";
    const EXTERNAL_RESOURCES = "exrs";
    const EXTERNAL_RESOURCES_TTL = { minutes: 120 };
    let externalResourcesDef = null;
    const BEACON_REQUEST = "beacon_request";
    const VOUCHER_QUERY = "voucher_code";
    const PASSWORDLESS_TOKEN_QUERY = "passwordless_token";
    const VISIT_ID_COOKIE = "__pvi";
    let unloadRegistered = false;
    let unloadTriggered = false;
    let collectedAds = {};
    let lastReferrer = null;
    const APPLE_PAY_PROVIDERS_IDS = {
      APPLE_PAY_BT: 25,
      APPLE_PAY_SS: 38,
      APPLE_PAY_STRIPE: 41,
      APPLE_PAY_PW: 42,
      DATATRANS_APPLE_PAY: 61
    };
    const APPLE_PAY_PROVIDERS_IDS_SET = new Set(Object.values(APPLE_PAY_PROVIDERS_IDS));
    let _appHasApplePay = void 0;
    let termsPaymentMethodsIDs = [];
    let wasApplePayInitialized = false;
    const IS_WK_WEB_VIEW = isWKWebView();
    function isWKWebView() {
      if (navigator.platform.substr(0, 2) === "iP") {
        var lte9 = /constructor/i.test(window.HTMLElement);
        var nav = window.navigator, ua = nav.userAgent, idb = !!window.indexedDB;
        if (ua.indexOf("Safari") !== -1 && ua.indexOf("Version") !== -1 && !nav.standalone) {
        } else if (!idb && lte9 || !window.statusbar.visible) {
        } else if (window.webkit && window.webkit.messageHandlers || !lte9 || idb) {
          return true;
        }
      }
      return false;
    }
    const loadLastVisit = () => {
      return util2.parseJSON(util2.__protected__.getCookie(VISIT_ID_COOKIE), true) || {};
    };
    const trackPage = (url, tags) => {
      return pageTrack(url, tags);
    };
    const getCurrentDomain = () => {
      return util2.getCurrentDomainFromCookie(VISIT_ID_COOKIE, true);
    };
    const trackCollectedAds = (sync, requestType) => {
      var tempAds = collectedAds;
      collectedAds = {};
      var ads = {};
      for (var type2 in tempAds) {
        if (tempAds.hasOwnProperty(type2)) {
          ads[type2] = ads[type2] || [];
          for (var id in tempAds[type2]) {
            if (tempAds[type2].hasOwnProperty(id)) {
              ads[type2].push(tempAds[type2][id]);
            }
          }
        }
      }
      trackAds(ads, sync, requestType);
    };
    let debouncedTrackAds;
    let visitContainer;
    let pageView;
    const getVisitContainer = () => {
      return visitContainer;
    };
    const getPageView = () => {
      return pageView;
    };
    const getOrGeneratePageViewId = () => {
      if (experience2.execute.invokeCount > 0) {
        dataLayer.refresh();
      }
      cxense2.__protected__.clearWidgets();
      return dataLayer.get("pageViewId");
    };
    function generatePageViewId() {
      function pad(n, width, z) {
        z = z || "0";
        const nn = String(n);
        return nn.length >= width ? nn : new Array(width - nn.length + 1).join(z) + nn;
      }
      if (isCxenseActivated()) {
        return generateCxCompatibleRandomId();
      } else {
        var random = util2.randomString(16);
        var hash = sha12.hash([fingerprint2.getFingerprint(), window.location.href].join(""));
        var now = new Date();
        var time = [pad(now.getFullYear(), 4), pad(now.getMonth() + 1, 2), pad(now.getDate(), 2), pad(now.getHours(), 2), pad(now.getMinutes(), 2), pad(now.getSeconds(), 2), pad(now.getMilliseconds(), 3)].join("-");
        var id = [time, random, hash].join("-");
        return id;
      }
    }
    const getVisitCookieOptions = (domain) => {
      var options = {
        path: "/",
        expires: 1,
        domain: visitContainer.currentDomain
      };
      if (domain) {
        options.domain = domain;
      }
      return options;
    };
    const saveVisitCookie = (visit, options) => {
      visit.domain = options.domain;
      visit.time = new Date().getTime();
      util2.__protected__.setCookieConsent("vx", VISIT_ID_COOKIE, util2.toJSON(visit, true), options);
    };
    const saveLastVisit = (visit) => {
      var options = getVisitCookieOptions();
      if (!visit.domain && !visitContainer.currentDomain) {
        util2.waitCall("domainIsReceived", (domainName) => {
          setVisitCurrentDomain(domainName);
          options.domain = domainName;
          saveVisitCookie(visit, options);
        });
      } else {
        saveVisitCookie(visit, options);
      }
    };
    const isTimeExpired = (visit) => {
      var time = new Date().getTime();
      var msInDay = 864e5;
      var msInMin = 6e4;
      var visitExpireTime = 18e5;
      var browserTimezoneOffset = util2.getBrowserTimezoneOffset() * msInMin;
      var appTimezoneOffset = util2.getAppTimezoneOffset();
      var midnight = new Date(visit.time).setHours(0, 0, 0, 0) + msInDay - browserTimezoneOffset - appTimezoneOffset;
      return visit.time + visitExpireTime < time || time >= midnight;
    };
    const hasExternalReferrer = () => {
      if (util2.__protected__.cameFromFbSubscriptions()) {
        return false;
      }
      if (!visitContainer.currentDomain) {
        return false;
      }
      var referrer = util2.getReferrer();
      if (lastReferrer && lastReferrer === referrer) {
        return false;
      }
      var referrerDomain = util2.getHostname(referrer);
      var thisIsSameDomains = new RegExp(visitContainer.currentDomain.replace(/\./g, "\\.").replace(/^\\./, "\\.?") + "$").test(referrerDomain);
      return Boolean(referrerDomain) && !thisIsSameDomains;
    };
    const refreshVisit = () => {
      var visit = loadLastVisit();
      var thisIsFirstVisit = !visit || !visit.id || !visit.time;
      if (thisIsFirstVisit || isTimeExpired(visit) || hasExternalReferrer()) {
        visit.id = "v-" + generatePageViewId();
      }
      saveLastVisit(visit);
      visitContainer.visit = visit;
    };
    const buildPageTrackParams = (params, url, tags) => {
      var _a, _b;
      var pageTrackSubmitType = "manual";
      let skipPageViewTrack = false;
      if (typeof url === "undefined") {
        url = window.location.href;
      } else if (typeof url === "object") {
        var pageTrackConfig = url;
        if (typeof pageTrackConfig.url === "undefined") {
          throw new Error("Must supply url property");
        }
        url = pageTrackConfig.url;
        if (typeof pageTrackConfig.tags !== "undefined") {
          tags = pageTrackConfig.tags;
        }
        if (typeof pageTrackConfig.submitType !== "undefined") {
          pageTrackSubmitType = pageTrackConfig.submitType;
        }
        skipPageViewTrack = pageTrackConfig.skipPageViewTrack;
      } else {
        throw new Error("First parameter to track page must be a URL or an object");
      }
      if (!tags) {
        tags = pn.tags;
      }
      if (pn.customPageUrl) {
        params["custom_page_url"] = util2.prepareUrlParameter(pn.customPageUrl);
      }
      if (typeof tags !== "undefined") {
        if (Object.prototype.toString.call(tags) !== "[object Array]" && Object.prototype.toString.call(tags) !== "[object String]") {
          util2.log("Tags must be an array or a comma-separated string, ignoring supplied tags");
          tags = "";
        } else if (tags instanceof Array) {
          tags = tags.join(",");
        }
      } else {
        tags = "";
      }
      if (!skipPageViewTrack) {
        pageView.track();
      }
      params["page_session_id"] = pageView.pageSessionId;
      params["track_count"] = pageView.trackCount;
      setPageViewId(params);
      var contentCreatedTime;
      if (pn.contentCreated) {
        contentCreatedTime = pn.contentCreated;
      } else if (pn.contentCreatedSelector && jqUtils2.queryEl(pn.contentCreatedSelector)) {
        contentCreatedTime = (_a = jqUtils2.queryEl(pn.contentCreatedSelector)) == null ? void 0 : _a.innerHTML;
      }
      if (contentCreatedTime) {
        if (!pn.contentCreated) {
          pn.contentCreated = contentCreatedTime;
        }
        params["content_created"] = contentCreatedTime;
      }
      if (typeof pn.contentIsNative === "boolean") {
        params["content_is_native"] = pn.contentIsNative;
      }
      if (pn.zone) {
        params["zone"] = pn.zone;
      }
      if (pn.itemId) {
        params["item_id"] = pn.itemId;
      }
      var contentSection = pn.contentSection || getMetaTagContent("section");
      if (contentSection) {
        params["content_section"] = contentSection;
      }
      var contentAuthor = pn.contentAuthor || getMetaTagContent("author");
      if (contentAuthor) {
        params["content_author"] = contentAuthor;
      }
      var contentId = pn.contentId || getMetaTagContent("id");
      if (contentId) {
        params["content_id"] = contentId;
      }
      var sailthruHid = util2.__protected__.getCookie("sailthru_hid");
      if (sailthruHid) {
        params["sailthru_hid"] = sailthruHid;
      }
      var referrer;
      if (lastReferrer && lastReferrer === util2.getReferrer()) {
        referrer = "";
      } else {
        referrer = util2.getReferrer();
        lastReferrer = referrer;
      }
      params["referer"] = util2.prepareUrlParameter(referrer);
      if (tags) {
        params["tags"] = tags;
      }
      params["url"] = util2.prepareUrlParameter(url);
      params["fingerprint"] = fingerprint2.getFingerprint();
      params["adblocker"] = util2.getAdblockStatus();
      if (params["adblocker"] === util2.ADBLOCKER_STATUS.ENABLED_AFTER_DISABLED || params["adblocker"] === util2.ADBLOCKER_STATUS.ENABLED) {
        pn.setCustomParam("_abr", util2.getAdblockerStatusReason(), "user", true);
        pn.setCustomParam("_absh", util2.getAdblockerHistoryCookieInfo().cookieValue + "", "user", true);
      }
      params["timezone_offset"] = util2.getBrowserTimezoneOffset();
      params["submit_type"] = pageTrackSubmitType;
      var visitId = fetchVisitId();
      params["visit_id"] = visitId;
      params["new_visit"] = checkIfNewVisitAndUpdateLastTrackedVisitId(visitId);
      const getContent = () => dataLayer.get("content") || {};
      params["keywords"] = ((_b = getContent().keywords) == null ? void 0 : _b.join(",")) || "";
      params["title"] = getContent().title || "";
      params["description"] = getContent().description || "";
      params["content_type"] = getContent().type || "";
      ["keywords", "title", "description", "content_type"].forEach((val) => {
        params[val] = params[val].substr(0, 8192);
      });
      params["custom_variables"] = JSON.stringify(pn.customVariables);
      buildPageCustomParams(params);
      consent4.__protected__.addConsentsToParams(params);
      return params;
    };
    const buildPageUnloadParams = () => {
      markVisitToCheckForRefresh();
      return {};
    };
    const buildPageCustomParams = (params) => {
      var customParams = {};
      if (pn.customParams) {
        customParams = jqUtils2.deepExtend({}, pn.customParams);
      }
      if (!jqUtils2.isEmptyObject(customParams)) {
        params["custom_params"] = JSON.stringify(customParams);
      }
      return params;
    };
    const fetchPageViewId = () => {
      return pageView.id;
    };
    const checkIfNewVisitAndUpdateLastTrackedVisitId = (visitId) => {
      var isNewVisit = visitContainer.lastTrackedVisitId !== visitId;
      visitContainer.lastTrackedVisitId = visitId;
      return isNewVisit;
    };
    const markVisitToCheckForRefresh = () => {
      visitContainer.checkForRefresh = true;
    };
    const fetchVisitId = () => {
      if (visitContainer.checkForRefresh) {
        refreshVisit();
        visitContainer.checkForRefresh = false;
      }
      return visitContainer.visit.id;
    };
    const getMetaTagContent = (name4) => {
      var metaTag = document.head.querySelector("meta[name=" + name4 + "]");
      return (metaTag || {}).content;
    };
    const setVisitCurrentDomain = (value) => {
      visitContainer.currentDomain = value;
    };
    const invalidateLastVisit = () => {
      var options = getVisitCookieOptions();
      cookie3.remove(VISIT_ID_COOKIE, options);
    };
    const currentEnvironmentSupportsPageTrack = () => {
      return !(pn.endpoint && pn.endpoint.match(/sandbox/));
    };
    const track = (path, params, callback, sync) => {
      if (!pn.aid || pn.aid.length === 0) {
        util2.log("Must supply a valid tp.aid before calling tp.init()");
        return;
      }
      if (!currentEnvironmentSupportsPageTrack()) {
        return;
      }
      logging2.setTime("track", Math.floor(performance.now() - window.pnInitPerformance));
      util2.waitCall("refreshAccessTokenList", () => {
        util2.waitCall("offerCreate", () => {
          util2.startCall("pageTrack");
          const cbk = function(response) {
            util2.doneCall("pageTrack");
            if (callback) {
              callback(response);
            }
          };
          api2.callApi(path, params, cbk, pn.getExperienceEndpoint(false) + "/api/v3", sync);
        });
      });
    };
    const trackPageUnloadIfNecessary = () => {
      if (unloadRegistered && pageView.trackCount > 0) {
        trackPageUnload();
        resetTimer();
      }
    };
    const trackPageUnload = (sync) => {
      if (!currentEnvironmentSupportsPageTrack() || composerControlPolicy2.denyAll) {
        return;
      }
      try {
        buildPageUnloadParams();
        if (viewportExit2.isInitialized()) {
          viewportExit2.resetSumOfCodesDirectionToDefault();
        }
        unregisterTrackUnload();
      } catch (e) {
        util2.error("main: error on tracking page unload event: ", e);
      }
    };
    const unloadAction = () => {
      if (!unloadTriggered) {
        unloadTriggered = true;
        trackPageUnload(true);
      }
    };
    const registerTrackUnload = () => {
      unloadRegistered = true;
    };
    const isRegisteredTrackUnload = () => {
      return unloadRegistered;
    };
    const unregisterTrackUnload = () => {
      unloadRegistered = false;
    };
    const unloadHandler = () => {
      if (unloadRegistered) {
        unloadAction();
      }
      trackCollectedAds(true, BEACON_REQUEST);
      experience2.__protected__.sendStatisticsExecutedNodes("unload");
    };
    const resetTimer = () => {
      activetimer.resetRecordedTime();
    };
    const resetAds = () => {
      doubleClickForPublisher2.resetAds();
    };
    const setPageViewId = (params) => {
      if (params) {
        params["pageview_id"] = fetchPageViewId();
      }
    };
    const pageTrack = (url, tags) => {
      if (!currentEnvironmentSupportsPageTrack() || composerControlPolicy2.denyAll) {
        return;
      }
      try {
        trackPageUnloadIfNecessary();
        var params = buildPageTrackParams({}, url, tags);
        track("/page/track", params);
        registerTrackUnload();
      } catch (e) {
        util2.error("main: error on page tracking event: ", e);
      }
    };
    const trackAds = (ads, sync, requestType) => {
      return;
      if (jqUtils2.isEmptyObject(ads)) {
        return;
      }
      var params = {
        ads: JSON.stringify(ads),
        url: util2.prepareUrlParameter(window.location.href),
        aid: pn.aid
      };
      var tbc = util2.getTbcCookie();
      if (tbc) {
        params.tbc = tbc;
      }
      setPageViewId(params);
      if (requestType === BEACON_REQUEST) {
        return analytics2.log.event({
          eventType: "logBeaconRequest" /* LOG_BEACON_REQUEST */,
          payload: {
            url: pn.getTrackingEndpoint() + "/api/v3/page/ads/track",
            params
          }
        });
      }
      return track("/page/ads/track", params, void 0, sync);
    };
    const trackAd = (type2, id, ad) => {
      if (!collectedAds[type2]) {
        collectedAds[type2] = {};
      }
      collectedAds[type2][id] = ad;
      debouncedTrackAds();
    };
    const checkVoucher = () => {
      const voucher = util2.getQueryParamByName(VOUCHER_QUERY);
      const passwordlessToken = util2.getQueryParamByName(PASSWORDLESS_TOKEN_QUERY);
      if (voucher && !passwordlessToken) {
        offer2.startRedeemVoucher({
          voucherCode: voucher
        });
      }
    };
    const checkVerificationCode = () => {
      if (user2.getProvider().name !== "pianoId") {
        return;
      }
      util2.waitCall("offerCreate", () => {
        pianoId2.__protected__.checkVerificationCode();
      });
    };
    const externalResourcesDelay = () => {
      if (externalResourcesDef) {
        return externalResourcesDef;
      } else {
        externalResourcesDef = new Promise((resolve) => {
          if (util2.__protected__.getLocalStorageItem(EXTERNAL_RESOURCES) !== null) {
            resolve({
              has_active_apple_pay_card: util2.__protected__.getLocalStorageItem(EXTERNAL_RESOURCES)
            });
          }
          if (!pn.applePayMerchantId) {
            resolve({ has_active_apple_pay_card: null });
            return externalResourcesDef;
          }
          isApplePayExistOnExternalResourcesSetting().then((hasApplePay2) => {
            const completeExternalResourcesSetting = (hasActiveApplePayCard) => {
              resolve({ has_active_apple_pay_card: hasActiveApplePayCard });
              util2.__protected__.setLocalStorageItem("vx", EXTERNAL_RESOURCES, hasActiveApplePayCard, EXTERNAL_RESOURCES_TTL);
            };
            if (hasApplePay2) {
              applePayIntegrationService2.__protected__.applePayCanMakePaymentsWithActiveCard().then(completeExternalResourcesSetting);
            } else {
              completeExternalResourcesSetting(null);
            }
          });
        });
      }
      return externalResourcesDef;
    };
    function isCxenseActivated() {
      return cxense2.__protected__.isActivated();
    }
    const generateCxCompatibleRandomId = () => {
      return util2.__protected__.randomStringCxCompatible();
    };
    function hasApplePay(termsPaymentMethodsIDs2) {
      if (!Array.isArray(termsPaymentMethodsIDs2) || !termsPaymentMethodsIDs2.length) {
        return false;
      }
      for (let paymentMethodID of termsPaymentMethodsIDs2) {
        if (APPLE_PAY_PROVIDERS_IDS_SET.has(paymentMethodID)) {
          return true;
        }
      }
      return false;
    }
    function getOnPaymentMethodsIDsReceiveHandler(onReceive) {
      return function({ params: paymentMethods }) {
        if (_appHasApplePay === void 0) {
          _appHasApplePay = hasApplePay(paymentMethods);
        }
        termsPaymentMethodsIDs = paymentMethods || [];
        onReceive(_appHasApplePay);
      };
    }
    function isApplePayExistOnInit() {
      return isApplePayExist((resolve) => {
        postmessage2.subscribe("ACTIVE_PAYMENT_METHODS_IDS_INITIALIZED", getOnPaymentMethodsIDsReceiveHandler(resolve));
        postmessage2.subscribe("MY_ACCOUNT_ACTIVE_PAYMENT_METHODS_IDS_INITIALIZED", getOnPaymentMethodsIDsReceiveHandler(resolve));
      });
    }
    function isApplePayExistOnExternalResourcesSetting() {
      return isApplePayExist((resolve) => {
        experience2.registerCallback("experienceFlow", () => {
          _appHasApplePay = true;
          resolve(true);
        });
      });
    }
    function isApplePayExist(callback) {
      if (_appHasApplePay !== void 0) {
        return Promise.resolve(_appHasApplePay);
      }
      if (IS_WK_WEB_VIEW) {
        _appHasApplePay = false;
        return Promise.resolve(false);
      }
      return new Promise((resolve) => {
        callback(resolve);
      });
    }
    function appHasApplePay() {
      return _appHasApplePay;
    }
    const initializeBraintreeGooglePay = () => {
      if (jqUtils2.isFunction(braintreeGooglePayIntegrationService2.initialize)) {
        braintreeGooglePayIntegrationService2.initialize();
      }
    };
    const initializeApplePay = () => {
      isApplePayExistOnInit().then((hasApplePay2) => {
        if (!hasApplePay2) {
          return;
        }
        if (!wasApplePayInitialized && jqUtils2.isFunction(applePayIntegrationService2.initialize)) {
          wasApplePayInitialized = true;
          applePayIntegrationService2.initialize();
        }
        initPaymentProvidersAfterMethodsIDChanged(termsPaymentMethodsIDs);
      });
    };
    const initPaymentProvidersAfterMethodsIDChanged = (paymentMethodsIDs) => {
      const isDataTransApplePayExist = paymentMethodsIDs.indexOf(APPLE_PAY_PROVIDERS_IDS.DATATRANS_APPLE_PAY) !== -1;
      if (jqUtils2.isFunction(datatransApplePayIntegrationService2.initialize) && isDataTransApplePayExist) {
        datatransApplePayIntegrationService2.initialize();
      }
    };
    function init() {
      if (!dataLayer.isReady) {
        util2.log("DataLayer should be initialized while calling tp.init()");
        util2.log("DataLayer was initialized by default configs");
        dataLayer.init();
      }
      if (!pn.aid || pn.aid.length === 0) {
        util2.log("Must supply a valid tp.aid before calling tp.init()");
        return;
      }
      debouncedTrackAds = util2.debounce(trackCollectedAds, 3e3);
      visitContainer = {
        currentDomain: getCurrentDomain(),
        lastTrackedVisitId: loadLastVisit().id,
        visit: {},
        checkForRefresh: false
      };
      pageView = {
        id: getOrGeneratePageViewId(),
        pageSessionId: "s-" + generatePageViewId(),
        trackCount: 0,
        tracked: false,
        track: () => {
          if (pageView.tracked) {
            pageView.id = getOrGeneratePageViewId();
          } else {
            pageView.tracked = true;
          }
          pageView.trackCount++;
        }
      };
      if (isCxenseActivated()) {
        pn.cxenseSiteId && dataLayer.set("siteId", pn.cxenseSiteId);
      }
      refreshVisit();
      if (!pn.isMockMode) {
        if (jqUtils2.isFunction(doubleClickForPublisher2.initialize)) {
          doubleClickForPublisher2.initialize();
        }
        if (jqUtils2.isFunction(activetimer.initialize)) {
          activetimer.initialize();
        }
        if (jqUtils2.isFunction(scrollDepth2.initialize)) {
          scrollDepth2.initialize();
        }
      }
      if (jqUtils2.isFunction(idle2.initialize)) {
        idle2.initialize();
      }
      initializeApplePay();
      initializeBraintreeGooglePay();
      if (jqUtils2.isFunction(pianoEsp2.__protected__.init)) {
        pianoEsp2.__protected__.init().catch(() => {
        });
      }
      if (jqUtils2.isFunction(user2.refreshAccessToken)) {
        user2.refreshAccessToken();
      }
      externalResourcesDelay();
      const provider = user2.getProvider();
      if (provider.getName() === pianoId2.getName()) {
        provider.__protected__.extendUserToken();
      }
      captchaV32.addCaptchaV3();
      const param2 = "cxTrackingId";
      const cxTrackingId = util2.getQueryParamByName(param2);
      if (cxTrackingId) {
        util2.removeQueryParamByName(param2);
        analytics2.log.event({
          eventType: "logAutoMicroConversion" /* LOG_AUTO_MICRO_CONVERSION */,
          payload: {
            trackingId: cxTrackingId,
            eventGroupId: "click",
            eventType: "EXTERNAL_LINK" /* EXTERNAL_LINK */,
            customParams: {
              href: location.href,
              source: "CX"
            }
          }
        });
      }
    }
    const checkToRunWidgetImmediately = () => {
      checkVoucher();
      checkVerificationCode();
      pianoId2.checkAndShowEmailIsNotConfirmed();
      if (jqUtils2.isFunction(offer2.checkThreeDSRedirect)) {
        offer2.checkThreeDSRedirect();
      }
    };
    return __spreadProps(__spreadValues({
      name: name3,
      fetchVisitId
    }, deprecatedMethods({
      trackPageUnloadIfNecessary,
      trackPageUnload,
      unregisterTrackUnload,
      isRegisteredTrackUnload,
      registerTrackUnload
    })), {
      externalResourcesDelay,
      pageTrack,
      trackPage,
      buildPageTrackParams,
      fetchPageViewId,
      resetTimer,
      resetAds,
      trackAd,
      init,
      checkToRunWidgetImmediately,
      trackAds,
      appHasApplePay,
      "__private__": __spreadProps(__spreadValues({
        VISIT_ID_COOKIE,
        VOUCHER_QUERY,
        PASSWORDLESS_TOKEN_QUERY,
        collectedAds,
        unloadRegistered,
        unloadTriggered,
        getPageView,
        getVisitContainer,
        track,
        checkVoucher,
        setPageViewId,
        currentEnvironmentSupportsPageTrack,
        invalidateLastVisit,
        getCurrentDomain,
        loadLastVisit,
        setVisitCurrentDomain,
        saveVisitCookie,
        getVisitCookieOptions,
        isTimeExpired,
        refreshVisit,
        generatePageViewId,
        trackCollectedAds
      }, deprecatedMethods({
        buildPageUnloadParams,
        unloadHandler,
        unloadAction
      })), {
        buildPageCustomParams,
        hasExternalReferrer
      })
    });
  };
  pn.container.register("main", {
    useValue: main()
  });
  pn.main = pn.container.resolve("main");

  // ../src/config/sdk-modules.ts
  var publicSDKModuleList = [
    { n: "polyfill", hM: false },
    { n: "predefine", hM: false },
    { n: "predefineTinypass", hM: false },
    { n: "checkTinypass", hM: false },
    { n: "css", hM: true },
    { n: "ajax", hM: true },
    { n: "jqUtils", hM: true },
    { n: "cookie", hM: true },
    { n: "localStorage", hM: true },
    { n: "versionService", hM: true },
    { n: "itp", hM: true },
    { n: "util", hM: true },
    { n: "api", hM: true },
    { n: "postmessage", hM: true },
    { n: "eventUtils", hM: true },
    { n: "janrain", hM: true },
    { n: "sha1", hM: true },
    { n: "containerUtils", hM: true },
    { n: "tinypassLogin", hM: true },
    { n: "tinypassAccounts", hM: true },
    { n: "condeUserProvider", hM: true },
    { n: "gigya", hM: true },
    { n: "jwtDecode", hM: true },
    { n: "log", hM: true },
    { n: "logging", hM: true },
    { n: "observer", hM: true },
    { n: "gaCollectingService", hM: true },
    { n: "gaService", hM: true },
    { n: "ga4Service", hM: true },
    { n: "acp", hM: true },
    { n: "pianoIdLite", hM: true },
    { n: "pianoId", hM: true },
    { n: "user", hM: true },
    { n: "viewportExit", hM: true },
    { n: "template", hM: true },
    { n: "offer", hM: true },
    { n: "myaccount", hM: true },
    { n: "meter", hM: true },
    { n: "fingerprint", hM: true },
    { n: "scrollDepth", hM: true },
    { n: "idle", hM: true },
    { n: "interaction", hM: true },
    { n: "recWidgetService", hM: true },
    { n: "piano", hM: true },
    { n: "pianoEsp", hM: true },
    { n: "swg", hM: true },
    { n: "fbpixel", hM: true },
    { n: "fbsubscriptions", hM: true },
    { n: "cxense", hM: true },
    { n: "experience", hM: true },
    { n: "ifvisible", hM: true },
    { n: "activetimer", hM: true },
    { n: "doubleClickForPublisher", hM: true },
    { n: "applePay", hM: true },
    { n: "goCardlessDropin", hM: true },
    { n: "braintreeGooglePayIntegrationService", hM: true },
    { n: "applePayIntegrationService", hM: true },
    { n: "datatransApplePayIntegrationService", hM: true },
    { n: "stripeApplePayIntegrationService", hM: true },
    { n: "obi3DSChallenge", hM: true },
    { n: "amp", hM: true },
    { n: "performanceMetrics", hM: true },
    { n: "doubleOptIn", hM: true },
    { n: "newscycle", hM: true },
    { n: "captchaV3", hM: true },
    { n: "main", hM: true },
    { n: "tinypassErrorHandler", hM: true },
    { n: "tinypass", hM: true },
    { n: "postProcessing", hM: false },
    { n: "clientConfiguration", hM: true },
    { n: "microsoftQuickAuth", hM: true },
    { n: "frequencyEvent", hM: true }
  ];

  // ../src/lib/tinypass.ts
  var dlContent = (() => {
    let cached = null;
    const send = (data) => {
      cached = data && __spreadValues(__spreadValues({}, cached), data);
      if (dataLayer.isReady && data) {
        dataLayer.set("content", cached);
        cached = null;
      }
    };
    return {
      set: (name3, value) => send({ [name3]: value }),
      get: (name3) => {
        var _a;
        return dataLayer.isReady ? (_a = dataLayer.get("content")) == null ? void 0 : _a[name3] : cached == null ? void 0 : cached[name3];
      },
      init: () => send(cached)
    };
  })();
  var tpPredefinedOptions = {
    predefineValues: []
  };
  if (window.tp && window.tp.length) {
    tpPredefinedOptions.predefineValues = [
      ...window.tp || []
    ];
  }
  pn.tpPredefinedOptions = tpPredefinedOptions;
  pn.container.register("tpPredefinedOptions", {
    useValue: tpPredefinedOptions
  });
  var Tinypass = class {
    constructor(tpPredefinedOptions2, css2, tinypassErrorHandler2, gaService2, ga4Service2, gaCollectingService2, utilService, consent4) {
      this.tpPredefinedOptions = tpPredefinedOptions2;
      this.css = css2;
      this.tinypassErrorHandler = tinypassErrorHandler2;
      this.gaService = gaService2;
      this.ga4Service = ga4Service2;
      this.gaCollectingService = gaCollectingService2;
      this.utilService = utilService;
      this.consent = consent4;
      this.isDataLayerEnabled = true;
      this.fullTPVersion = false;
      this.isInitialized = false;
      this.aid = "";
      this.isSensitiveDataProtectionEnabled = false;
      this.affiliateTokenName = "affiliateToken";
      this.cxCdnUrl = "https://cdn.cxense.com";
      this.c1XLoadCce = true;
      this.c1XIntegrationVersion = "v2";
      this.cxenseLibAwaitingTimeout = 0;
      this.cxenseLibAwaitingRetryCount = 0;
      this.trackPages = true;
      this.debug = false;
      this.userRef = "";
      this.usePianoIdLiteUserProvider = false;
      this.useTinypassAccounts = false;
      this.useCondeUserProvider = false;
      this.useGigyaUserProvider = false;
      this.usePianoIdUserProvider = false;
      this.useAidSpecifiedCookies = false;
      this.sandbox = false;
      this.zIndexes = {
        backdrop: 3e5,
        modal: 300050,
        close: 300100
      };
      this.linkedTermSelectedCallbacks = [];
      this.requestUserAuthForLinkedTerm = true;
      this.customPreChecks = [];
      this.customParams = {};
      this.externalLibraries = [];
      this.externalLibrariesCallbacks = [];
      this.customVariables = {};
      this.locale = "";
      this.trackPageView = true;
      this.redirectToFbTimeout = 3;
      this.isDoubleOptInCheckOnAccessCheckEnabled = false;
      this.isMockMode = false;
      this.inappBrowserReturn = false;
      this.events = [];
      this.appList = [];
      this.cacheableShowTemplate = true;
      this.disableLockConfig = false;
      this.initCallbacks = [];
      this.mainModuleInited = false;
      this.restCallbacks = [];
      this.initTries = 0;
      this.listOfAddedHandlers = [];
      this.callbacks = [];
      css2.loadOfferCss();
    }
    get tags() {
      var _a;
      return (_a = dlContent.get("tags")) == null ? void 0 : _a.join(",");
    }
    set tags(val) {
      let newVal;
      if (Array.isArray(val)) {
        newVal = val;
      } else {
        newVal = typeof val === "string" ? val.split(",") : null;
      }
      dlContent.set("tags", newVal);
    }
    get contentIsNative() {
      return dlContent.get("isNative");
    }
    set contentIsNative(val) {
      dlContent.set("isNative", val);
    }
    get contentId() {
      return dlContent.get("id");
    }
    set contentId(val) {
      dlContent.set("id", val);
    }
    get contentCreated() {
      var _a;
      return ((_a = dlContent.get("createdAt")) == null ? void 0 : _a.toString()) || "";
    }
    set contentCreated(val) {
      dlContent.set("createdAt", val);
    }
    get contentAuthor() {
      var _a;
      return ((_a = dlContent.get("authors")) == null ? void 0 : _a.join(",")) || "";
    }
    set contentAuthor(val) {
      dlContent.set("authors", [val]);
    }
    get contentSection() {
      return dlContent.get("section");
    }
    set contentSection(val) {
      dlContent.set("section", val);
    }
    get zone() {
      return dlContent.get("zone");
    }
    set zone(val) {
      dlContent.set("zone", val);
    }
    initTp() {
      try {
        const predefineValues = this.tpPredefinedOptions.predefineValues;
        this.tpPredefinedOptions.predefineValues = [];
        predefineValues.forEach((predefineValue) => {
          if (typeof predefineValue[1] === "function") {
            if (predefineValue[0] === "init") {
              this.initCallbacks.push(predefineValue[1]);
            } else {
              this.restCallbacks.push(predefineValue);
            }
          } else if (predefineValue[1] === "init" && typeof predefineValue[2] === "function") {
            this.initCallbacks.push(predefineValue[2]);
          } else {
            this.push(predefineValue);
          }
        });
        if (!this.aid && this.initTries < 10) {
          this.initTries++;
          setTimeout(() => this.initTp(), 50);
          return;
        }
        if (!this.aid) {
          return;
        }
        this.tinypassErrorHandler.initialize();
        while (this.restCallbacks.length) {
          try {
            const predefineValue = this.restCallbacks.shift();
            this.push(predefineValue);
          } catch (error) {
            console.error(error);
            pn.tinypassErrorHandler.addError(error);
          }
        }
        this._init();
        if (this.externalLibraries.length) {
          this.realizeExternalLibraries();
        }
        this.isInitialized = true;
        window.___tp = () => {
        };
      } catch (e) {
        pn.tinypassErrorHandler.addError(e, "initTP");
        console.error("init PN process error", e);
      }
    }
    realizeExternalLibraries() {
      const extLibrariesPromiseList = [];
      this.externalLibraries.forEach((extLibrary) => {
        const loadJsPromise = this.utilService.requireJsFile(extLibrary);
        extLibrariesPromiseList.push(loadJsPromise);
      });
      Promise.all(extLibrariesPromiseList).then(() => {
        this.externalLibraries = [];
        if (this.externalLibrariesCallbacks) {
          for (let i = 0; i < this.externalLibrariesCallbacks.length; ++i) {
            tp2.externalLibrariesCallbacks[i]();
          }
        }
        tp2.externalLibrariesCallbacks = [];
      });
    }
    push(...args) {
      let i, f2, parameterArray;
      for (i = 0; i < args.length; i++) {
        parameterArray = args[i];
        f2 = parameterArray.shift();
        if (typeof f2 === "string" || f2 instanceof String) {
          if (!this[f2]) {
            console.error("Undefined method " + f2);
            return;
          }
          this[f2].apply(this, parameterArray);
        } else {
          f2.apply(this, parameterArray);
        }
      }
    }
    init(callback) {
      if (this.isInitialized) {
        if (!this.mainModuleInited) {
          this.mainModuleInited = true;
          this.initMainModuleAfterInitCbk();
        }
        if (callback) {
          callback();
        }
      } else {
        if (callback) {
          this.tpPredefinedOptions.predefineValues.push(["init", callback]);
        }
        this.initTp();
      }
    }
    _init() {
      const config = {};
      if (this.cookieDomain || this.cookiePath) {
        config.cookieDefault = {
          domain: this.cookieDomain,
          path: this.cookiePath
        };
      }
      dataLayer.init(config);
      dlContent.init();
      if (this.cxenseSiteId) {
        dataLayer.set("siteId", this.cxenseSiteId);
      }
      pn.consent.__protected__.init();
      if (pn.util && pn.util.hasQueryParamByName && pn.util.hasQueryParamByName("xpdebug")) {
        pn.setDebug(true);
      }
      pn.util.setTpccCookies();
      if (pn.util.isSafariOrIOsUiWebView() && !pn.user.isUserValid()) {
        if (pn.util.getQueryParamByName("userToken")) {
          const cookieDomain = pn.util.getQueryParamByName("cookieDomain");
          const userToken = pn.util.getQueryParamByName("userToken");
          const tokenListValue = pn.util.getQueryParamByName("tokenListValue");
          pn.util.setAccessTokenListCookie({ cookie_domain: cookieDomain, value: tokenListValue }, userToken);
          pn.util.removeQueryParamByName("userToken");
          pn.util.removeQueryParamByName("cookieDomain");
          pn.util.removeQueryParamByName("tokenListValue");
        }
      }
      if (!this.mainModuleInited) {
        this.mainModuleInited = true;
        this.initMainModuleAfterInitCbk();
      }
      pn.itp.init();
      if (!this.aid) {
        const aidError = new Error(`Incorrect aid integration: ${tp2.aid} url: ${window.location.href}`);
        this.tinypassErrorHandler.addError(aidError);
      }
      pn.logging.setTime("startInit", Math.floor(window.pnInitPerformance));
      pn.logging.setTime("completeInit", Math.floor(performance.now() - window.pnInitPerformance));
    }
    initMainModuleAfterInitCbk() {
      pn.user.providerInit();
      if (this.appList.indexOf(this.aid) < 0) {
        this.appList.push(this.aid);
        pn.main.init();
      }
      while (this.initCallbacks.length) {
        try {
          this.initCallbacks.shift()();
        } catch (error) {
          console.error(error);
          pn.tinypassErrorHandler.addError(error);
        }
      }
      pn.main.checkToRunWidgetImmediately();
      if (this.events) {
        for (let i = 0; i < this.events.length; i++) {
          this.events[i]();
        }
        this.events = [];
      }
    }
    setAid(aid) {
      this.aid = aid;
    }
    enableSensitiveDataProtection(isEnabled) {
      this.isSensitiveDataProtectionEnabled = isEnabled;
    }
    reload() {
      location.href = pn.util.removeVoucherCodeFromUrl(location.href);
    }
    removeSharedAccountCodeFromUrl() {
      location.href = pn.util.removeSharedAccountCodeFromUrl(location.href);
    }
    setGAClientId(clientId) {
      this.gaClientId = clientId;
      this.gaService.recreateWithClientId(clientId);
    }
    getGAClientId() {
      return this.gaClientId;
    }
    enableGACrossDomainLinking(savedUA) {
      this.gaCrossDomainLinking = true;
      const interval = 500;
      const intervalTimeout = 6e4;
      const startTime = Date.now();
      const timeoutIDFunction = () => {
        const ga = window.ga;
        if (ga && typeof ga === "function") {
          try {
            ga((tracker) => {
              if (typeof tracker !== "undefined" && typeof savedUA === "undefined") {
                this.setGAClientId(tracker.get("clientId"));
              } else if (typeof savedUA !== "undefined") {
                const trackers = ga.getAll();
                for (let i = 0; i < trackers.length; i++) {
                  const tempTracker = trackers[i];
                  if (tempTracker.get("trackingId") === savedUA) {
                    this.setGAClientId(tempTracker.get("clientId"));
                    break;
                  }
                }
              }
            });
          } catch (e) {
          }
        } else {
          if (Date.now() - startTime < intervalTimeout) {
            setTimeout(timeoutIDFunction, interval);
          }
        }
      };
      timeoutIDFunction();
    }
    setExcludedGAEvents(events) {
      this.gaCollectingService.setExcludedEvents(events);
    }
    setGA4Config(config) {
      this.ga4Service.setGa4Config(config);
    }
    setTags(tags) {
      if (tags instanceof Array) {
        this.tags = tags.join(",");
      } else {
        this.tags = tags;
      }
    }
    setCookieDomain(value) {
      if (value[0] !== ".") {
        value = "." + value;
      }
      this.cookieDomain = value;
    }
    setStaticDomain(value) {
      this.staticDomain = value;
    }
    setCookiePath(value) {
      this.cookiePath = value;
    }
    setDontScrollTopModal(val) {
      this.dontScrollTopModal = val;
    }
    setUseExperience(val) {
      this.useExperience = val;
    }
    setExperimentalIosModal(val) {
      this.experimentalIosModal = val;
    }
    setApplePayMerchantId(val) {
      this.applePayMerchantId = val;
    }
    setContentIsNative(val) {
      this.contentIsNative = val;
    }
    setComposerHost(val) {
      this.composerHost = val;
    }
    setEndpoint(val) {
      this.endpoint = val;
    }
    setAffiliateTokenName(affiliateTokenName) {
      this.affiliateTokenName = affiliateTokenName;
    }
    setEspEndpoint(val) {
      this.espEndpoint = val;
    }
    setCxCdnUrl(val) {
      this.cxCdnUrl = val;
    }
    setC1XLoadCce(val) {
      this.c1XLoadCce = val;
    }
    setC1XIntegrationVersion(val) {
      this.c1XIntegrationVersion = val;
    }
    setDataLayerEnabled(val) {
      this.isDataLayerEnabled = val;
    }
    setCxenseSiteId(val) {
      this.cxenseSiteId = val;
      dataLayer.set("siteId", val);
    }
    setCxenseLibAwaitingTimeout(val) {
      this.cxenseLibAwaitingTimeout = val;
    }
    setCxenseLibAwaitingRetryCount(val) {
      this.cxenseLibAwaitingRetryCount = val;
    }
    setContentId(val) {
      this.contentId = val;
    }
    setTrackPages(val) {
      this.trackPages = val;
    }
    setDebug(val) {
      this.debug = val;
    }
    setUserRef(val) {
      this.userRef = val;
    }
    setUsePianoIdLiteUserProvider(val) {
      this.usePianoIdLiteUserProvider = val;
    }
    setExternalJWT(val) {
      this.externalJWT = val;
    }
    getExternalJWT() {
      return this.externalJWT;
    }
    setUseTinypassAccounts(val) {
      this.useTinypassAccounts = val;
    }
    setUseCondeUserProvider(val) {
      this.useCondeUserProvider = val;
    }
    setUseGigyaUserProvider(val) {
      this.useGigyaUserProvider = val;
    }
    setUsePianoIdUserProvider(val) {
      this.usePianoIdUserProvider = val;
    }
    setPianoIdUrl(val) {
      this.pianoIdUrl = val;
    }
    setItemId(val) {
      this.itemId = val;
    }
    setUseAidSpecifiedCookies(val) {
      this.useAidSpecifiedCookies = val;
    }
    setSandbox(val) {
      this.sandbox = val;
    }
    setContentCreatedSelector(val) {
      this.contentCreatedSelector = val;
    }
    setContentCreated(val) {
      this.contentCreated = val;
    }
    setContentAuthor(val) {
      this.contentAuthor = val;
    }
    setContentSection(val) {
      this.contentSection = val;
    }
    setZone(val) {
      this.zone = val || "";
    }
    isNonProdEndpoint() {
      var nonProdUrlRegex = /^https?:\/\/(.*sandbox.*|\d+\.dev)\.(tinypass\.com|piano\.io)/i;
      if (this.endpoint === "sandbox") {
        return true;
      }
      return nonProdUrlRegex.test(this.endpoint);
    }
    setZIndexes(val) {
      this.zIndexes = val;
    }
    setCustomPreCheck(handler) {
      this.customPreChecks.push(handler);
    }
    setLinkedTermSelected(handler) {
      if (typeof handler !== "function") {
        return;
      }
      this.linkedTermSelectedCallbacks.push(handler);
    }
    setLinkTermSelected(handler) {
      this.setLinkedTermSelected(handler);
    }
    setRequestUserAuthForLinkedTerm(val) {
      this.requestUserAuthForLinkedTerm = val;
    }
    setDisableLockConfig(val) {
      this.disableLockConfig = val;
    }
    setCustomParam(name3, value, scope, override) {
      const availableScopes = ["content", "user", "request"];
      if (!scope)
        scope = "content";
      scope = scope.toLowerCase();
      if (availableScopes.indexOf(scope) < 0) {
        throw new Error("Undefined scope " + scope + "\nAvailable scopes: " + availableScopes.join(", "));
      }
      if (this.customParams[scope] === void 0) {
        this.customParams[scope] = {};
      }
      if (this.customParams[scope][name3] === void 0 || override) {
        this.customParams[scope][name3] = [];
      }
      var values = [].concat(value);
      for (var i = 0; i < values.length; i++) {
        if (typeof values[i] !== "string") {
          throw new Error("setCustomParam accept only string values or array of strings");
        }
        this.customParams[scope][name3].push(values[i]);
      }
    }
    resetCustomParam(scope) {
      if (!scope) {
        scope = "content";
      }
      delete this.customParams[scope];
    }
    addExternalLibrary(libraries, callback) {
      if (typeof libraries === "string") {
        this.externalLibraries.push(libraries);
      } else {
        for (var i = 0; i < libraries.length; ++i) {
          this.externalLibraries.push(libraries[i]);
        }
      }
      if (callback) {
        this.externalLibrariesCallbacks.push(callback);
      }
      if (this.isInitialized) {
        this.realizeExternalLibraries();
      }
    }
    setCustomVariable(name3, value) {
      this.customVariables[name3] = value;
    }
    saveCustomVariablesToLocalStorage(time) {
      function _getCurrentTimestamp() {
        return Math.floor(new Date().getTime() / 1e3);
      }
      const composerLSSetAsync = (key2, value) => {
        pn.consent.__protected__.async((products2) => {
          var _a;
          return (_a = products2.composer) == null ? void 0 : _a.localStorage.set(key2, value);
        });
      };
      var keyName = "__tp-customVariables";
      composerLSSetAsync(keyName, JSON.stringify(this.customVariables));
      if (time) {
        composerLSSetAsync(keyName + "-expiration", _getCurrentTimestamp() + time + "");
      }
    }
    restoreCustomVariablesFromLocalstorage() {
      if ("localStorage" in window && window["localStorage"] !== null) {
        var customVars = tp2.util.__protected__.getLocalStorageItem("customVariables");
        tp2.util.__protected__.removeLocalStorageItem("customVariables");
        if (customVars) {
          for (var prop in customVars) {
            this.customVariables[prop] = customVars[prop];
          }
        }
      }
    }
    handler(event, callback) {
      const registerPrefixedEvents = this.registerPrefixedEvents;
      return () => {
        const modules = [
          pn.offer,
          pn.template,
          pn.meter,
          pn.experience,
          pn.myaccount,
          pn.pianoId,
          pn.tinypassLogin,
          pn.swg,
          pn.user,
          pn.credit
        ];
        var result;
        for (var i = 0; i < modules.length; i++) {
          var module = modules[i];
          if (!module) {
            continue;
          }
          var res = module.registerCallback(event, callback);
          if (res !== void 0) {
            result = res;
          }
          res = registerPrefixedEvents(module, event, callback);
          if (res !== void 0) {
            result = res;
          }
        }
        return result;
      };
    }
    registerPrefixedEvents(module, event, callback) {
      var prefixes = [
        { module: "offer", prefix: "checkout" },
        { module: "pianoId", prefix: "pianoId" }
      ];
      var moduleEvent, res, result;
      for (var i = 0; i < prefixes.length; i++) {
        var p = prefixes[i];
        if (module.name === p.module && event.substring(0, p.prefix.length) === p.prefix) {
          moduleEvent = event.substring(p.prefix.length, p.prefix.length + 1).toLowerCase() + event.substring(p.prefix.length + 1, event.length);
          res = module.registerCallback(moduleEvent, callback);
          if (res !== void 0) {
            result = res;
          }
        }
      }
      return result;
    }
    addHandler(handlerName, handler) {
      var ev = this.handler(handlerName, handler);
      if (this.isInitialized) {
        ev();
      } else {
        this.events.push(ev);
      }
      this.listOfAddedHandlers.push(handlerName);
    }
    getListOfAddedHandlers() {
      return this.listOfAddedHandlers;
    }
    setTrackPageview(val) {
      this.trackPageView = val;
    }
    setLocale(value) {
      this.locale = value;
      this.utilService.__protected__.setCookie("LANG", this.locale);
      if (this.isInitialized) {
        this.changeLocale(value);
      } else {
        this.initCallbacks.push(() => {
          this.changeLocale(value);
        });
      }
    }
    setPageURL(val) {
      this.customPageUrl = val;
    }
    setAdblockerCookieName(val) {
      this.adblockerCookieName = val;
    }
    setMaxCookieExpirationInDays(val) {
      const maxCookieExpirationInDays = typeof val === "string" ? parseInt(val, 10) : val;
      if (isFinite(maxCookieExpirationInDays) && maxCookieExpirationInDays > 0) {
        this.maxCookieExpirationInDays = maxCookieExpirationInDays;
      } else {
        throw new Error("maxCookieExpirationInDays must be a positive number");
      }
    }
    getMaxCookieExpirationInDays() {
      return this.maxCookieExpirationInDays;
    }
    setFbPixelId(val) {
      this.fbPixelId = val;
    }
    getFbPixelId() {
      return this.fbPixelId;
    }
    setRedirectToFbTimeout(val) {
      this.redirectToFbTimeout = val;
    }
    enableDoubleOptInCheckOnAccessCheck() {
      this.isDoubleOptInCheckOnAccessCheckEnabled = true;
    }
    setCloudflareWorkerUrl(val) {
      this.cloudflareWorkerUrl = val;
    }
    getEndpoint(url, attemptToReturnSecureUrl) {
      if (url.lastIndexOf("/") === url.length - 1) {
        url = url.substr(0, url.length - 1);
      }
      if (url.match(/\/v3$/)) {
        url = url.substr(0, url.lastIndexOf("/v3"));
      }
      if (url.match(/\/api$/)) {
        url = url.substr(0, url.lastIndexOf("/api"));
      }
      if (!url.match(/^(http[s]?:)?\/\//)) {
        url = "//" + url;
      }
      if (typeof attemptToReturnSecureUrl !== "undefined" && attemptToReturnSecureUrl && !url.match(/^http[s]?:/)) {
        url = "https:" + url;
      }
      return url;
    }
    _getEndpointRoot(attemptToReturnSecureUrl) {
      var url = "https://buy.tinypass.com";
      if (this.sandbox === true) {
        this.endpoint = "sandbox";
      }
      if (this.endpoint) {
        if (this.endpoint === "sandbox") {
          url = "https://sandbox.tinypass.com";
        } else if (this.endpoint !== "prod" && this.endpoint !== "production") {
          url = this.endpoint;
        }
      }
      return this.getEndpoint(url, attemptToReturnSecureUrl);
    }
    _getApiEndpoint() {
      return this._getEndpointRoot() + "/api/v3";
    }
    _getTrackingEndpoint(sourceUrl = "") {
      var url = sourceUrl || this.endpoint;
      if (this.sandbox === true) {
        url = "https://sandbox.tinypass.com";
      } else if (typeof this.endpoint === "undefined" || this.endpoint === null || this.endpoint === "" || this.endpoint === "prod" || this.endpoint === "production" || this.endpoint.match(/(buy|api|api-v3)\.tinypass\.com/)) {
        url = sourceUrl || "https://api-v3.tinypass.com";
      }
      return this.getEndpoint(url, true);
    }
    _getExperienceEndpoint(attemptToReturnSecureUrl) {
      var url = "https://c2.piano.io";
      if (this.composerHost) {
        url = this.composerHost;
      } else {
        if (this.sandbox === true) {
          this.endpoint = "sandbox";
        }
        if (this.endpoint) {
          if (this.endpoint === "sandbox") {
            url = "https://c2-sandbox.piano.io";
          } else if (this.endpoint !== "prod" && this.endpoint !== "production") {
            url = this.endpoint;
            url = url.replace("//buy.tinypass.com", "//c2.piano.io");
            url = url.replace("//api.tinypass.com", "//c2.piano.io");
            url = url.replace("//buy-au.piano.io", "//c2-au.piano.io");
            url = url.replace("//api-au.piano.io", "//c2-au.piano.io");
            url = url.replace("//buy-ap.piano.io", "//c2-ap.piano.io");
            url = url.replace("//api-ap.piano.io", "//c2-ap.piano.io");
            url = url.replace("//buy-eu.piano.io", "//c2-eu.piano.io");
            url = url.replace("//api-eu.piano.io", "//c2-eu.piano.io");
            url = url.replace("//sandbox.tinypass.com", "//c2-sandbox.piano.io");
            url = url.replace("//sandbox.piano.io", "//c2-sandbox.piano.io");
            url = url.replace("//experience-au.piano.io", "//c2-au.piano.io");
            url = url.replace("//experience-eu.piano.io", "//c2-eu.piano.io");
            url = url.replace("//experience-ap.piano.io", "//c2-ap.piano.io");
            url = url.replace("//experience.tinypass.com", "//c2.piano.io");
            url = url.replace("//buy.piano.io", "//c2.piano.io");
            url = url.replace("//api.piano.io", "//c2.piano.io");
            url = url.replace("//experience.piano.io", "//c2.piano.io");
          }
        }
      }
      return this.getEndpoint(url, attemptToReturnSecureUrl);
    }
    _isSandbox() {
      return this.sandbox || this.endpoint === "sandbox" || !!this.endpoint && this.endpoint.indexOf("//sandbox.tinypass.com") !== -1;
    }
    changeLocale(value) {
      if (pn.pianoId.isConfigured()) {
        pn.pianoId.updateLang(value);
      }
      pn.postmessage.broadcast("langChanged", { lang: value });
    }
    pageTrack(url, tags) {
      pn.main.pageTrack(url, tags);
    }
    trackPage(url, tags) {
      pn.main.pageTrack(url, tags);
    }
    trackPageUnload() {
      pn.main.trackPageUnload();
    }
    trackAds(ads) {
      pn.main.trackAds(ads);
    }
    trackAd(type2, id, ad) {
      pn.main.trackAd(type2, id, ad);
    }
    onLoad(callback) {
      this.callbacks.push(callback);
    }
    getEndpointRoot(attemptToGetSecureUrl) {
      return this._getEndpointRoot(attemptToGetSecureUrl);
    }
    getExperienceEndpoint(attemptToGetSecureUrl) {
      return this._getExperienceEndpoint(attemptToGetSecureUrl);
    }
    getApiEndpoint() {
      return this._getApiEndpoint();
    }
    getTrackingEndpoint(sourceUrl = "") {
      return this._getTrackingEndpoint(sourceUrl);
    }
    isSandbox() {
      return this._isSandbox();
    }
    setCacheableShowTemplate(enabled) {
      this.cacheableShowTemplate = enabled;
    }
    getCacheableShowTemplate() {
      return this.cacheableShowTemplate;
    }
    setSssAccessToken(token) {
      this.sssAccessToken = token;
    }
    setSssCallbackUrl(url) {
      this.sssCallbackUrl = url;
    }
    setSssMode(mode) {
      this.sssMode = mode;
    }
    setSssOriginUrl(url) {
      this.sssOriginUrl = url;
    }
    verifySignature(payloadString, signatureB64, publicKeyB64) {
      let publicKey = this.utilService.asUint8Array(window.atob(publicKeyB64));
      let payload = this.utilService.asUint8Array(payloadString);
      let signature = this.utilService.asUint8Array(window.atob(signatureB64));
      const signatureAlgorithm = {
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: "SHA-256" }
      };
      return crypto.subtle.importKey("spki", publicKey, signatureAlgorithm, false, ["verify"]).then(function(key2) {
        return crypto.subtle.verify(signatureAlgorithm, key2, signature, payload);
      });
    }
  };
  Tinypass = __decorateClass([
    pn.singleton(),
    __decorateParam(0, pn.inject("tpPredefinedOptions")),
    __decorateParam(1, pn.inject("css")),
    __decorateParam(2, pn.inject("tinypassErrorHandler")),
    __decorateParam(3, pn.inject("gaService")),
    __decorateParam(4, pn.inject("ga4Service")),
    __decorateParam(5, pn.inject("gaCollectingService")),
    __decorateParam(6, pn.inject("util")),
    __decorateParam(7, pn.inject("consent"))
  ], Tinypass);
  pn.container.registerSingleton("tinypass", Tinypass);
  var tpInst = pn.container.resolve("tinypass");
  publicSDKModuleList.forEach((m) => {
    if (m.hM && !pn.container.isRegistered(m.n)) {
      pn.container.resolve(m.n);
    }
  });
  Object.assign(pn, tpInst);
  Object.setPrototypeOf(pn, Tinypass.prototype);
  var tp2 = window.tp = pn;
  pn.initTp();

  // ../src/lib/postProcessing.ts
  var postProcessing = "postProcessing";
})();
/*!
| \#  | name/product                                                              | PA        | DMP     | COMPOSER  | ID        | VX        | ESP     | Social Flow |
| --- | -------------------------------------------------------------------------- | --------- | ------- | --------- | --------- | --------- | ------- | ----------- |
| 0   | Default (not consent selected)                                             | opt-in    | opt-in  | opt-in    | opt-in    | opt-in    | opt-in  | opt-in      |
| 1   | Audience measurement                                                       | opt-in    | opt-in  | opt-out   | opt-out   | opt-out   | opt-out | opt-out     |
| 2   | Audience measurement (Exempted)                                            | essential | opt-out | opt-out   | opt-out   | opt-out   | opt-out | opt-out     |
| 3   | Content performance measurement                                            | opt-in    | opt-out | opt-in    | opt-out   | opt-out   | opt-out | opt-in      |
| 4   | Content performance measurement (Exempted)                                 | essential | opt-out | opt-out   | opt-out   | opt-out   | opt-out | essential   |
| 5   | Personalized content profile creation                                      | opt-out   | opt-in  | opt-in    | opt-out   | opt-out   | opt-out | opt-out     |
| 6   | Personalized ads profile creation                                          | opt-out   | opt-in  | opt-out   | opt-out   | opt-out   | opt-out | opt-out     |
| 7   | Ads performance measurement                                                | opt-out   | opt-out | opt-out   | opt-out   | opt-out   | opt-out | opt-in      |
| 8   | User experience personalization (registration, subscription, newsletter)   | opt-out   | opt-out | opt-in    | opt-in    | opt-in    | opt-in  | opt-out     |
| 9   | Subscription (Exempted)                                                    | opt-out   | opt-out | essential | opt-out   | essential | opt-out | opt-out     |
| 10  | Registration (Exempted)                                                    | opt-out   | opt-out | essential | essential | opt-out   | opt-out | opt-out     |
*/
/**
 * @license
 * Piano Browser SDK-DataLayer@2.10.1.
 * Copyright 2010-2022 Piano Software Inc.
 */
//!event.defaultPrevented
//# sourceMappingURL=tinypass.min.js.map
